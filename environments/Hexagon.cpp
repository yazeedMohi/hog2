//
//  Hexagon.cpp
//  Hexagon
//
//  Created by Nathan Sturtevant on 11/13/21.
//  Copyright Â© 2021 MovingAI. All rights reserved.
//

#include "Hexagon.h"
#include <ctype.h>
#include <string>
#include <map>
#include<cmath>
#include <thread>
#include <cstdlib>
#include "pbPlots.hpp"
#include "supportLib.hpp"
#include "vectorCache.h"
#include <sstream>

#include "SVGUtil.h"
//#include <boost/serialization/map.hpp>
//#include <boost/serialization/set.hpp>
//#include <fstream>

#pragma mark -
#pragma mark Efficient Hexagon Search Code
#pragma mark -

constexpr uint64_t bits(uint64_t a, uint64_t b)
{
//    const uint64_t one = 1;
    return ((((uint64_t)1)<<a)|(((uint64_t)1)<<b));
}

constexpr uint64_t bits(uint64_t a, uint64_t b, uint64_t c, uint64_t d)
{
//    const uint64_t one = 1;
    return ((((uint64_t)1)<<a)|(((uint64_t)1)<<b)|(((uint64_t)1)<<c)|(((uint64_t)1)<<d));
}

constexpr uint64_t bits(uint64_t a, uint64_t b, uint64_t c)
{
//    const uint64_t one = 1;
    return ((((uint64_t)1)<<a)|(((uint64_t)1)<<b)|(((uint64_t)1)<<c));
}

constexpr uint64_t bits(uint64_t a, uint64_t b, uint64_t c, uint64_t d, uint64_t e, uint64_t f)
{
    return bits(a, b, c)|bits(d, e, f);
}

//(1, 2, 3, 9, 10, 11)
const int rotateCWTable[54] =
{5,6,14,15,25,26,37,3,4,12,13,23,24,35,36,46,1,2,10,11,21,22,33,34,44,45,53,0,8,9,19,20,31,32,42,43,51,52,7,17,18,29,30,40,41,49,50,16,27,28,38,39,47,48};

const int flipTable[54] =
{47,48,49,50,51,52,53,38,39,40,41,42,43,44,45,46,27,28,29,30,31,32,33,34,35,36,37,16,17,18,19,20,21,22,23,24,25,26,7,8,9,10,11,12,13,14,15,0,1,2,3,4,5,6};
// 49,39,40,41,42,30
const int mapPiece[numPieces] =    {2, 1, 7, 6, 3, 5, 4, 0, 8, 9};

int noFlipMoveCount[numPieces] =
{
//	kHexagon = 0, 2/c
	4, // no flip symmetry
//	kButterfly = 1, 1/b
	42, // no flip symmetry
//	kElbow = 2, 7/h
	72, // no symmetry
//	kLine = 3, 6/g
	72/2,
//	kMountains = 4, 3/d
	156/2,
//	kWrench = 5, 5/f
	156/2,
//	kTriangle = 6, 4/e
	144/2,
//	kHook = 7, 0/a
	168/2,
//	kTrapezoid = 8, 8/i 9/j
	126,
//	kSnake = 9
	72/2
};

bool printLocTables = false;

uint64_t locations[numPieces][192+1];
uint64_t localized_holes[numPieces][192+1][12+1];

uint64_t localized_holes_side1_odd[numPieces][192+1][12+1];
uint64_t localized_holes_side1_even[numPieces][192+1][12+1];
uint64_t localized_holes_side2_odd[numPieces][192+1][12+1];
uint64_t localized_holes_side2_even[numPieces][192+1][12+1];

const uint64_t hole_locations_orig[numPieces][3] = // 0 1
{
    {
        0, // kHexagon count
        bits(0, 2, 9),//bits(0, 1, 2, 8, 9, 10)
        bits(1, 8, 10),//bits(0, 1, 2, 8, 9, 10)

    },
    {
        1, // kButterfly count
        bits(1, 3, 10),//bits(1, 2, 3, 9, 10, 11)
        bits(2, 9, 11),//bits(1, 2, 3, 9, 10, 11)
    },
    { // elbow piece
        1, // kElbow count
        bits(0, 2, 7),//bits(0, 1, 2, 3, 7, 8)
        bits(1, 3, 8),//bits(0, 1, 2, 3, 7, 8)
    },
    { // long parallelogram - symmetric left to right
        1,
        bits(0, 2, 4),//bits(0, 1, 2, 3, 4, 5)
        bits(1, 3, 5),//bits(0, 1, 2, 3, 4, 5)

//        bits(1, 2, 3, 4, 5, 6)//bits(1, 2, 3, 4, 5, 6)
    },
    { // kMountain
        1,
        bits(0, 2, 7, 9),//bits(0, 1, 2, 7, 8, 9)
        bits(1, 8),//bits(0, 1, 2, 7, 8, 9)

//        bits(1, 2, 3, 10, 11, 12),//bits(1, 2, 3, 10, 11, 12)
    },
    { // long piece a bit like the elbow but asymmetric
        1, // kWrench count
        bits(0, 2, 4),//bits(0, 1, 2, 3, 4, 8) TODOX revert this back
        bits(1, 3, 8),//bits(0, 1, 2, 3, 4, 8)

//      bits(0, 8, 9, 10, 11, 12),//bits(0, 8, 9, 10, 11, 12)
    },
    { // triangle piece
        1, // kTriangle count
        bits(2, 4),
        bits(1, 3, 5, 10),
//        bits(1, 3, 10),//bits(1, 2, 3, 4, 5, 10)
//        bits(2, 4, 5),//bits(1, 2, 3, 4, 5, 10)
//        bits(0, 7, 8, 9, 10, 11),//bits(0, 7, 8, 9, 10, 11)
    },
    
//    { // triangle piece
//        1, // kTriangle count
//        bits(1, 3, 10),//bits(1, 2, 3, 4, 5, 10)
//        bits(2, 4, 5),//bits(1, 2, 3, 4, 5, 10)
//
////        bits(0, 7, 8, 9, 10, 11),//bits(0, 7, 8, 9, 10, 11)
//    },
    {
        1, // kHook count
        bits(0, 9, 11),//bits(0, 1, 8, 9, 10, 11)
        bits(1, 8, 10),//bits(0, 1, 8, 9, 10, 11)

//        bits(0, 1, 2, 3, 8, 9),//bits(0, 1, 2, 3, 8, 9)
    },
    { // small trapezoids -- symmetric left/right
        1,
        bits(0, 2),//bits(0, 1, 2)
        2, // bits(1),//bits(0, 1, 2)  could be problematic
        
//        bits(1, 2, 3),//bits(0, 1, 2)
    },
    {
        1, // kSnake
        bits(0, 2, 11), //bits(0, 1, 2, 10, 11, 12)
        bits(1, 10, 12), //bits(0, 1, 2, 10, 11, 12)

//        bits(2, 3, 4, 8, 9, 10), //bits(2, 3, 4, 8, 9, 10)
    },
};

const uint64_t locations_orig[numPieces][14*6*2+1] =
{ // pieces
	{ // hexagon piece - symmetric in all ways
//		4, // count
//		bits(0, 1, 2, 8, 9, 10), bits(2, 3, 4, 10, 11, 12),
//		bits(9, 10, 11, 19, 20, 21), bits(20, 21, 22, 31, 32, 33)

		// re-ordered so first 4 are the ones we want. The remaining ones are used for symmetry building
		4, // kHexagon count
		bits(0, 1, 2, 8, 9, 10), bits(2, 3, 4, 10, 11, 12), bits(9, 10, 11, 19, 20, 21), bits(20, 21, 22, 31, 32, 33),
		bits(7, 8, 9, 17, 18, 19), bits(11, 12, 13, 21, 22, 23), bits(13, 14, 15, 23, 24, 25), bits(4, 5, 6, 12, 13, 14),
		bits(16, 17, 18, 27, 28, 29), bits(18, 19, 20, 29, 30, 31), bits(22, 23, 24, 33, 34, 35), bits(24, 25, 26, 35, 36, 37),
		bits(28, 29, 30, 38, 39, 40), bits(30, 31, 32, 40, 41, 42), bits(32, 33, 34, 42, 43, 44), bits(34, 35, 36, 44, 45, 46),
		bits(39, 40, 41, 47, 48, 49), bits(41, 42, 43, 49, 50, 51), bits(43, 44, 45, 51, 52, 53)

		
//		19, // count
//		bits(0, 1, 2, 8, 9, 10), bits(2, 3, 4, 10, 11, 12), bits(4, 5, 6, 12, 13, 14),
//		bits(7, 8, 9, 17, 18, 19), bits(9, 10, 11, 19, 20, 21), bits(11, 12, 13, 21, 22, 23), bits(13, 14, 15, 23, 24, 25),
//		bits(16, 17, 18, 27, 28, 29), bits(18, 19, 20, 29, 30, 31), bits(20, 21, 22, 31, 32, 33), bits(22, 23, 24, 33, 34, 35), bits(24, 25, 26, 35, 36, 37l),
//		bits(28, 29, 30, 38, 39, 40), bits(30, 31, 32, 40, 41, 42), bits(32, 33, 34, 42, 43, 44), bits(34, 35, 36, 44, 45, 46),
//		bits(39, 40, 41, 47, 48, 49), bits(41, 42, 43, 49, 50, 51), bits(43, 44, 45, 51, 52, 53)
	},
	{ // butterfly (not in my original set) - symmetric left to right and top to bottom
		42, // kButterfly count
		bits(1, 2, 3, 9, 10, 11), bits(3, 4, 5, 11, 12, 13),
		bits(8, 9, 10, 18, 19, 20), bits(10, 11, 12, 20, 21, 22), bits(12, 13, 14, 22, 23, 24),
		bits(17, 18, 19, 28, 29, 30), bits(19, 20, 21, 30, 31, 32), bits(21, 22, 23, 32, 33, 34), bits(23, 24, 25, 34, 35, 36),
		bits(29, 30, 31, 39, 40, 41), bits(31, 32, 33, 41, 42, 43), bits(33, 34, 35, 43, 44, 45),
		bits(40, 41, 42, 48, 49, 50), bits(42, 43, 44, 50, 51, 52),
		// rotated clockwise
		bits(6, 14, 15, 12, 13, 23), bits(15, 25, 26, 23, 24, 35),
		bits(4, 12, 13, 10, 11, 21), bits(13, 23, 24, 21, 22, 33), bits(24, 35, 36, 33, 34, 44),
		bits(2, 10, 11, 8, 9, 19), bits(11, 21, 22, 19, 20, 31), bits(22, 33, 34, 31, 32, 42), bits(34, 44, 45, 42, 43, 51),
		bits(9, 19, 20, 17, 18, 29), bits(20, 31, 32, 29, 30, 40), bits(32, 42, 43, 40, 41, 49),
		bits(18, 29, 30, 27, 28, 38), bits(30, 40, 41, 38, 39, 47),
		// rotated CCW
		bits(16, 17, 7, 29, 18, 19), bits(7, 8, 0, 19, 9, 10),
		bits(28, 29, 18, 40, 30, 31), bits(18, 19, 9, 31, 20, 21), bits(9, 10, 2, 21, 11, 12),
		bits(39, 40, 30, 49, 41, 42), bits(30, 31, 20, 42, 32, 33), bits(20, 21, 11, 33, 22, 23), bits(11, 12, 4, 23, 13, 14),
		bits(41, 42, 32, 51, 43, 44), bits(32, 33, 22, 44, 34, 35), bits(22, 23, 13, 35, 24, 25),
		bits(43, 44, 34, 53, 45, 46), bits(34, 35, 24, 46, 36, 37)
	},
	{ // elbow piece - note this has rotational symmetry with fliping the piece over
		// so it has 6 30 degree rotations possible
		12*6, // kElbow count
		bits(0, 1, 2, 3, 7, 8), bits(2, 3, 4, 5, 9, 10),
		bits(7, 8, 9, 10, 16, 17), bits(9, 10, 11, 12, 18, 19), bits(11, 12, 13, 14, 20, 21),
		bits(18, 19, 20, 21, 28, 29), bits(20, 21, 22, 23, 30, 31), bits(22, 23, 24, 25, 32, 33),
		bits(30, 31, 32, 33, 39, 40), bits(32, 33, 34, 35, 41, 42), bits(34, 35, 36, 37, 43, 44),
		bits(41, 42, 43, 44, 48, 49),
		// rotated 60
		bits(1, 2, 3, 4, 12, 13), bits(3, 4, 5, 6, 14, 15),
		bits(8, 9, 10, 11, 21, 22), bits(10, 11, 12, 13, 23, 24), bits(12, 13, 14, 15, 25, 26),
		bits(17, 18, 19, 20, 31, 32), bits(19, 20, 21, 22, 33, 34), bits(21, 22, 23, 24, 35, 36),
		bits(27, 28, 29, 30, 40, 41), bits(29, 30, 31, 32, 42, 43), bits(31, 32, 33, 34, 44, 45),
		bits(40, 41, 42, 43, 51, 52),
		// rotated 120 (elbow points right)
		bits(15, 25, 26, 37, 36, 46), bits(24, 35, 36, 46, 45, 53),
		bits(6, 14, 15, 25, 24, 35), bits(13, 23, 24, 35, 34, 44), bits(22, 33, 34, 44, 43, 51),
		bits(4, 12, 13, 23, 22, 33), bits(11, 21, 22, 33, 32, 42), bits(20, 31, 32, 42, 41, 49),
		bits(2, 10, 11, 21, 20, 31), bits(9, 19, 20, 31, 30, 40), bits(18, 29, 30, 40, 39, 47),
		bits(0, 8, 9, 19, 18, 29),
		// rotated 180 (elbow bottom right)
		bits(48, 49, 50, 51, 43, 44), bits(50, 51, 52, 53, 45, 46),
		bits(43, 44, 45, 46, 36, 37), bits(41, 42, 43, 44, 34, 35), bits(39, 40, 41, 42, 32, 33),
		bits(32, 33, 34, 35, 24, 25), bits(30, 31, 32, 33, 22, 23), bits(28, 29, 30, 31, 20, 21),
		bits(20, 21, 22, 23, 13, 14), bits(18, 19, 20, 21, 11, 12), bits(16, 17, 18, 19, 9, 10),
		bits(9, 10, 11, 12, 4, 5),
		// rotated 240 (elbow bottom left)
		bits(47, 48, 49, 50, 38, 39), bits(49, 50, 51, 52, 40, 41),
		bits(38, 39, 40, 41, 27, 28), bits(40, 41, 42, 43, 29, 30), bits(42, 43, 44, 45, 31, 32),
		bits(29, 30, 31, 32, 17, 18), bits(31, 32, 33, 34, 19, 20), bits(33, 34, 35, 36, 21, 22),
		bits(19, 20, 21, 22, 8, 9), bits(21, 22, 23, 24, 10, 11), bits(23, 24, 25, 26, 12, 13),
		bits(10, 11, 12, 13, 1, 2),
		// rotated 300 (elbow left)
		bits(7, 17, 16, 27, 28, 38), bits(0, 8, 7, 17, 18, 29),
		bits(18, 29, 28, 38, 39, 47), bits(9, 19, 18, 29, 30, 40), bits(2, 10, 9, 19, 20, 31),
		bits(20, 31, 30, 40, 41, 49), bits(11, 21, 20, 31, 32, 42), bits(4, 12, 11, 21, 22, 33),
		bits(22, 33, 32, 42, 43, 51), bits(13, 23, 22, 33, 34, 44), bits(6, 14, 13, 23, 24, 35),
		bits(24, 35, 34, 44, 45, 53)
	},
	{ // long parallelogram - symmetric left to right
		24*3, // kLine count
		// regular - flipped
		bits(0, 1, 2, 3, 4, 5),
		bits(7, 8, 9, 10, 11, 12), bits(9, 10, 11, 12, 13, 14),
		bits(16, 17, 18, 19, 20, 21), bits(18, 19, 20, 21, 22, 23), bits(20, 21, 22, 23, 24, 25),
		bits(28, 29, 30, 31, 32, 33), bits(30, 31, 32, 33, 34, 35), bits(32, 33, 34, 35, 36, 37),
		bits(39, 40, 41, 42, 43, 44), bits(41, 42, 43, 44, 45, 46),
		bits(48, 49, 50, 51, 52, 53),
		// one clockwise rotation, flipped
		bits(5, 6, 14, 15, 25, 26),
		bits(3, 4, 12, 13, 23, 24), bits(12, 13, 23, 24, 35, 36),
		bits(1, 2, 10, 11, 21, 22), bits(10, 11, 21, 22, 33, 34), bits(21, 22, 33, 34, 44, 45),
		bits(8, 9, 19, 20, 31, 32), bits(19, 20, 31, 32, 42, 43), bits(31, 32, 42, 43, 51, 52),
		bits(17, 18, 29, 30, 40, 41), bits(29, 30, 40, 41, 49, 50),
		bits(27, 28, 38, 39, 47, 48),
		// one CCW rotation, flipped
		bits(27, 16, 17, 7, 8, 0),
		bits(38, 28, 29, 18, 19, 9), bits(29, 18, 19, 9, 10, 2),
		bits(47, 39, 40, 30, 31, 20), bits(40, 30, 31, 20, 21, 11), bits(31, 20, 21, 11, 12, 4),
		bits(49, 41, 42, 32, 33, 22), bits(42, 32, 33, 22, 23, 13), bits(33, 22, 23, 13, 14, 6),
		bits(51, 43, 44, 34, 35, 24), bits(44, 34, 35, 24, 25, 15),
		bits(53, 45, 46, 36, 37, 26),
		// kLine initial
		bits(1, 2, 3, 4, 5, 6),
		bits(8, 9, 10, 11, 12, 13), bits(10, 11, 12, 13, 14, 15),
		bits(17, 18, 19, 20, 21, 22), bits(19, 20, 21, 22, 23, 24), bits(21, 22, 23, 24, 25, 26),
		bits(27, 28, 29, 30, 31, 32), bits(29, 30, 31, 32, 33, 34), bits(31, 32, 33, 34, 35, 36),
		bits(38, 39, 40, 41, 42, 43), bits(40, 41, 42, 43, 44, 45),
		bits(47, 48, 49, 50, 51, 52),
		// one clockwise rotation
		bits(6, 14, 15, 25, 26, 37),
		bits(4, 12, 13, 23, 24, 35), bits(13, 23, 24, 35, 36, 46),
		bits(2, 10, 11, 21, 22, 33), bits(11, 21, 22, 33, 34, 44), bits(22, 33, 34, 44, 45, 53),
		bits(0, 8, 9, 19, 20, 31), bits(9, 19, 20, 31, 32, 42), bits(20, 31, 32, 42, 43, 51),
		bits(7, 17, 18, 29, 30, 40), bits(18, 29, 30, 40, 41, 49),
		bits(16, 27, 28, 38, 39, 47),
		// one CCW rotation
		bits(16, 17, 7, 8, 0, 1),
		bits(28, 29, 18, 19, 9, 10), bits(18, 19, 9, 10, 2, 3),
		bits(39, 40, 30, 31, 20, 21), bits(30, 31, 20, 21, 11, 12), bits(20, 21, 11, 12, 4, 5),
		bits(48, 49, 41, 42, 32, 33), bits(41, 42, 32, 33, 22, 23), bits(32, 33, 22, 23, 13, 14),
		bits(50, 51, 43, 44, 34, 35), bits(43, 44, 34, 35, 24, 25),
		bits(52, 53, 45, 46, 36, 37),	},
	{ // two trapezoids on top of each other [kMountain] (note some are removed because they leave unfillable gaps
		52*3, // kMountains count
		// original
		bits(0, 1, 2, 7, 8, 9), bits(2, 3, 4, 9, 10, 11), bits(4, 5, 6, 11, 12, 13),
		bits(7, 8, 9, 16, 17, 18), bits(9, 10, 11, 18, 19, 20), bits(11, 12, 13, 20, 21, 22), bits(13, 14, 15, 22, 23, 24),
		bits(18, 19, 20, 28, 29, 30), bits(20, 21, 22, 30, 31, 32), bits(22, 23, 24, 32, 33, 34), //bits(24, 25, 26, 34, 35, 36),
		bits(30, 31, 32, 39, 40, 41), bits(32, 33, 34, 41, 42, 43), //bits(34, 35, 36, 43, 44, 45),
		bits(41, 42, 43, 48, 49, 50), //bits(43, 44, 45, 50, 51, 52),
		// original flipped both left/right and up/down
		/*bits(1, 2, 3, 8, 9, 10),*/ bits(3, 4, 5, 10, 11, 12),
		/*bits(8, 9, 10, 17, 18, 19),*/ bits(10, 11, 12, 19, 20, 21), bits(12, 13, 14, 21, 22, 23),
		/*bits(17, 18, 19, 27, 28, 29),*/ bits(19, 20, 21, 29, 30, 31), bits(21, 22, 23, 31, 32, 33), bits(23, 24, 25, 33, 34, 35),
		bits(29, 30, 31, 38, 39, 40), bits(31, 32, 33, 40, 41, 42), bits(33, 34, 35, 42, 43, 44), bits(35, 36, 37, 44, 45, 46),
		bits(40, 41, 42, 47, 48, 49), bits(42, 43, 44, 49, 50, 51), bits(44, 45, 46, 51, 52, 53),
		
		// original rotated CW - 52+
		bits(5, 6, 14, 3, 4, 12), bits(14, 15, 25, 12, 13, 23), bits(25, 26, 37, 23, 24, 35),
		bits(3, 4, 12, 1, 2, 10), bits(12, 13, 23, 10, 11, 21), bits(23, 24, 35, 21, 22, 33), bits(35, 36, 46, 33, 34, 44),
		bits(10, 11, 21, 8, 9, 19), bits(21, 22, 33, 19, 20, 31), bits(33, 34, 44, 31, 32, 42),
		bits(19, 20, 31, 17, 18, 29), bits(31, 32, 42, 29, 30, 40),
		bits(29, 30, 40, 27, 28, 38),
		// flipped top to bottom and left to right
		bits(15, 25, 26, 13, 23, 24),
		bits(13, 23, 24, 11, 21, 22), bits(24, 35, 36, 22, 33, 34),
		bits(11, 21, 22, 9, 19, 20), bits(22, 33, 34, 20, 31, 32), bits(34, 44, 45, 32, 42, 43),
		bits(9, 19, 20, 7, 17, 18), bits(20, 31, 32, 18, 29, 30), bits(32, 42, 43, 30, 40, 41), bits(43, 51, 52, 41, 49, 50),
		bits(18, 29, 30, 16, 27, 28), bits(30, 40, 41, 28, 38, 39), bits(41, 49, 50, 39, 47, 48),
		
		// original rotated CCW - 104+
		bits(27, 16, 17, 38, 28, 29), bits(17, 7, 8, 29, 18, 19), bits(8, 0, 1, 19, 9, 10),
		bits(38, 28, 29, 47, 39, 40), bits(29, 18, 19, 40, 30, 31), bits(19, 9, 10, 31, 20, 21), bits(10, 2, 3, 21, 11, 12),
		bits(40, 30, 31, 49, 41, 42), bits(31, 20, 21, 42, 32, 33), bits(21, 11, 12, 33, 22, 23),
		bits(42, 32, 33, 51, 43, 44), bits(33, 22, 23, 44, 34, 35),
		bits(44, 34, 35, 53, 45, 46),
		// flipped top to bottom and left to right (180 degree rotation)
		bits(7, 8, 0, 18, 19, 9),
		bits(18, 19, 9, 30, 31, 20), bits(9, 10, 2, 20, 21, 11),
		bits(30, 31, 20, 41, 42, 32), bits(20, 21, 11, 32, 33, 22), bits(11, 12, 4, 22, 23, 13),
		bits(41, 42, 32, 50, 51, 43), bits(32, 33, 22, 43, 44, 34), bits(22, 23, 13, 34, 35, 24), bits(13, 14, 6, 24, 25, 15),
		bits(43, 44, 34, 52, 53, 45), bits(34, 35, 24, 45, 46, 36), bits(24, 25, 15, 36, 37, 26),

		// original flipped top to bottom
		bits(1, 2, 3, 10, 11, 12), //bits(3, 4, 5, 12, 13, 14),
		bits(8, 9, 10, 19, 20, 21), bits(10, 11, 12, 21, 22, 23), //bits(12, 13, 14, 23, 24, 25),
		bits(17, 18, 19, 29, 30, 31), bits(19, 20, 21, 31, 32, 33), bits(21, 22, 23, 33, 34, 35), //bits(23, 24, 25, 35, 36, 37),
		bits(27, 28, 29, 38, 39, 40), bits(29, 30, 31, 40, 41, 42), bits(31, 32, 33, 42, 43, 44), bits(33, 34, 35, 44, 45, 46),
		bits(38, 39, 40, 47, 48, 49), bits(40, 41, 42, 49, 50, 51), bits(42, 43, 44, 51, 52, 53),
		// original flipped left to right
		bits(0, 1, 2, 9, 10, 11), bits(2, 3, 4, 11, 12, 13), bits(4, 5, 6, 13, 14, 15),
		bits(7, 8, 9, 18, 19, 20), bits(9, 10, 11, 20, 21, 22), bits(11, 12, 13, 22, 23, 24), bits(13, 14, 15, 24, 25, 26),
		/*16-18,28-30,*/ bits(18, 19, 20, 30, 31, 32), bits(20, 21, 22, 32, 33, 34), bits(22, 23, 24, 34, 35, 36),
		/*28-30,39-41,*/ bits(30, 31, 32, 41, 42, 43), bits(32, 33, 34, 43, 44, 45),
		/*39-41,48-50,*/ bits(41, 42, 43, 50, 51, 52),
		
		// original rotated CW flipped top to bottom
		bits(6, 14, 15, 13, 23, 24),
		bits(4, 12, 13, 11, 21, 22), bits(13, 23, 24, 22, 33, 34),
		bits(2, 10, 11, 9, 19, 20), bits(11, 21, 22, 20, 31, 32), bits(22, 33, 34, 32, 42, 43),
		bits(0, 8, 9, 7, 17, 18), bits(9, 19, 20, 18, 29, 30), bits(20, 31, 32, 30, 40, 41), bits(32, 42, 43, 41, 49, 50),
		bits(7, 17, 18, 16, 27, 28), bits(18, 29, 30, 28, 38, 39), bits(30, 40, 41, 39, 47, 48),
		// original rotated CW flipped left to right
		bits(5, 6, 14, 12, 13, 23), bits(14, 15, 25, 23, 24, 35), bits(25, 26, 37, 35, 36, 46),
		bits(3, 4, 12, 10, 11, 21), bits(12, 13, 23, 21, 22, 33), bits(23, 24, 35, 33, 34, 44), bits(35, 36, 46, 44, 45, 53),
		bits(10, 11, 21, 19, 20, 31), bits(21, 22, 33, 31, 32, 42), bits(33, 34, 44, 42, 43, 51),
		bits(19, 20, 31, 29, 30, 40), bits(31, 32, 42, 40, 41, 49),
		bits(29, 30, 40, 38, 39, 47),
		
		// original rotated CCW flipped top to bottom
		bits(16, 17, 7, 18, 19, 9),
		bits(28, 29, 18, 30, 31, 20), bits(18, 19, 9, 20, 21, 11),
		bits(39, 40, 30, 41, 42, 32), bits(30, 31, 20, 32, 33, 22), bits(20, 21, 11, 22, 23, 13),
		bits(48, 49, 41, 50, 51, 43), bits(41, 42, 32, 43, 44, 34), bits(32, 33, 22, 34, 35, 24), bits(22, 23, 13, 24, 25, 15),
		bits(50, 51, 43, 52, 53, 45), bits(43, 44, 34, 45, 46, 36), bits(34, 35, 24, 36, 37, 26),
		// original rotated CCW flipped left to right
		bits(27, 16, 17, 29, 18, 19), bits(17, 7, 8, 19, 9, 10), bits(8, 0, 1, 10, 2, 3),
		bits(38, 28, 29, 40, 30, 31), bits(29, 18, 19, 31, 20, 21), bits(19, 9, 10, 21, 11, 12), bits(10, 2, 3, 12, 4, 5),
		bits(40, 30, 31, 42, 32, 33), bits(31, 20, 21, 33, 22, 23), bits(21, 11, 12, 23, 13, 14),
		bits(42, 32, 33, 44, 34, 35), bits(33, 22, 23, 35, 24, 25),
		bits(44, 34, 35, 46, 36, 37),
	},
	{ // long piece a bit like the elbow but asymmetric
		13*6*2, // kWrench count
		// meaning there are 6 rotations x 2 after flipping
		// standard
		bits(0, 1, 2, 3, 4, 8), bits(2, 3, 4, 5, 6, 10),
		bits(7, 8, 9, 10, 11, 17), bits(9, 10, 11, 12, 13, 19), bits(11, 12, 13, 14, 15, 21),
		bits(16, 17, 18, 19, 20, 27), bits(18, 19, 20, 21, 22, 29), bits(20, 21, 22, 23, 24, 31), bits(22, 23, 24, 25, 26, 33),
		bits(28, 29, 30, 31, 32, 38), bits(30, 31, 32, 33, 34, 40), bits(32, 33, 34, 35, 36, 42),
		bits(39, 40, 41, 42, 43, 47),
		// rotated 60
		bits(4, 5, 6, 14, 15, 25), bits(13, 14, 15, 25, 26, 37),
		bits(2, 3, 4, 12, 13, 23), bits(11, 12, 13, 23, 24, 35), bits(22, 23, 24, 35, 36, 46),
		bits(0, 1, 2, 10, 11, 21), bits(9, 10, 11, 21, 22, 33), bits(20, 21, 22, 33, 34, 44), bits(32, 33, 34, 44, 45, 53),
		bits(7, 8, 9, 19, 20, 31), bits(18, 19, 20, 31, 32, 42), bits(30, 31, 32, 42, 43, 51),
		bits(16, 17, 18, 29, 30, 40),
		// rotated 120
		bits(25, 26, 36, 37, 45, 46), bits(35, 36, 45, 46, 52, 53),
		bits(14, 15, 24, 25, 34, 35), bits(23, 24, 34, 35, 43, 44), bits(33, 34, 43, 44, 50, 51),
		bits(5, 6, 13, 14, 22, 23), bits(12, 13, 22, 23, 32, 33), bits(21, 22, 32, 33, 41, 42), bits(31, 32, 41, 42, 48, 49),
		bits(3, 4, 11, 12, 20, 21), bits(10, 11, 20, 21, 30, 31), bits(19, 20, 30, 31, 39, 40),
		bits(1, 2, 9, 10, 18, 19),
		// rotated 180
		bits(47, 48, 49, 50, 51, 43), bits(49, 50, 51, 52, 53, 45),
		bits(38, 39, 40, 41, 42, 32), bits(40, 41, 42, 43, 44, 34), bits(42, 43, 44, 45, 46, 36),
		bits(27, 28, 29, 30, 31, 20), bits(29, 30, 31, 32, 33, 22), bits(31, 32, 33, 34, 35, 24), bits(33, 34, 35, 36, 37, 26),
		bits(17, 18, 19, 20, 21, 11), bits(19, 20, 21, 22, 23, 13), bits(21, 22, 23, 24, 25, 15),
		bits(10, 11, 12, 13, 14, 6),
		// rotated 240
		bits(28, 38, 39, 47, 48, 49), bits(16, 27, 28, 38, 39, 40),
		bits(30, 40, 41, 49, 50, 51), bits(18, 29, 30, 40, 41, 42), bits(7, 17, 18, 29, 30, 31),
		bits(32, 42, 43, 51, 52, 53), bits(20, 31, 32, 42, 43, 44), bits(9, 19, 20, 31, 32, 33), bits(0, 8, 9, 19, 20, 21),
		bits(22, 33, 34, 44, 45, 46), bits(11, 21, 22, 33, 34, 35), bits(2, 10, 11, 21, 22, 23),
		bits(13, 23, 24, 35, 36, 37),
		// rotated 300
		bits(0, 1, 7, 8, 17, 18), bits(7, 8, 16, 17, 27, 28),
		bits(2, 3, 9, 10, 19, 20), bits(9, 10, 18, 19, 29, 30), bits(18, 19, 28, 29, 38, 39),
		bits(4, 5, 11, 12, 21, 22), bits(11, 12, 20, 21, 31, 32), bits(20, 21, 30, 31, 40, 41), bits(30, 31, 39, 40, 47, 48),
		bits(13, 14, 22, 23, 33, 34), bits(22, 23, 32, 33, 42, 43), bits(32, 33, 41, 42, 49, 50),
		bits(34, 35, 43, 44, 51, 52),
		// standard - flipped
		bits(0, 1, 2, 3, 4, 12), bits(2, 3, 4, 5, 6, 14),
		bits(7, 8, 9, 10, 11, 21), bits(9, 10, 11, 12, 13, 23), bits(11, 12, 13, 14, 15, 25),
		bits(16, 17, 18, 19, 20, 31), bits(18, 19, 20, 21, 22, 33), bits(20, 21, 22, 23, 24, 35), bits(22, 23, 24, 25, 26, 37),
		bits(28, 29, 30, 31, 32, 42), bits(30, 31, 32, 33, 34, 44), bits(32, 33, 34, 35, 36, 46),
		bits(41, 42, 43, 44, 45, 53),
		// rotated 60 - flipped
		bits(24, 5, 6, 14, 15, 25), bits(36, 14, 15, 25, 26, 37),
		bits(22, 3, 4, 12, 13, 23), bits(34, 12, 13, 23, 24, 35), bits(45, 23, 24, 35, 36, 46),
		bits(20, 1, 2, 10, 11, 21), bits(32, 10, 11, 21, 22, 33), bits(43, 21, 22, 33, 34, 44), bits(52, 33, 34, 44, 45, 53),
		bits(30, 8, 9, 19, 20, 31), bits(41, 19, 20, 31, 32, 42), bits(50, 31, 32, 42, 43, 51),
		bits(48, 29, 30, 40, 41, 49),
		// rotated 120 - flipped
		bits(44, 26, 36, 37, 45, 46), bits(51, 36, 45, 46, 52, 53),
		bits(33, 15, 24, 25, 34, 35), bits(42, 24, 34, 35, 43, 44), bits(49, 34, 43, 44, 50, 51),
		bits(21, 6, 13, 14, 22, 23), bits(31, 13, 22, 23, 32, 33), bits(40, 22, 32, 33, 41, 42), bits(47, 32, 41, 42, 48, 49),
		bits(19, 4, 11, 12, 20, 21), bits(29, 11, 20, 21, 30, 31), bits(38, 20, 30, 31, 39, 40),
		bits(27, 9, 19, 18, 28, 29),
		// rotated 180 - flipped
		bits(47, 48, 49, 50, 51, 39), bits(49, 50, 51, 52, 53, 41),
		bits(38, 39, 40, 41, 42, 28), bits(40, 41, 42, 43, 44, 30), bits(42, 43, 44, 45, 46, 32),
		bits(27, 28, 29, 30, 31, 16), bits(29, 30, 31, 32, 33, 18), bits(31, 32, 33, 34, 35, 20), bits(33, 34, 35, 36, 37, 22),
		bits(17, 18, 19, 20, 21, 7), bits(19, 20, 21, 22, 23, 9), bits(21, 22, 23, 24, 25, 11),
		bits(8, 9, 10, 11, 12, 0),
		// rotated 240 - flipped
		bits(28, 38, 39, 47, 48, 29), bits(16, 27, 28, 38, 39, 17),
		bits(30, 40, 41, 49, 50, 31), bits(18, 29, 30, 40, 41, 19), bits(7, 17, 18, 29, 30, 8),
		bits(32, 42, 43, 51, 52, 33), bits(20, 31, 32, 42, 43, 21), bits(9, 19, 20, 31, 32, 10), bits(0, 8, 9, 19, 20, 1),
		bits(22, 33, 34, 44, 45, 23), bits(11, 21, 22, 33, 34, 12), bits(2, 10, 11, 21, 22, 3),
		bits(4, 12, 13, 23, 24, 5),
		// rotated 300 - flipped
		bits(0, 1, 7, 8, 17, 2), bits(7, 8, 16, 17, 27, 9),
		bits(2, 3, 9, 10, 19, 4), bits(9, 10, 18, 19, 29, 11), bits(18, 19, 28, 29, 38, 20),
		bits(4, 5, 11, 12, 21, 6), bits(11, 12, 20, 21, 31, 13), bits(20, 21, 30, 31, 40, 22), bits(30, 31, 39, 40, 47, 32),
		bits(13, 14, 22, 23, 33, 15), bits(22, 23, 32, 33, 42, 24), bits(32, 33, 41, 42, 49, 34),
		bits(24, 25, 34, 35, 44, 26),
	},
	{ // triangle piece
		12*6*2, // kTriangle count
		// regular
		bits(1, 2, 3, 4, 5, 10),
		bits(8, 9, 10, 11, 12, 19), bits(10, 11, 12, 13, 14, 21),
		bits(17, 18, 19, 20, 21, 29), bits(19, 20, 21, 22, 23, 31), bits(21, 22, 23, 24, 25, 33),
		bits(27, 28, 29, 30, 31, 38), bits(29, 30, 31, 32, 33, 40), bits(31, 32, 33, 34, 35, 42), bits(33, 34, 35, 36, 37, 44),
		bits(38, 39, 40, 41, 42, 47), bits(40, 41, 42, 43, 44, 49),
		// rotated 60
		bits(6, 13, 14, 15, 25, 26),
		bits(4, 11, 12, 13, 23, 24), bits(13, 22, 23, 24, 35, 36),
		bits(2, 9, 10, 11, 21, 22), bits(11, 20, 21, 22, 33, 34), bits(22, 32, 33, 34, 44, 45),
		bits(0, 7, 8, 9, 19, 20), bits(9, 18, 19, 20, 31, 32), bits(20, 30, 31, 32, 42, 43), bits(32, 41, 42, 43, 51, 52),
		bits(7, 16, 17, 18, 29, 30), bits(18, 28, 29, 30, 40, 41),
		// rotated 120
		bits(35, 36, 37, 45, 46, 53),
		bits(23, 24, 25, 34, 35, 44), bits(33, 34, 35, 43, 44, 51),
		bits(12, 13, 14, 22, 23, 33), bits(21, 22, 23, 32, 33, 42), bits(31, 32, 33, 41, 42, 49),
		bits(3, 4, 5, 11, 12, 21), bits(10, 11, 12, 20, 21, 31), bits(19, 20, 21, 30, 31, 40), bits(29, 30, 31, 39, 40, 47),
		bits(1, 2, 3, 9, 10, 19), bits(8, 9, 10, 18, 19, 29),
		// rotated 180
		bits(48, 49, 50, 51, 52, 43),
		bits(41, 42, 43, 44, 45, 34), bits(39, 40, 41, 42, 43, 32),
		bits(32, 33, 34, 35, 36, 24), bits(30, 31, 32, 33, 34, 22), bits(28, 29, 30, 31, 32, 20),
		bits(22, 23, 24, 25, 26, 15), bits(20, 21, 22, 23, 24, 13), bits(18, 19, 20, 21, 22, 11), bits(16, 17, 18, 19, 20, 9),
		bits(6, 11, 12, 13, 14, 15), bits(9, 10, 11, 12, 13, 4),
		// rotated 240
		bits(27, 28, 38, 39, 40, 47),
		bits(29, 30, 40, 41, 42, 49), bits(17, 18, 29, 30, 31, 40),
		bits(31, 32, 42, 43, 44, 51), bits(19, 20, 31, 32, 33, 42), bits(8, 9, 19, 20, 21, 31),
		bits(33, 34, 44, 45, 46, 53), bits(21, 22, 33, 34, 35, 44), bits(10, 11, 21, 22, 23, 33), bits(1, 2, 10, 11, 12, 21),
		bits(23, 24, 35, 36, 37, 46), bits(12, 13, 23, 24, 25, 35),
		// rotated 300
		bits(0, 7, 8, 16, 17, 18),
		bits(9, 18, 19, 28, 29, 30), bits(2, 9, 10, 18, 19, 20),
		bits(20, 30, 31, 39, 40, 41), bits(11, 20, 21, 30, 31, 32), bits(4, 11, 12, 20, 21, 22),
		bits(32, 41, 42, 48, 49, 50), bits(22, 32, 33, 41, 42, 43), bits(13, 22, 23, 32, 33, 34), bits(6, 13, 14, 22, 23, 24),
		bits(34, 43, 44, 50, 51, 52), bits(24, 34, 35, 43, 44, 45),
		// flipped
		bits(0, 7, 8, 9, 10, 11), bits(2, 9, 10, 11, 12, 13),
		bits(7, 16, 17, 18, 19, 20), bits(9, 18, 19, 20, 21, 22), bits(11, 20, 21, 22, 23, 24), bits(13, 22, 23, 24, 25, 26),
		bits(18, 28, 29, 30, 31, 32), bits(20, 30, 31, 32, 33, 34), bits(22, 32, 33, 34, 35, 36),
		bits(30, 39, 40, 41, 42, 43), bits(32, 41, 42, 43, 44, 45),
		bits(41, 48, 49, 50, 51, 52),
		// rotated 60 - flipped
		bits(3, 4, 5, 12, 13, 23), bits(12, 13, 14, 23, 24, 35),
		bits(1, 2, 3, 10, 11, 21), bits(10, 11, 12, 21, 22, 33), bits(21, 22, 23, 33, 34, 44), bits(33, 34, 35, 44, 45, 53),
		bits(8, 9, 10, 19, 20, 31), bits(19, 20, 21, 31, 32, 42), bits(31, 32, 33, 42, 43, 51),
		bits(17, 18, 19, 29, 30, 40), bits(29, 30, 31, 40, 41, 49),
		bits(27, 28, 29, 38, 39, 47),
		// rotated 120 - flipped
		bits(15, 24, 25, 26, 34, 35), bits(24, 34, 35, 36, 43, 44),
		bits(6, 13, 14, 15, 22, 23), bits(13, 22, 23, 24, 32, 33), bits(22, 32, 33, 34, 41, 42), bits(32, 41, 42, 43, 48, 49),
		bits(4, 11, 12, 13, 20, 21), bits(11, 20, 21, 22, 30, 31), bits(20, 30, 31, 32, 39, 40),
		bits(2, 9, 10, 11, 18, 19), bits(9, 18, 19, 20, 28, 29),
		bits(0, 7, 8, 9, 16, 17),
		// rotated 180 - flipped
		bits(42, 43, 44, 45, 46, 53), bits(40, 41, 42, 43, 44, 51),
		bits(33, 34, 35, 36, 37, 46), bits(31, 32, 33, 34, 35, 44), bits(29, 30, 31, 32, 33, 42), bits(27, 28, 29, 30, 31, 40),
		bits(21, 22, 23, 24, 25, 35), bits(19, 20, 21, 22, 23, 33), bits(17, 18, 19, 20, 21, 31),
		bits(10, 11, 12, 13, 14, 23), bits(8, 9, 10, 11, 12, 21),
		bits(1, 2, 3, 4, 5, 12),
		// rotated 240 - flipped
		bits(30, 40, 41, 48, 49, 50), bits(18, 29, 30, 39, 40, 41),
		bits(32, 42, 43, 50, 51, 52), bits(20, 31, 32, 41, 42, 43), bits(9, 19, 20, 30, 31, 32), bits(0, 8, 9, 18, 19, 20),
		bits(22, 33, 34, 43, 44, 45), bits(11, 21, 22, 32, 33, 34), bits(2, 10, 11, 20, 21, 22),
		bits(13, 23, 24, 34, 35, 36), bits(4, 12, 13, 22, 23, 24),
		bits(6, 14, 15, 24, 25, 26),
		// rotated 300 - flipped
		bits(18, 19, 27, 28, 29, 38), bits(9, 10, 17, 18, 19, 29),
		bits(30, 31, 38, 39, 40, 47), bits(20, 21, 29, 30, 31, 40), bits(11, 12, 19, 20, 21, 31), bits(4, 5, 10, 11, 12, 21),
		bits(32, 33, 40, 41, 42, 49), bits(22, 23, 31, 32, 33, 42), bits(13, 14, 21, 22, 23, 33),
		bits(34, 35, 42, 43, 44, 51), bits(24, 25, 33, 34, 35, 44),
		bits(36, 37, 44, 45, 46, 53),
	},
	{
		14*6*2, // kHook count

		// V-like piece-flip
		bits(0, 1, 8, 9, 10, 11), bits(2, 3, 10, 11, 12, 13),
		bits(7, 8, 17, 18, 19, 20), bits(9, 10, 19, 20, 21, 22), bits(11, 12, 21, 22, 23, 24),
		bits(16, 17, 27, 28, 29, 30), bits(18, 19, 29, 30, 31, 32), bits(20, 21, 31, 32, 33, 34), bits(22, 23, 33, 34, 35, 36),
		bits(28, 29, 38, 39, 40, 41), bits(30, 31, 40, 41, 42, 43), bits(32, 33, 42, 43, 44, 45),
		bits(39, 40, 47, 48, 49, 50), bits(41, 42, 49, 50, 51, 52),
		// 60-degrees-flip
		bits(4, 5, 6, 12, 13, 23), bits(13, 14, 15, 23, 24, 35),
		bits(2, 3, 4, 10, 11, 21), bits(11, 12, 13, 21, 22, 33), bits(22, 23, 24, 33, 34, 44),
		bits(0, 1, 2, 8, 9, 19), bits(9, 10, 11, 19, 20, 31), bits(20, 21, 22, 31, 32, 42), bits(32, 33, 34, 42, 43, 51),
		bits(7, 8, 9, 17, 18, 29), bits(18, 19, 20, 29, 30, 40), bits(30, 31, 32, 40, 41, 49),
		bits(16, 17, 18, 27, 28, 38), bits(28, 29, 30, 38, 39, 47),
		// 120-degree-flip
		bits(24, 25, 26, 34, 35, 37), bits(13, 14, 15, 22, 23, 25), bits(4, 5, 6, 11, 12, 14),
		bits(34, 35, 36, 43, 44, 46), bits(22, 23, 24, 32, 33, 35), bits(11, 12, 13, 20, 21, 23), bits(2, 3, 4, 9, 10, 12),
		bits(32, 33, 34, 41, 42, 44), bits(20, 21, 22, 30, 31, 33), bits(9, 10, 11, 18, 19, 21), bits(0, 1, 2, 7, 8, 10),
		bits(30, 31, 32, 39, 40, 42), bits(18, 19, 20, 28, 29, 31), bits(7, 8, 9, 16, 17, 19),
		// 180-degree-flip
		bits(42, 43, 44, 45, 52, 53), bits(40, 41, 42, 43, 50, 51),
		bits(33, 34, 35, 36, 45, 46), bits(31, 32, 33, 34, 43, 44), bits(29, 30, 31, 32, 41, 42),
		bits(23, 24, 25, 26, 36, 37), bits(21, 22, 23, 24, 34, 35), bits(19, 20, 21, 22, 32, 33), bits(17, 18, 19, 20, 30, 31),
		bits(12, 13, 14, 15, 24, 25), bits(10, 11, 12, 13, 22, 23), bits(8, 9, 10, 11, 20, 21),
		bits(3, 4, 5, 6, 13, 14), bits(1, 2, 3, 4,11, 12),
		// 240-degree-flip
		bits(30, 40, 41, 47, 48, 49), bits(32, 42, 43, 49, 50, 51), bits(34, 44, 45, 51, 52, 53),
		bits(18, 29, 30, 38, 39, 40), bits(20, 31, 32, 40, 41, 42), bits(22, 33, 34, 42, 43, 44), bits(24, 35, 36, 44, 45, 46),
		bits(9, 19, 20, 29, 30, 31), bits(11, 21, 22, 31, 32, 33), bits(13, 23, 24, 33, 34, 35), bits(15, 25, 26, 35, 36, 37),
		bits(2, 10, 11, 19, 20, 21), bits(4, 12, 13, 21, 22, 23), bits(6, 14, 15, 23, 24, 25),
		// 300-degree-flip
		bits(16, 18, 19, 27, 28, 29), bits(7, 9, 10, 17, 18, 19),
		bits(28, 30, 31, 38, 39, 40), bits(18, 20, 21, 29, 30, 31), bits(9, 11, 12, 19, 20, 21),
		bits(39, 41, 42, 47, 48, 49), bits(30, 32, 33, 40, 41, 42), bits(20, 22, 23, 31, 32, 33), bits(11, 13, 14, 21, 22, 23),
		bits(41, 43, 44, 49, 50, 51), bits(32, 34, 35, 42, 43, 44), bits(22, 24, 25, 33, 34, 35),
		bits(43, 45, 46, 51, 52, 53), bits(34, 36, 37, 44, 45, 46),
		// hook / V-like piece
		bits(0, 1, 2, 3, 8, 9), bits(2, 3, 4, 5, 10, 11),
		bits(7, 8, 9, 10, 17, 18), bits(9, 10, 11, 12, 19, 20), bits(11, 12, 13, 14, 21, 22),
		bits(16, 17, 18, 19, 27, 28), bits(18, 19, 20, 21, 29, 30), bits(20, 21, 22, 23, 31, 32), bits(22, 23, 24, 25, 33, 34),
		bits(28, 29, 30, 31, 38, 39), bits(30, 31, 32, 33, 40, 41), bits(32, 33, 34, 35, 42, 43),
		bits(39, 40, 41, 42, 47, 48), bits(41, 42, 43, 44, 49, 50),
		// 60-degrees
		bits(4, 5, 6, 12, 14, 15), bits(13, 14, 15, 23, 25, 26),
		bits(2, 3, 4, 10, 12, 13), bits(11, 12, 13, 21, 23, 24), bits(22, 23, 24, 33, 35, 36),
		bits(0, 1, 2, 8, 10, 11), bits(9, 10, 11, 19, 21, 22), bits(20, 21, 22, 31, 33, 34), bits(32, 33, 34, 42, 44, 45),
		bits(7, 8, 9, 17, 19, 20), bits(18, 19, 20, 29, 31, 32), bits(30, 31, 32, 40, 42, 43),
		bits(16, 17, 18, 27, 29, 30), bits(28, 29, 30, 38, 40, 41),
		// 120-degree
		bits(24, 25, 26, 36, 37, 46), bits(13, 14, 15, 24, 25, 35), bits(4, 5, 6, 13, 14, 23),
		bits(34, 35, 36, 45, 46, 53), bits(22, 23, 24, 34, 35, 44), bits(11, 12, 13, 22, 23, 33), bits(2, 3, 4, 11, 12, 21),
		bits(32, 33, 34, 43, 44, 51), bits(20, 21, 22, 32, 33, 42), bits(9, 10, 11, 20, 21, 31), bits(0, 1, 2, 9, 10, 19),
		bits(30, 31, 32, 41, 42, 49), bits(18, 19, 20, 30, 31, 40), bits(7, 8, 9, 18, 19, 29),
		// 180-degree
		bits(44, 45, 50, 51, 52, 53), bits(42, 43, 48, 49, 50, 51),
		bits(35, 36, 43, 44, 45, 46), bits(33, 34, 41, 42, 43, 44), bits(31, 32, 39, 40, 41, 42),
		bits(25, 26, 34, 35, 36, 37), bits(23, 24, 32, 33, 34, 35), bits(21, 22, 30, 31, 32, 33), bits(19, 20, 28, 29, 30, 31),
		bits(14, 15, 22, 23, 24, 25), bits(12, 13, 20, 21, 22, 23), bits(10, 11, 18, 19, 20, 21),
		bits(5, 6, 11, 12, 13, 14), bits(3, 4, 9, 10, 11, 12),
		// 240-degree
		bits(38, 39, 41, 47, 48, 49), bits(40, 41, 43, 49, 50, 51), bits(42, 43, 45, 51, 52, 53),
		bits(27, 28, 30, 38, 39, 40), bits(29, 30, 32, 40, 41, 42), bits(31, 32, 34, 42, 43, 44), bits(33, 34, 36, 44, 45, 46),
		bits(17, 18, 20, 29, 30, 31), bits(19, 20, 22, 31, 32, 33), bits(21, 22, 24, 33, 34, 35), bits(23, 24, 26, 35, 36, 37),
		bits(8, 9, 11, 19, 20, 21), bits(10, 11, 13, 21, 22, 23), bits(12, 13, 15, 23, 24, 25),
		// 300-degree
		bits(7, 16, 17, 27, 28, 29), bits(0, 7, 8, 17, 18, 19),
		bits(18, 28, 29, 38, 39, 40), bits(9, 18, 19, 29, 30, 31), bits(2, 9, 10, 19, 20, 21),
		bits(30, 39, 40, 47, 48, 49), bits(20, 30, 31, 40, 41, 42), bits(11, 20, 21, 31, 32, 33), bits(4, 11, 12, 21, 22, 23),
		bits(32, 41, 42, 49, 50, 51), bits(22, 32, 33, 42, 43, 44), bits(13, 22, 23, 33, 34, 35),
		bits(34, 43, 44, 51, 52, 53), bits(24, 34, 35, 44, 45, 46),
	},
	{ // small trapezoids -- symmetric left/right
		126, // kTrapezoid count
		// upright pieces
		bits(0, 1, 2), bits(2, 3, 4), bits(4, 5, 6),
		bits(7, 8, 9), bits(9, 10, 11), bits(11, 12, 13), bits(13, 14, 15),
		bits(16, 17, 18), bits(18, 19, 20), bits(20, 21, 22), bits(22, 23, 24), bits(24, 25, 26),
		bits(28, 29, 30), bits(30, 31, 32), bits(32, 33, 34), bits(34, 35, 36),
		bits(39, 40, 41), bits(41, 42, 43), bits(43, 44, 45),
		bits(48, 49, 50), bits(50, 51, 52),
		// downward pieces
		bits(1, 2, 3), bits(3, 4, 5),
		bits(8, 9, 10), bits (10, 11, 12), bits(12, 13, 14),
		bits(17, 18, 19), bits(19, 20, 21), bits(21, 22, 23), bits(23, 24, 25),
		bits(27, 28, 29), bits(29, 30, 31), bits(31, 32, 33), bits(33, 34, 35), bits(35, 36, 37),
		bits(38, 39, 40), bits(40, 41, 42), bits(42, 43, 44), bits(44, 45, 46),
		bits(47, 48, 49), bits(49, 50, 51), bits(51, 52, 53),
		// one clockwise rotation
		bits(5, 6, 14), bits(14, 15, 25), bits(25, 26, 37),
		bits(3, 4, 12), bits(12, 13, 23), bits(23, 24, 35), bits(35, 36, 46),
		bits(1, 2, 10), bits(10, 11, 21), bits(21, 22, 33), bits(33, 34, 44), bits(44, 45, 53),
		bits(8, 9, 19), bits(19, 20, 31), bits(31, 32, 42), bits(42, 43, 51),
		bits(17, 18, 29), bits(29, 30, 40), bits(40, 41, 49),
		bits(27, 28, 38), bits(38, 39, 47),
		// one clockwise rotation downward
		bits(6, 14, 15), bits(15, 25, 26),
		bits(4, 12, 13), bits(13, 23, 24), bits(24, 35, 36),
		bits(2, 10, 11), bits(11, 21, 22), bits(22, 33, 34), bits(34, 44, 45),
		bits(0, 8, 9), bits(9, 19, 20), bits(20, 31, 32), bits(32, 42, 43), bits(43, 51, 52),
		bits(7, 17, 18), bits(18, 29, 30), bits(30, 40, 41), bits(41, 49, 50),
		bits(16, 27, 28), bits(28, 38, 39), bits(39, 47, 48),
		// two clockwise rotations
		bits(27, 16, 17), bits(17, 7, 8), bits(8, 0, 1),
		bits(38, 28, 29), bits(29, 18, 19), bits(19, 9, 10), bits(10, 2, 3),
		bits(47, 39, 40), bits(40, 30, 31), bits(31, 20, 21), bits(21, 11, 12), bits(12, 4, 5),
		bits(49, 41, 42), bits(42, 32, 33), bits(33, 22, 23), bits(23, 13, 14),
		bits(51, 43, 44), bits(44, 34, 35), bits(35, 24, 25),
		bits(53, 45, 46), bits(46, 36, 37),
		// two clockwise rotations downward
		bits(16, 17, 7), bits(7, 8, 0),
		bits(28, 29, 18), bits(18, 19, 9), bits(9, 10, 2),
		bits(39, 40, 30), bits(30, 31, 20), bits(20, 21, 11), bits(11, 12, 4),
		bits(48, 49, 41), bits(41, 42, 32), bits(32, 33, 22), bits(22, 23, 13), bits(13, 14, 6),
		bits(50, 51, 43), bits(43, 44, 34), bits(34, 35, 24), bits(24, 25, 15),
		bits(52, 53, 45), bits(45, 46, 36), bits(36, 37, 26)
	},
	{ // funny last piece
		12*3*2, // kSnake count (72)
		bits(0, 1, 2, 10, 11, 12),
		bits(7, 8, 9, 19, 20, 21), bits(9, 10, 11, 21, 22, 23), bits(11, 12, 13, 23, 24, 25),
		bits(16, 17, 18, 29, 30, 31), bits(18, 19, 20, 31, 32, 33), bits(20, 21, 22, 33, 34, 35), bits(22, 23, 24, 35, 36, 37),
		bits(28, 29, 30, 40, 41, 42), bits(30, 31, 32, 42, 43, 44), bits(32, 33, 34, 44, 45, 46),
		bits(41, 42, 43, 51, 52, 53),
		// rotated 60 degrees
		bits(5, 6, 13, 14, 23, 24),
		bits(3, 4, 11, 12, 21, 22), bits(12, 13, 22, 23, 33, 34), bits(23, 24, 34, 35, 44, 45),
		bits(1, 2, 9, 10, 19, 20), bits(10, 11, 20, 21, 31, 32), bits(21, 22, 32, 33, 42, 43), bits(33, 34, 43, 44, 51, 52),
		bits(8, 9, 18, 19, 29, 30), bits(19, 20, 30, 31, 40, 41), bits(31, 32, 41, 42, 49, 50),
		bits(29, 30, 39, 40, 47, 48),
		// rotated 120 degress
		bits(26, 34, 35, 36, 37, 44),
		bits(15, 22, 23, 24, 25, 33), bits(24, 32, 33, 34, 35, 42), bits(34, 41, 42, 43, 44, 49),
		bits(6, 11, 12, 13, 14, 21), bits(13, 20, 21, 22, 23, 31), bits(22, 30, 31, 32, 33, 40), bits(32, 39, 40, 41, 42, 47),
		bits(4, 9, 10, 11, 12, 19), bits(11, 18, 19, 20, 21, 29), bits(20, 28, 29, 30, 31, 38),
		bits(9, 16, 17, 18, 19, 27),
		// flipped
		bits(4, 5, 6, 10, 11, 12), bits(9, 10, 11, 17, 18, 19), bits(11, 12, 13, 19, 20, 21), bits(13, 14, 15, 21, 22, 23),
		bits(18, 19, 20, 27, 28, 29), bits(20, 21, 22, 29, 30, 31), bits(22, 23, 24, 31, 32, 33), bits(24, 25, 26, 33, 34, 35),
		bits(30, 31, 32, 38, 39, 40), bits(32, 33, 34, 40, 41, 42), bits(34, 35, 36, 42, 43, 44),
		bits(41, 42, 43, 47, 48, 49),
		// rotated 60 degrees - flipped
		bits(13, 23, 24, 25, 26, 37),
		bits(2, 10, 11, 12, 13, 23), bits(11, 21, 22, 23, 24, 35), bits(22, 33, 34, 35, 36, 46),
		bits(0, 8, 9, 10, 11, 21), bits(9, 19, 20, 21, 22, 33), bits(20, 31, 32, 33, 34, 44), bits(32, 42, 43, 44, 45, 53),
		bits(7, 17, 18, 19, 20, 31), bits(18, 29, 30, 31, 32, 42), bits(30, 40, 41, 42, 43, 51),
		bits(16, 27, 28, 29, 30, 40),
		// rotated 120 degress - flipped
		bits(34, 35, 44, 45, 52, 53),
		bits(13, 14, 23, 24, 34, 35), bits(22, 23, 33, 34, 43, 44), bits(32, 33, 42, 43, 50, 51),
		bits(4, 5, 12, 13, 22, 23), bits(11, 12, 21, 22, 32, 33), bits(20, 21, 31, 32, 41, 42), bits(30, 31, 40, 41, 48, 49),
		bits(2, 3, 10, 11, 20, 21), bits(9, 10, 19, 20, 30, 31), bits(18, 19, 29, 30, 39, 40),
		bits(0, 1, 8, 9, 18, 19)
	}
};

HexagonEnvironment::HexagonEnvironment()
{
//	pieces = {0, 2, 3, 4, 5, 6, 7, 8, 8, 8, 8};
//	pieces = {kHexagon, kElbow, kLine, kMountains, kWrench, kTriangle, kHook, kTrapezoid, kTrapezoid, kSnake};
//	pieces = {kHexagon, kElbow, kLine, kMountains, kWrench, kTriangle, kHook, kTrapezoid, kTrapezoid, kButterfly};
	pieces = {kHexagon, kElbow, kSnake, kMountains, kWrench, kTriangle, kHook, kTrapezoid, kTrapezoid, kButterfly};
	flippable = {kCanFlip, kCanFlip, kSide1, kSide1, kSide1, kCanFlip, kCanFlip, kCanFlip, kCanFlip, kCanFlip};
//	pieces = {0, 1, 2, 3, 4, 5, 6, 7, 8, 8};
//	pieces = {0, 1, 2, 3, 4, 5, 6, 7, 9};
//	pieces = {9, 0, 1, 2, 3, 4, 5, 6, 7};
    BuildLocationTable();
    std::cout << "-< Built location table >-\n\n";
    BuildHolesTable();
    std::cout << "-< Built holes table >-\n\n";
	BuildFlipTable();
    std::cout << "-< Built flip table >-\n\n";
	BuildRotationTable();
    std::cout << "-< Built Rotation table >-\n\n";
}

void HexagonEnvironment::SetPieces(const std::vector<tPieceName> &pieces)
{
	this->pieces.resize(0);
	for (int x = 0; x < pieces.size(); x++)
		this->pieces.push_back((int)pieces[x]);
}

std::vector<int> HexagonEnvironment::GetPieces(){
    return this->pieces;
}

void HexagonEnvironment::SetFlippable(const std::array<tFlipType, numPieces> &flips)
{
	flippable = flips;
}


HexagonEnvironment::~HexagonEnvironment()
{
	
}

void HexagonEnvironment::BuildRotationTable()
{
	uint64_t one = 1;
	//	int rotate30Map[12][14*6*2+1];
	// for all pieces
	for (int x = 0; x < numPieces; x++)
	{
		int total = locations[x][0];
		if (total == 4) total = 19;
		
		// and all locations/rotations
		for (int y = 1; y <= total; y++)
		{
			// rotate the piece from the given location
			uint64_t loc = locations[x][y];
			uint64_t rot_loc = 0;
			for (int x = 0; x < 64; x++) // simple and dumb
			{
				if ((loc>>x)&1)
				{
					rot_loc |= (one<<rotateCWTable[x]);
				}
			}
			// find match to rotation
			bool success = false;
			for (int z = 1; z <= total; z++)
			{
				if (locations[x][z] == rot_loc)
				{
//                    if(rotate30Map[x][y] == 180 && z == 20)
//                        std::cout << "zoom " << x << " " << y << " " << z  << "\n";

					rotate30Map[x][y] = z;
					success = true;
                    
//                    if(x == 4 && y == 173)
//                    {
//                        std::cout << y << " | " << z;
//                    }
                    
//                    std::cout << "map " << rotate30Map[4][173]  << "\n";

					break;
				}
			}
			assert(success == true);
		}
	}
}

void HexagonEnvironment::BuildFlipTable()
{
	uint64_t one = 1;
	//	int flipMap[12][14*6*2+1];
	// for all pieces
	for (int x = 0; x < numPieces; x++)
	{
		int total = locations[x][0];
		if (total == 4) total = 19;

		// and all locations/rotations
		for (int y = 1; y <= total; y++)// TODOX total is obsolete
		{
			// flip the piece from the given location
			uint64_t loc = locations[x][y];
			uint64_t flip_loc = 0;
            int count = 0;
			for (int x = 0; x < 64; x++) // simple and dumb
			{
				if ((loc>>x)&1)
				{
					flip_loc |= (one<<flipTable[x]);
                    count ++;
				}
			}
//            std::cout << "\n\n";
			// find match to flip
			bool success = false;
			for (int z = 1; z <= total; z++)
			{
				if (locations[x][z] == flip_loc)
				{
					flipMap[x][y] = z;
					success = true;
					break;
				}
                
//                std::vector<int> b;
//
//                std::cout << x << z << "\n\n";
//
//                for (int t = 0; t < 54; t++)
//                {
//                    if ((locations[x][z]>>t)&1)
//                    {
//                        b.push_back(t);
//                    }
//                }
//
//                int size = b.size();//sizeof(b)/sizeof(*b);
//
//                if(true)
//                {
//                    std::cout << "-- (";
//                    for(int p = 0; p < size; p++)
//                    {printf("%d", b[p]);if(p<(size-1))std::cout << ", ";}
//                    std::cout << ")\n";
//                }
			}
            
//            std::vector<int> b;
//
//            for (int t = 0; t < 54; t++)
//            {
//                if ((flip_loc>>t)&1)
//                {
//                    b.push_back(t);
//                }
//            }
//
//            int size = b.size();//sizeof(b)/sizeof(*b);
//
//            if(true)
//            {
//                std::cout << "---- [" << y << "/" << total << "] (";
//                for(int p = 0; p < size; p++)
//                {printf("%d", b[p]);if(p<(size-1))std::cout << ", ";}
//                std::cout << ")\n";
//            }
            
			assert(success == true);
		}
	}
}

//-- (0, 1, 2, 8, 9, 10)
//-- (2, 3, 4, 10, 11, 12)
//-- (4, 5, 6, 12, 13, 14)
//-- (7, 8, 9, 17, 18, 19)
//-- (9, 10, 11, 19, 20, 21)
//-- (11, 12, 13, 21, 22, 23)
//-- (13, 14, 15, 23, 24, 25)
//-- (16, 17, 18, 27, 28, 29)
//-- (18, 19, 20, 29, 30, 31)
//-- (2, 3, 4)
//-- (1, 2, 3, 9, 10, 11)
//-- (3, 4, 5, 11, 12, 13)
//-- (8, 9, 10, 18, 19, 20)
//-- (10, 11, 12, 20, 21, 22)
//-- (12, 13, 14, 22, 23, 24)
//-- (17, 18, 19, 28, 29, 30)
//-- (19, 20, 21, 30, 31, 32)
//-- (21, 22, 23, 32, 33, 34)
//-- (23, 24, 25, 34, 35, 36)
//
//(0, 1, 2, 8, 9, 10)
//(2, 3, 4, 10, 11, 12)
//(4, 5, 6, 12, 13, 14)
//(7, 8, 9, 17, 18, 19)
//(9, 10, 11, 19, 20, 21)
//(11, 12, 13, 21, 22, 23)
//(13, 14, 15, 23, 24, 25)
//(16, 17, 18, 27, 28, 29)
//(18, 19, 20, 29, 30, 31)
//
//(20, 21, 22, 31, 32, 33)
//(22, 23, 24, 33, 34, 35)
//(24, 25, 26, 35, 36, 37)
//(28, 29, 30, 38, 39, 40)
//(30, 31, 32, 40, 41, 42)
//(32, 33, 34, 42, 43, 44)
//(34, 35, 36, 44, 45, 46)
//(39, 40, 41, 47, 48, 49)
//(41, 42, 43, 49, 50, 51)
//(43, 44, 45, 51, 52, 53)

//(0, 1, 2, 8, 9, 10)
//(0, 1, 2, 4, 7, 8, 9, 10, 11, 14, 15, 18, 19, 21, 23, 24, 25, 27, 29, 30, 32)
//(16, 18, 19, 21, 27, 29, 30, 31, 32, 33, 35, 36, 38, 39, 40, 41, 42, 45, 46, 47, 48, 49, 51)

void HexagonEnvironment::RotateCW(HexagonSearchState &s) const
{
	HexagonSearchState tmp;
//    std::cout << "count " << s.cnt << "\n";
//    std::cout << rotate30Map[4][173];

	for (int x = 0; x < s.cnt; x++)
	{
//        if(x!=9) continue;
//        std::cout << "x" << x << "\n";
//        if(x == 9) s.state[x].piece = 10;
		ApplyAction(tmp, RotateCW(s.state[x]));
	}
	s = tmp;
}

HexagonAction HexagonEnvironment::RotateCW(HexagonAction a) const
{
//    std::cout << "rot " << a.piece << " " << a.location << "\n";
	a.location = rotate30Map[a.piece][a.location];
//    std::cout << "rop " << a.piece << " " << a.location << "\n";

	return a;
}

void HexagonEnvironment::Flip(HexagonSearchState &s) const
{
	HexagonSearchState tmp;
	for (int x = 0; x < s.cnt; x++)
	{
		ApplyAction(tmp, Flip(s.state[x]));
	}
	s = tmp;
}

HexagonAction HexagonEnvironment::Flip(HexagonAction a) const
{
	a.location = flipMap[a.piece][a.location];
	return a;
}

bool all = false;
uint64_t goldenPattern = 1143;

void HexagonEnvironment::GetSuccessors(const HexagonSearchState &nodeID, std::vector<HexagonSearchState> &neighbors) const
{
	static std::vector<HexagonAction> actions;
	GetActions(nodeID, actions);
	neighbors.resize(0);
	for (auto i : actions)
	{
		HexagonSearchState next;
		GetNextState(nodeID, i, next);
		neighbors.push_back(next);
	}
}

void HexagonEnvironment::GetActions(const HexagonSearchState &nodeID, std::vector<HexagonAction> &actions) const
{
	actions.clear();
//	for (int x = 0; x < 126; x++)
//		actions.push_back({0, x});
//	for (int x = 0; x < 19; x++)
//		actions.push_back({1, x});
//	const int piece = 8;
    
    for (int p = (all ? 0 : nodeID.cnt); p <= (all ? (pieces.size() - 1) : nodeID.cnt); p++)
    {
        unsigned int piece = pieces[p];
        
        if(all)
        {
            int alreadyPlayed = false;
            for (int i = 0; i < nodeID.cnt; i++)
            {
                if(nodeID.state[i].piece == piece)
                {
                    alreadyPlayed += 1;
                    if(alreadyPlayed == 2 || piece != kTrapezoid) break;
                }
            }
            if(alreadyPlayed == 2 || (alreadyPlayed == 1 && piece != kTrapezoid)) continue;
        }
        
        //	for (unsigned int x = 1; x <= locations[piece][0]; x++)
        // dots & loc = 0 | dots & localized_holes = 1 (localized_holes is a table)
        //    std::cout<<flippable[nodeID.cnt];
        
        
        switch (flippable[nodeID.cnt])
        {
            case kCanFlip:
            case kHoles:
                if(all)
                {
//                    for (unsigned int x = 1; x <= locations[piece][0]; x++)
//                    {
//                        if((nodeID.bits&locations[piece][x]) != 0) continue;
//                        for (unsigned int y = 1; y <= localized_holes[piece][x][0]; y++)
//                        {
//                            if (((nodeID.dots&~localized_holes[piece][x][y])&locations[piece][x]) == 0)
//                            {
//                                actions.push_back({piece, x});
//                                break;
//                            }
//                        }
//                    }
                    
                    
                    for (unsigned int x = 1; x <= locations[piece][0]; x++)
                    {
                        if ((nodeID.bits&locations[piece][x]) == 0 && GoalValidHoles(nodeID, goldenPattern))
                            actions.push_back({piece, x});
                    }
                }
                else
                {
                    for (unsigned int x = 1; x <= locations[piece][0]; x++)
                    {
                        if ((nodeID.bits&locations[piece][x]) == 0)
                            actions.push_back({piece, x});
                    }
                }
                break;
            case kSide1:
                for (unsigned int x = 1; x <= noFlipMoveCount[piece]; x++)
                {
                    if ((nodeID.bits&locations[piece][x]) == 0)
                        actions.push_back({piece, x});
                }
                break;
            case kSide2:
                for (unsigned int x = noFlipMoveCount[piece]+1; x <= locations[piece][0]; x++)
                {
                    if ((nodeID.bits&locations[piece][x]) == 0)
                        actions.push_back({piece, x});
                }
                break;
                //        case kHoles:
                //            for (unsigned int x = 1; x <= locations[piece][0]; x++)
                //            {
                //                if((nodeID.bits&locations[piece][x]) != 0) continue;
                ////                if(x >= localized_holes[piece][0])
                ////                {actions.push_back({piece, x});continue;;/*std::cout << (nodeID.bits&locations[piece][x]) << " " << (nodeID.dots^localized_holes[piece][x]) << "\n";*/}
                //
                ////                std::cout << (nodeID.dots) << "\n";
                ////                if (((nodeID.bits&locations[piece][x]) == 0) && ((nodeID.dots&locations[piece][x]) == 0 || nodeID.dots&localized_holes[piece][x] == 1))
                ////                if (piece < 2)
                ////                {
                ////
                ////                }
                //
                ////                std::cout << "TRACK " << piece << " " << localized_holes[piece][x][0] << "\n";
                //                for (unsigned int y = 1; y <= localized_holes[piece][x][0]; y++)
                //                {
                //                    if (((nodeID.dots&~localized_holes[piece][x][y])&locations[piece][x]) == 0)//((nodeID.dots&locations[piece][x]) == 0) || (nodeID.dots^localized_holes[piece][x]) == 0)
                //                        //                if ((nodeID.bits&locations[piece][x]) == 0)
                //                    {actions.push_back({piece, x});break;/*std::cout << (nodeID.bits&locations[piece][x]) << " " << (nodeID.dots^localized_holes[piece][x]) << "\n";*/}
                //                }
                ////                if((nodeID.bits&locations[piece][x]) == 0 && (((nodeID.dots&~localized_holes[piece][x])&locations[piece][x]) == 0 || x >= localized_holes[piece][0]))
                ////                    std::cout << piece << "\n" << x << " | " << localized_holes[piece][0] << "\n" << std::bitset<54>(locations[piece][x]) << "\n" << std::bitset<54>(localized_holes[piece][x]) << "\n" << std::bitset<54>((nodeID.dots&~localized_holes[piece][x])&locations[piece][x]) << "\n\n";
                //            }
                //            break;
        }
    }
//	for (unsigned int x = 1; x <= (flippable[nodeID.cnt]?locations[piece][0]:noFlipMoveCount[piece]); x++)
//	{
//		if ((nodeID.bits&locations[piece][x]) == 0)
//			actions.push_back({piece, x});
//	}
    
    /*
     holes, actual patterns
     
     */
}

// no need to test all patterns btw. Also, keep in mind that the trapezoids are not taken care of in this case
// shared queue in utils
// //
long bestGlobal = INT_MAX, validAGlobal = 0, validBGlobal = 0, validOGlobal = 0, validX1Global = 0, validX2Global = 0, validX3Global = 0, mostPatternGoalsGlobal = 0;

// parrallelogram can be one
//const int numPatternsForPiece[numPieces] = {1, 1, 3, 3, 15, 15, 15, 15, 3, 3};

//TODO: one piece is irrelevalnt cuz its not included in any of the solutions
const int numPatternsForPiece[numPieces] = {1, 1, 3, 3, 4, 4, 4, 4, 3, 3};

// 00 03 30

// 432

// 0 0 0 0 0 3 0 0 0

// 1107

// 0 0 0 0 3 2 3 1 0 0

// 1143

// 0 0 0 0 3 3 3 1 0 0


//for (int j = 0; j < piece; j++) {
//    div *= numPatternsForPiece[j];
//}
//
//int x = (pattern / div) % numPatternsForPiece[piece];

//int noFlipMoveCount[numPieces] =
//{
////    kHexagon = 0, 2/c
////    kButterfly = 1, 1/b
////    kElbow = 2, 7/h
////    kLine = 3, 6/g
////    kMountains = 4, 3/d
////    kWrench = 5, 5/f
////    kTriangle = 6, 4/e
////    kHook = 7, 0/a
////    kTrapezoid = 8, 8/i 9/j
////    kSnake = 9
//};

//int main(int argc, char **argv) {
//  TApplication app("Root app", &argc, argv);
//  guiDemo();
//  app.Run();
//  return 0;
//}

/*
 COLOR OPTIMIZATION
 
 up to 10 colors
 
 all ways of assigning colors to pieces:
 2: 2^10 => 1024
 3: 3^10 => 59k
 4: 4^10 => 1M
 5: 5^10 => 9.7M
 6: 6^10 => 60M
 7: 7^10 => 282M
 8: 8^10 => 1B
 9: 9^10 => 3B
 10: 10^10 => 10B
  
 all ways of defining constraints:
 2: must touch edge, no touch edge, must touch corner, no touch corner => 4
 3: 12
 4: 24
 5: 40
 6: 60
 7: 84
 8: 112
 9: 144
 10: 180
 
 0 - 49
 
 10 - 5 : 5^10
 
 List of pieces and what pieces the share an edge with
 piece 0 { 1, 3 ,4}, piece 1 {0, 5, 7},..
 
 List of pieces and what pieces the share a corner with
 piece 0 { 1, 3 ,4}, piece 1 {0, 5, 7},..
 
 
 */

// 000100000
// 010000000

//for i  0  -> clrs
//      for p : c[i]
//          for j i+1 -> clrs
//              for q : c[j]
//                  if((edgeAdjacent(p,q) && must_not_be_edge_adjacent[i,j])
//                      || (!edgeAdjacent(p,q) && must_be_edge_adjacent[i,j])
//                      || (cornerAdjacent(p,q) && must_not_be_corner_adjacent[i,j])
//                      || (!cornerAdjacent(p,q) && must_be_corner_adjacent[i,j]))
//                  goalValid = false;
//                  break;


int bestPatternGlobal;
//TODO: corner touching is currently weird
std::vector<int> GetNeighboringTrianlges(int loc)
{
    std::vector<int> res;
    if(!(loc == 6 || loc == 15 || loc == 26 || loc == 37 || loc == 46 || loc == 53))
    {
        res.push_back(loc+1);
    }
    if(!(loc == 0 || loc == 7 || loc == 16 ||
           loc == 27 || loc == 38 || loc == 47))
    {
        res.push_back(loc-1);
    }
    if(loc < 47 && ((loc % 2 == 0 && loc <= 6) || (loc % 2 == 1 && (loc > 6 && loc <= 15)) || (loc % 2 == 0 && (loc > 15 && loc <= 37)) || (loc % 2 == 1 && (loc > 37 && loc <= 46)) || (loc % 2 == 0 && (loc > 46 && loc <= 53))))
    {
//        if(loc == 10) std::cout << "\nCATCH!!!!\n\n";
        res.push_back(loc+(loc < 7 ? 8 : (loc < 16 ? 10 : (loc < 27 ? 11 : (loc < 38 ? 10 : 8)))));
    }
    else if(loc > 6 && ((loc % 2 == 1 && loc <= 6) || (loc % 2 == 0 && (loc > 6 && loc <= 15)) || (loc % 2 == 1 && (loc > 15 && loc <= 37)) || (loc % 2 == 0 && (loc > 37 && loc <= 46)) || (loc % 2 == 1 && (loc > 46 && loc <= 53))))
    {
        res.push_back(loc-(loc < 16 ? 8 : (loc < 27 ? 10 : (loc < 38 ? 11 : (loc < 47 ? 10 : 8)))));
    }
    
    return res;
}

uint64_t GetNeighboringTrianlgesBits(int loc)
{
    uint64_t res = 0;
    if(!(loc == 6 || loc == 15 || loc == 26 || loc == 37 || loc == 46 || loc == 53))
    {
        res |= (((uint64_t)1)<<(loc+1));
    }
    if(!(loc == 0 || loc == 7 || loc == 16 ||
           loc == 27 || loc == 38 || loc == 47))
    {
        res |= (((uint64_t)1)<<(loc-1));
    }
    if(loc < 47 && ((loc % 2 == 0 && loc <= 6) || (loc % 2 == 1 && (loc > 6 && loc <= 15)) || (loc % 2 == 0 && (loc > 15 && loc <= 37)) || (loc % 2 == 1 && (loc > 37 && loc <= 46)) || (loc % 2 == 0 && (loc > 46 && loc <= 53))))
    {
        res |= (((uint64_t)1)<<(loc+(loc < 7 ? 8 : (loc < 16 ? 10 : (loc < 27 ? 11 : (loc < 38 ? 10 : 8))))));
    }
    else if(loc > 6 && ((loc % 2 == 1 && loc <= 6) || (loc % 2 == 0 && (loc > 6 && loc <= 15)) || (loc % 2 == 1 && (loc > 15 && loc <= 37)) || (loc % 2 == 0 && (loc > 37 && loc <= 46)) || (loc % 2 == 1 && (loc > 46 && loc <= 53))))
    {
        res |= (((uint64_t)1)<<(loc-(loc < 16 ? 8 : (loc < 27 ? 10 : (loc < 38 ? 11 : (loc < 47 ? 10 : 8))))));
    }
    
    return res;
}

void HexagonEnvironment::BuildAdjacencies(HexagonSearchState &goal)
{
//    std::cout << "Building adjacencies for: " << goal.index << "\n";
    int i, j, k, p, q;
    bool edgeAdjacent, cornerAdjacent;
    
    for(p = 0; p < goal.cnt; p++)
    {
        std::vector<int> bits1;
        for (i = 0; i < 54; i++)
        {
            if((locations[goal.state[p].piece][goal.state[p].location]>>i)&1)
                bits1.push_back(i);
        }
        
        for(q = p+1; q < goal.cnt; q++)
        {
            edgeAdjacent = false;
            cornerAdjacent = false;
            
            std::vector<int> bits2;
            for (i = 0; i < 54; i++)
            {
                if((locations[goal.state[q].piece][goal.state[q].location]>>i)&1)
                    bits2.push_back(i);
            }
            
            for (i = 0; i < bits1.size(); i++)
            {
                std::vector<int> neighbors = GetNeighboringTrianlges(bits1[i]);
                for (j = 0; j < bits2.size(); j++)
                {
                    if(find(neighbors.begin(), neighbors.end(), bits2[j]) != neighbors.end())
                    {
                        edgeAdjacent = true;
//                        goal.edgeAdjacencies[goal.state[p].piece+10*goal.state[q].piece] = true;
//                        goal.edgeAdjacencies[goal.state[q].piece+10*goal.state[p].piece] = true;
                        goal.edgeAdjacencies[p+11*q] = true;
                        goal.edgeAdjacencies[q+11*p] = true;
                        break;
                    }
                }
                
                if(edgeAdjacent)
                {
                    break;
                }
            }
            
            if(edgeAdjacent)
            {
                continue;
            }
            
//            std::cout << "NOT edge adjacent " << pieceNames[goal.state[p].piece] << "|"<< pieceNames[goal.state[q].piece] << "  " << goal.state[p].piece << "|"<< goal.state[q].piece << "\n";
            
            for (i = 0; i < bits1.size(); i++)
            {
                std::vector<int> neighbors = GetNeighboringTrianlges(bits1[i]);
                
                for (k = 0; k < neighbors.size(); k++) {
                    std::vector<int> secondNeighbors = GetNeighboringTrianlges(neighbors[k]);
                    for (j = 0; j < bits2.size(); j++)
                    {
                        if(find(secondNeighbors.begin(), secondNeighbors.end(), bits2[j]) != secondNeighbors.end())
                        {
                            cornerAdjacent = true;
//                            goal.cornerAdjacencies[goal.state[p].piece+10*goal.state[q].piece] = true;
//                            goal.cornerAdjacencies[goal.state[q].piece+10*goal.state[p].piece] = true;
                            goal.cornerAdjacencies[p+11*q] = true;
                            goal.cornerAdjacencies[q+11*p] = true;
//                            std::cout<<"corners touching at " << bits2[j] << " " << " " << bits1[i] << " " << neighbors[k] << " " << secondNeighbors[0] << " " << secondNeighbors[1] << " " << (secondNeighbors.size() == 3 ? secondNeighbors[2] : -1) << "\n";
                            break;
                        }
                    }
                    if(cornerAdjacent) break;
                }
                if(cornerAdjacent) break;
            }
            
//            if(cornerAdjacent)
//                std::cout << "Corner adjacent: " << pieceNames[goal.state[p].piece] << "|"<< pieceNames[goal.state[q].piece] << "  " << goal.state[p].piece << "|"<< goal.state[q].piece << "\n";
        }
    }
}


//                if((!(bits1[i] == 6 || bits1[i] == 15 || bits1[i] == 26 || bits1[i] == 37 || bits1[i] == 46 || bits1[i] == 53) && find(bits2.begin(), bits2.end(), bits1[i]+1) == bits2.end())
//                   ||
//                   (!(bits1[i] == 0 || bits1[i] == 7 || bits1[i] == 16 ||
//                      bits1[i] == 27 || bits1[i] == 38 || bits1[i] == 47) && find(bits2.begin(), bits2.end(), bits1[i]-1) == bits2.end())
//                   ||
//                   (bits1[i] % 2 == 0 && bits1[i] < 47 && find(bits2.begin(), bits2.end(), bits1[i]+(bits1[i] < 7 ? 8 : (bits1[i] < 16 ? 10 : (bits1[i] < 27 ? 11 : (bits1[i] < 38 ? 10 : 8))))) == bits2.end())
//                   ||
//                   (bits1[i] % 2 == 1 && bits1[i] > 6 && find(bits2.begin(), bits2.end(), bits1[i]-(bits1[i] < 16 ? 8 : (bits1[i] < 27 ? 10 : (bits1[i] < 38 ? 11 : (bits1[i] < 47 ? 10 : 8))))) == bits2.end()))
//                {
//                    goal.edgeAdjacencies[p+10*q] = true;
//                    goal.edgeAdjacencies[q+10*p] = true;
//                    break;
//                }


void HexagonEnvironment::ColorConstraintSpaceSearchParallel(std::vector<HexagonSearchState> goals, std::vector<double> &interestingPatterns, int THRESHOLD, uint64_t numPatterns, int numColors, int threadNum, int totalThreads)
{
    std::vector<double> localInterestingPatterns(interestingPatterns.size());
    uint64_t patternGoals = 0;
    bool goalValid;
    int size = goals.size();
    int i,j,k,p,q,g;
    int constraint;
    HexagonSearchState goal;
    int adjacencyPortion;
    
    std::vector<std::vector<int>> colors(numColors);
    
    for (i = 0; i < 10; i++) {
        colors[i/5].push_back(i);
    }
    
    // 2 colors
    
    // 1024 * 5
    
    std::cout << threadNum << " " << numPatterns << " " << totalThreads;
    
    for (uint64_t pattern = threadNum; pattern < numPatterns; pattern += totalThreads)
    {
        for (i = 0; i < numColors; i++) {
            colors[i].clear();
        }
        
        k = pow(numColors, pieces.size());
        q = pattern % k;
        
        for (i = 0; i < 10; i++) {
            p = q / pow(numColors, i);
            p %= numColors;
            colors[p].push_back(i);
        }
        
        adjacencyPortion = pattern / pow(numColors, pieces.size());
        
        patternGoals = 0;
        if(pattern % 1000000 == 0)
        {
            std::cout << "Pattern " << pattern << " / " << numPatterns << " ("<< ((pattern*100)/numPatterns) << "%)" << "\n";
        }
        
        for (g = 0; g < size; g++)
        {
            goal = goals[g];
            goalValid = true;
            k = -1;

            for (i = 0; i < numColors; i++)
            {
                for (j = i+1; j < numColors; j++)
                {
                    k++;
                    constraint = adjacencyPortion / pow(5, k);
                    constraint %= 5;
                    for (p = 0; p < colors[i].size(); p++)
                    {
                        for (q = 0; q < colors[j].size(); q++)
                        {
                            if((goal.edgeAdjacencies[p + 10 * q] && constraint == 1)
                              || (!goal.edgeAdjacencies[p + 10 * q] && constraint == 2)
                              || (goal.cornerAdjacencies[p + 10 * q] && constraint == 3)
                              || (!goal.cornerAdjacencies[p + 10 * q] && constraint == 4))
                            {
                                std::cout<<"INVALIDATED\n";
                                goalValid = false;
                                break;
                            }
                        }
                        if(!goalValid) break;
                    }
                    if(!goalValid) break;
                }
                if(!goalValid) break;
            }
                        
            if(goalValid) patternGoals++;
        }
        
        localInterestingPatterns[patternGoals]++;
    }
    
    patternLock.lock();
    
    for(i = 0; i < interestingPatterns.size(); i++)
        interestingPatterns[i] += localInterestingPatterns[i];
    
    patternLock.unlock();
    
    std::cout<<"THREAD (" << threadNum << ") COMPLETE\n";
}

// 0/1 0/2 0/3 0/4 1/2 1/3 1/4 2/3 2/4 3/4
int comb = 1;

void HexagonEnvironment::ColorConstraintSpaceSearchParallelExperiment(std::vector<HexagonSearchState> &goals, std::vector<double> &interestingPatterns, int THRESHOLD, uint64_t numPatterns, int numColors, int threadNum, int totalThreads, std::vector<std::vector<HexagonSearchState>> &selectedSolutions)
{
    std::vector<double> localInterestingPatterns(interestingPatterns.size());
    std::vector<int> pieces;
    uint64_t patternGoals = 0;
    bool goalValid;
    int size = goals.size(), mostPatternGoals = 99999, bestPattern;
    mostPatternGoalsGlobal = 999999;
    int i,j,k,p,q,g;
    int constraint;
    HexagonSearchState goal;
    int adjacencyPortion;
    
    std::vector<std::vector<int>> colors(numColors);
    
    int p1 = comb % 4, p2 = comb / 4;
    
    if(p1 == p2) p2 = 3;
    
//    std::cout<< "COMB COMP: " << p1 << " " << p2 << "\n";
    
    
//    const int mapPiece[numPieces] =    {2, 1, 7, 6, 3, 5, 4, a, 8, 9};
//    const int revMapPiece[numPieces+1] = {7, 1, 0, 4, 6, 5, 3, 2, 8, 9, 8};// 8, 8/i 9/j
    
    colors[0].push_back(0); // all sym
    colors[0].push_back(1);
    
    colors[1].push_back(3); // rot sym
    colors[1].push_back(9);
    
    colors[2].push_back(2); // flip sym
    colors[2].push_back(8);
    colors[2].push_back(8);
    
    colors[3].push_back(p1+4);
    colors[3].push_back(p2+4);
    
    for (i = 0; i < 4; i++) {
        if(i != p1 && i != p2)
            colors[4].push_back(i+4);
    }
    
    numPatterns = numColors * (numColors-1) / 2;
    int constraintType = 1;
    
//        for (i = 0; i < numColors; i++) {
//            colors[i].clear();
//        }
//
//        k = pow(numColors, pieces.size());
//        q = pattern % k;
//
//        for (i = 0; i < 10; i++) {
//            p = q / pow(numColors, i);
//            p %= numColors;
//            colors[p].push_back(i);
//        }
        
//        adjacencyPortion = pattern;// / k;
        
//        if(pattern % 1000000 == 0)
//        {
//            std::cout << "Pattern " << pattern << " / " << numPatterns << " ("<< ((pattern*100)/numPatterns) << "%)" << "\n";
//        }
        
        for (g = 0; g < size; g++)
        {
            goal = goals[g];
            patternGoals = 0;
            pieces.clear();
            for (p = 0; p < goal.cnt; p++)
            {
                pieces.push_back(goal.state[p].piece);
            }
            
            for(int multi = 0; multi < 2; multi++)
            for (constraintType = 1; constraintType < 5; constraintType++)
//            constraintType = 4;
            {
                numPatterns = multi == 0 ? numColors : (numColors * (numColors-1) / 2);
                for (int pattern = 0; pattern < numPatterns; pattern++)
                {
                    goalValid = constraintType == 1 || constraintType == 3;
                    k = -1;
                    
                    for (i = (multi == 0 ? pattern : 0); i < (multi == 0 ? (pattern+1) : numColors); i++)
                    {
                        for (j =  (multi == 0 ? pattern : (i+1)); j < (multi == 0 ? (pattern+1) : numColors); j++)
                        {
                            k++;
                            if(multi == 1 && k != pattern) continue;
                            
                            if(i == j)
                            {
                                int numPiecesOfClr = 0;
                                for (int tp : pieces) {
                                    if(find(colors[i].begin(), colors[i].end(), tp) != colors[i].end())
                                        numPiecesOfClr++;
                                }
                                if(numPiecesOfClr < 2) continue;
                            }
                            //                            std::cout << constraintType << " " << i << " " << j << " " << (i * numPieces + j) << " " << ((i * numPieces + j) * 10 + constraintType) << colors[i].size() << " " << colors[j].size() << "\n";
                            goal.constraints.push_back((i * numPieces + j) * 10 + constraintType);
//                            if(goal.allConstraints.size() > 1) std::cout<<"\n\nMOREE\n\n\n";
                            constraint = constraintType;//adjacencyPortion / pow(5, k);
                            //                    constraint %= 5;
                            bool lookingForFirstTrapezoid = true;
                            for (p = 0; p < colors[i].size(); p++)
                            {
                                int p1 = colors[i][p];
                                int actualP = -1;
                                bool firstTrapezoid = true;
                                for (int pp = 0; pp < goal.cnt; pp++)
                                {
                                    if(goal.state[pp].piece == p1)
                                    {
                                        if(p1 == 8 && lookingForFirstTrapezoid)
                                            lookingForFirstTrapezoid = false;
                                        else if(p1 == 8 && !lookingForFirstTrapezoid && firstTrapezoid)
                                        {
                                            firstTrapezoid = false;
                                            continue;
                                        }
                                        
                                        actualP = pp;
                                        break;
                                    }
                                }

                                bool lookingForFirstQTrapezoid = true;
                                for (q = 0; q < colors[j].size(); q++)
                                {
                                    
                                    int q1 = colors[j][q];
                                    int actualQ = -1;
                                    bool firstQTrapezoid = true;

                                    for (int qq = 0; qq < goal.cnt; qq++)
                                    {
                                        if(goal.state[qq].piece == q1)
                                        {
                                            if(q1 == 8 && lookingForFirstQTrapezoid)
                                                lookingForFirstQTrapezoid = false;
                                            if(q1 == 8 && !lookingForFirstQTrapezoid && firstQTrapezoid)
                                            {
                                                firstQTrapezoid = false;
                                                continue;
                                            }
                                            
                                            actualQ = qq;
                                            break;
                                        }
                                    }

                                    //                                    int p1 = colors[i][p];
                                    //                                    int p2 = colors[j][q];
                                    
                                    if(actualP == actualQ || actualP == -1 || actualQ == -1)
                                    {
                                        //                                        std::cout<<"INVALIDATED??" << colors[i].size() << " " <<  "\n";
                                        //                                        if(colors[i].size() == 1)
                                        //                                        {
                                        //                                            std::cout<<"INVALIDATED++\n";
                                        //                                            goalValid = false;
                                        //                                            break;
                                        //                                        }
                                        continue;
                                    }
                                    
                                    //                                    bool b1 = (find(pieces.begin(), pieces.end(), p1) == pieces.end());
                                    //                                    bool b2 = (find(pieces.begin(), pieces.end(), p1) == pieces.end());
                                    //                                    std::cout << b1 << " " << b2 << "\n";
                                    
                                    //                                    if(find(pieces.begin(), pieces.end(), p1) == pieces.end() || find(pieces.begin(), pieces.end(), q1) == pieces.end())
                                    //                                    if(actualP == -1 || actualQ == -1)
                                    //                                        continue;
                                    
                                    //                                    std::cout << "goal adj " << p1 << " " << p2 << " "<< goal.edgeAdjacencies[p1 + 10 * p2] << " " << goal.cornerAdjacencies[p1 + 10 * p2] << " | " << constraint << "\n";
                                    
                                    //                                    bool invalid1 = ( goal.edgeAdjacencies  [p1 + 10 * p2] && constraint == 1);
                                    //                                    bool anyInvalid =(   ( goal.edgeAdjacencies  [p1 + 10 * p2] && constraint == 1)
                                    //                                                    || (!goal.edgeAdjacencies  [p1 + 10 * p2] && constraint == 2)
                                    //                                                    || ( goal.cornerAdjacencies[p1 + 10 * p2] && constraint == 3)
                                    //                                                    || (!goal.cornerAdjacencies[p1 + 10 * p2] && constraint == 4));
                                    
                                    //                                    std::cout << "invalid " << invalid1 << " " << anyInvalid << "\n";

                                    if(   ( goal.edgeAdjacencies  [actualP + 11 * actualQ] && constraint == 1)
                                       || (!goal.edgeAdjacencies  [actualP + 11 * actualQ] && constraint == 2)
                                       || ((goal.edgeAdjacencies  [actualP + 11 * actualQ] || goal.cornerAdjacencies[actualP + 11 * actualQ]) && constraint == 3)
                                       || ((goal.edgeAdjacencies [actualP + 11 * actualQ]  ||!goal.cornerAdjacencies[actualP + 11 * actualQ]) && constraint == 4))
                                    {
                                        //                                        std::cout<<"INVALIDATED\n";
                                        goalValid = false;
                                        break;
                                    }
                                    if((goal.edgeAdjacencies[actualP + 11 * actualQ] && constraint == 2) || ((!goal.edgeAdjacencies[actualP + 11 * actualQ] && goal.cornerAdjacencies[actualP + 11 * actualQ]) && constraint == 4))
                                        goalValid = true;
                                }
                                if(!goalValid) break;
                            }
                            //                            if(!goalValid) break;
                        }
                        //                        if(!goalValid) break;
                    }

                    if(goalValid)
                    {
                        patternGoals++;
                        
                        //                        std::cout<<"GOAL VALID [" << goal.index <<"] " <<constraintType << " " << selectedSolutions[constraintType].size() << "\n";
                        
                        goals[g].allConstraints.push_back(goal.constraints[0]);
                        for (auto t : goal.constraints) {
                            
                            HexagonSearchState newGoal;
                            newGoal.state = goal.state;
                            newGoal.cnt = goal.cnt;
                            newGoal.bits = goal.bits;
                            newGoal.index = goal.index;
                            newGoal.dots = goal.dots;
                            newGoal.forbiddenPiece = goal.forbiddenPiece;
                            
                            newGoal.edgeAdjacencies = goal.edgeAdjacencies;
                            newGoal.cornerAdjacencies = goal.cornerAdjacencies;
                            
//                            if(multi == 1)
//                                std::cout << "idx " << goal.index << " color: " << t << "\n";
                            
                            newGoal.constraints.push_back(t);
                            newGoal.allConstraints = goals[g].allConstraints;
                            
                            selectedSolutions[multi == 0 ? constraintType : 5].push_back(newGoal);
                        }
                        
                        //
                        //                        Graphics::Display d;
                        //
                        //                        std::string fileName = "/Users/yazeedsabil/Desktop/gen_puzzles/" + std::to_string(constraintType) + "/" + std::to_string(g)+ ".svg";
                        //
                        //                    //    std::cout << fileName;
                        //                        Hexagon h;
                        //                        HexagonState hs;
                        //                        ConvertToHexagonState(goal, hs);
                        //                        h.Draw(d);
                        //                        h.Draw(d, hs);
                        //                        MakeSVG(d, fileName.c_str(), 1024, 1024);
                        //                        break;
                    }
                    
                    goal.constraints.clear();
                    
//                    std::cout<<"FACTS " << goals[g].allConstraints.size() << "\n";
                }
            }
        /*
         
         for (g = 0; g < size; g++)
         {
             goal = goals[g];
             goalValid = true;
             k = -1;

             for (i = 0; i < numColors; i++)
             {
                 for (j = i+1; j < numColors; j++)
                 {
                     k++;
                     constraint = k == pattern ? constraintType : 0;//adjacencyPortion / pow(5, k);
 //                    constraint %= 5;
                     for (p = 0; p < colors[i].size(); p++)
                     {
                         for (q = 0; q < colors[j].size(); q++)
                         {
                             if((goal.edgeAdjacencies[p + 10 * q] && constraint == 1)
                               || (!goal.edgeAdjacencies[p + 10 * q] && constraint == 2)
                               || (goal.cornerAdjacencies[p + 10 * q] && constraint == 3)
                               || (!goal.cornerAdjacencies[p + 10 * q] && constraint == 4))
                             {
 //                                std::cout<<"INVALIDATED\n";
                                 goalValid = false;
                                 break;
                             }
                         }
                         if(!goalValid) break;
                     }
                     if(!goalValid) break;
                 }
                 if(!goalValid) break;
             }
                         
             if(goalValid) patternGoals++;
         }
         */
        
        localInterestingPatterns[g] = patternGoals;
        if(patternGoals < mostPatternGoals) { mostPatternGoals = patternGoals; bestPattern = g; }
//        if(patternGoals > mostPatternGoals) mostPatternGoals = patternGoals;
    }
    
    patternLock.lock();
    
    if(mostPatternGoals < mostPatternGoalsGlobal) { mostPatternGoalsGlobal = mostPatternGoals; bestPatternGlobal = bestPattern; }
    
    for(i = 0; i < interestingPatterns.size(); i++)
        interestingPatterns[i] += localInterestingPatterns[i];
    
    for (i = 0; i < goals.size(); i++) {
        if(goals[i].allConstraints.size() > 1)
        {
//            selectedSolutions[5].push_back(goals[i]);
//            std::cout << "NOW WE HAVE " << selectedSolutions[5].size();
        }
    }
    
    patternLock.unlock();
    
//    std::cout<<"THREAD (" << threadNum << ") COMPLETE\n";
}

uint64_t HexagonEnvironment::BitsFromArray(std::vector<int> a) const
{
    uint64_t r = 0;
    for(int i : a) r|=(((uint64_t)1)<<i);
    return r;
}

std::string PrintBits(uint64_t bits, uint64_t holes = 0)
{
//    bits = 671154232;
    std::string res = "";
    
    for (int i = 0; i < 54; i++) {
        if(i == 0 || i == 47) res += "  ";
        if(i == 7 || i == 38) res += " ";
        
        if(((i % 2 == 0 && i <= 6) || (i % 2 == 1 && (i > 6 && i <= 15)) || (i % 2 == 0 && (i > 15 && i <= 37)) || (i % 2 == 1 && (i > 37 && i <= 46)) || (i % 2 == 0 && (i > 46 && i <= 53))))
        {
            res += ((bits>>i)&1) == 0 ? "â³" : (((holes>>i)&1) != 0 ? "â®" : "â²");
//            res |= (((uint64_t)1)<<(loc+(loc < 7 ? 8 : (loc < 16 ? 10 : (loc < 27 ? 11 : (loc < 38 ? 10 : 8))))));
        }
        else
        {
            res += ((bits>>i)&1) == 0 ? "â½" : (((holes>>i)&1) != 0 ? "â§¨" : "â¼");
//            res |= (((uint64_t)1)<<(loc-(loc < 16 ? 8 : (loc < 27 ? 10 : (loc < 38 ? 11 : (loc < 47 ? 10 : 8))))));
        }
        
        if(i == 6) res += "  ";
        if(i == 26 || i == 46) res += " ";
        
        if(i == 6 || i == 15 || i == 26 || i == 37 || i == 46)
            res += "\n";
    }
    
    return res;
}

//
bool HexagonEnvironment::GoalValidHoles(HexagonSearchState goal, uint64_t pattern) const
{
    if(goal.dots == 0)
        return true;
    
    int p1, p2, y, loc, piece, location, x1, x2, x;
    
    p1 = comb % 4;
    p2 = comb / 4;

    if(p1 == p2) p2 = 3;

    p1+=4;
    p2+=4;
    
    for(int p = 0; p < goal.cnt; p++)
    {
        piece = goal.state[p].piece;
        
        location = goal.state[p].location;
        
        if(numPatternsForPiece[piece] == 1)
        {
//            std::cout << "\n\n" << PrintBits(locations[piece][location]) << "\n\n";
            continue;
        }
        
        bool valid = false;
        
        uint64_t div = 1;
        
        for (int j = 0; j < piece; j++)
        {
            div *= numPatternsForPiece[j];
        }
        
        x = (pattern / div) % numPatternsForPiece[piece];

        if(piece == 3 || piece == 9)
        {
            // flip odd, even, no constraint
            // rot: one side fits and not the other, or neither
            x1 = x % 2 == 0 ? 0 : 3;
            x2 = x / 2 == 0 ? 0 : 3;
        }
        else
        {
            if(numPatternsForPiece[piece] == 3)
            {
                x1 = x2 = x;
            }
            else
            {
                if(p1 == piece || p2 == piece)
                {
                    // no - o/e
                    x1 = x < 2 ? (x+1) : 3;
                    x2 = x > 1 ? (x-1) : 3;
                }
                else
                {
                    // o/e e/o
                    x1 = (x / 2) + 1;
                    x2 = (x % 2) + 1;
                }
                
//                        x1 = x / 4;
//                        x2 = x % 4;
            }
        }
        
        if(location <= noFlipMoveCount[piece])
        {
            if(x1 == 0)
            {
//                std::cout << "\n\n" << PrintBits(locations[piece][location], locations[piece][location]) << "\n\n";
                continue;
            }
            
            if((numPatternsForPiece[piece] == 3 && !(piece == 3 || piece == 9)) && x2 == 0)
            {
//                std::cout << "\n\n" << PrintBits(locations[piece][location], locations[piece][location]) << "\n\n";
                continue;
            }
            
            if(x1 != 3)
            {
                for (y = 1; y <= (x1 == 1 ? localized_holes_side1_odd : localized_holes_side1_even)[piece][location][0]; y++)
                {
                    if (((goal.dots&~(x1 == 1 ? localized_holes_side1_odd : localized_holes_side1_even)[piece][location][y])&locations[piece][location]) == 0)
                    {
                        valid = true;
//                        std::cout << "\n\n" << PrintBits(locations[piece][location], (x1 == 1 ? localized_holes_side1_odd : localized_holes_side1_even)[piece][location][y]) << "\n\n";
                        break;
                    }
                }
                
                if(valid)
                {
                    continue;
                }
            }
        }
        else
        {
            if(x2 == 0)
            {
//                std::cout << "\n\n" << PrintBits(locations[piece][location], locations[piece][location]) << "\n\n";
                continue;
            }
            
            if(x2 != 3)
            {
                loc = location - noFlipMoveCount[piece];// + 1;
                
                for (y = 1; y <= (x2 == 1 ? localized_holes_side2_odd : localized_holes_side2_even)[piece][loc][0]; y++)
                {
                    if (((goal.dots&~(x2 == 1 ? localized_holes_side2_odd : localized_holes_side2_even)[piece][loc][y])&locations[piece][location]) == 0)
                    {
                        valid = true;
//                        std::cout << "\n\n" << PrintBits(locations[piece][location], (x2 == 1 ? localized_holes_side2_odd : localized_holes_side2_even)[piece][loc][y]) << "\n\n";
                        break;
                    }
                }
                
                if(valid)
                {
                    continue;
                }
            }
        }
        
//        std::cout << "\n\nINVLAID\n\n";

        return false;
    }
    
    uint64_t dots = BitsFromArray({1,3,5,8,10,12,14,17,19,21,23,25,27,29,31,33,35,37,38,40,42,44,46,47,49,51,53});
    
//    std::cout << "\n\n" << PrintBits((((1ull)<<54)-1), dots) << "\n\n";
//
//    std::cout << "\n\nVALID "<< goal.index <<"\n\n";
    
//    int ffhx =22;
    
    return true;
}

std::vector<HexagonSearchState> filteredGoals;

void HexagonEnvironment::FilterGoalsUsingPattern(std::vector<HexagonSearchState> goals, std::vector<double> &interestingPatterns, int THRESHOLD, uint64_t numPatterns, int threadNum, int totalThreads)
{
    long best = goals.size(), validA = 0, validB = 0, validX1 = 0, validX2 = 0, validX3 = 0, validO = 0,mostPatternGoals=0, bestPattern;
    std::vector<double> localInterestingPatterns(interestingPatterns.size());
    uint64_t patternGoals = 0;
    bool debug = false;//threadNum==0;//pattern % 1000000 == 0;
    bool goalValid, valid;
    int location, loc, piece;
    int size = goals.size();
    int i,j,p,y;
    int x, x1, x2, p1, p2;
    HexagonSearchState goal;
    
    std::vector<double> goalxs(10);
    
    p1 = comb % 4;
    p2 = comb / 4;
    
    if(p1 == p2) p2 = 3;
    
    p1+=4;
    p2+=4;
//
//    if(threadNum == 0)
//        std::cout << "COMB COMPONENTS " << p1 << " " << p2 << "\n";
//
    
    // hole patterns -> max solutions + max min color-constraint-configs solution
//    for (uint64_t pattern = threadNum; pattern < numPatterns; pattern += totalThreads)
    uint64_t pattern = goldenPattern;
    {
//        bool basic_debug = pattern % 1000000 == 0;
//        bool debug = false;//pattern % 1000000 == 0;
        patternGoals = 0;
//        if(pattern % 1000000 == 0)
//        {
//            std::cout << "Pattern " << pattern << " / " << numPatterns << " ("<< ((pattern*100)/numPatterns) << "%)" << "\n";
//        }
        
//        int i = -1;
        
        for (i = 0; i < size; i++)
        {
            goal = goals[i];
//            i++;
            goalValid = true;
            
            if(debug)
            {
                std::cout << "Goal pieces " << goal.cnt << " " << i << "/" << size << "\n";
            }
            
            goalValid = GoalValidHoles(goal, goldenPattern);
//            for(p = 0; p < goal.cnt; p++)
//            {
//                piece = goal.state[p].piece;
//
////                if(debug)
////                {
////                    std::cout << "Piece " << piece << " p " << p << " num " << numPatternsForPiece[piece] << "\n";
////                }
////
//                if(numPatternsForPiece[piece] == 1)
//                {
//                    validO++;
//                    continue;
//                }
//
//                location = goal.state[p].location;
//
//                valid = false;
//
//                uint64_t div = 1;
//
//                for (j = 0; j < piece; j++) {
//                    div *= numPatternsForPiece[j];
//                }
//
//                x = (pattern / div) % numPatternsForPiece[piece];
//
//                if(piece == 3 || piece == 9)
//                {
//                    // flip odd, even, no constraint
//                    // rot: one side fits and not the other, or neither
//                    x1 = x % 2 == 0 ? 0 : 3;
//                    x2 = x / 2 == 0 ? 0 : 3;
//                }
//                else
//                {
//                    if(numPatternsForPiece[piece] == 3)
//                    {
//                        x1 = x2 = x;
//                    }
//                    else
//                    {
//                        if(p1 == piece || p2 == piece)
//                        {
//                            // no - o/e
//                            x1 = x < 2 ? (x+1) : 3;
//                            x2 = x > 1 ? (x-1) : 3;
//                        }
//                        else
//                        {
//                            // o/e e/o
//                            x1 = (x / 2) + 1;
//                            x2 = (x % 2) + 1;
//                        }
//
////                        x1 = x / 4;
////                        x2 = x % 4;
//                    }
//                }
//
////                goalxs[piece] = x;
////                continue;//  remove
//                //TODO test with array of xs for each piece and print all of them for all puzzles
//
////                if(debug)
////                {
////                    std::cout << "piece = " << piece << " | p = " << p << " | num = " << numPatternsForPiece[piece] << " | loc = " << location << " | no flip = " << noFlipMoveCount[piece] << " | x = " << x << " | x1 = " << x1 << " | x2 = " << x2 << "\n";
////                }
//
//                if(location <= noFlipMoveCount[piece])
//                {
//                    if(x1 == 0)
//                    {
//                        validX1++;
//                        continue;
//                    }
//
//                    if((numPatternsForPiece[piece] == 3 && !(piece == 3 || piece == 9)) && x2 == 0)
//                    {
//                        validX3++;
//                        continue;
//                    }
//
//                    // 100 edge constrained
//                    //
//
//                    if(x1 != 3)
//                    {
//                        for (y = 1; y <= (x1 == 1 ? localized_holes_side1_odd : localized_holes_side1_even)[piece][location][0]; y++)
//                        {
////                            if(debug)
////                            {
//////                                std::cout<<"been here, done that";
////
////                                std::cout <<
////                                "dots " << std::bitset<54>(goal.dots) <<
////                                "\nhole " << std::bitset<54>(localized_holes_side1_even[piece][location][y]) <<
////                                "\nholo " << std::bitset<54>(localized_holes_side1_odd[piece][location][y]) <<
//////                                "\nho?? " << std::bitset<54>(localized_holes_side1_odd[piece][location+1][y]) <<
////                                "\nlocs " << std::bitset<54>(locations[piece][location]) << "\n\n";
////
////                            }
//
//                            if (((goal.dots&~(x1 == 1 ? localized_holes_side1_odd : localized_holes_side1_even)[piece][location][y])&locations[piece][location]) == 0)
//                            {
//                                valid = true;
//                                break;
//                            }
//                        }
//
//                        if(valid)
//                        {
//                            validA++;
//                            continue;
//                        }
//                    }
//                }
//                else
//                {
//                    if(x2 == 0)
//                    {
//                        validX2++;
//                        continue;
//                    }
//
//
//                    if(x2 != 3)
//                    {
//                        loc = location - noFlipMoveCount[piece];// + 1;
//
//                        for (y = 1; y <= (x2 == 1 ? localized_holes_side2_odd : localized_holes_side2_even)[piece][loc][0]; y++)
//                        {
////                            if(debug)
////                            {
//////                                std::cout<<"been here, done that";
////
////                                std::cout <<
////                                "dots " << std::bitset<54>(goal.dots) <<
////                                "\nhols " << std::bitset<54>(localized_holes_side2_odd[piece][loc][y]) <<
////                                "\nhol? " << std::bitset<54>(localized_holes_side2_odd[piece][loc-1][y]) <<
////                                "\nho?? " << std::bitset<54>(localized_holes_side2_odd[piece][loc+1][y]) <<
////                                "\nlocs " << std::bitset<54>(locations[piece][loc]) <<
////                                "\nlocs " << std::bitset<54>(locations[piece][location]) << "\n\n";
////
////                            }
//
//                            if (((goal.dots&~(x2 == 1 ? localized_holes_side2_odd : localized_holes_side2_even)[piece][loc][y])&locations[piece][location]) == 0)
//                            {
//                                valid = true;
//                                break;
//                            }
//                        }
//
//                        if(valid)
//                        {
//                            validB++;
//                            continue;
//                        }
//                    }
//                }
//
////                std::cout<<"invalid piece " << piece << "\n";
//                goalValid = false;
//                break;
//            }
                        
            if(goalValid) {
                patternGoals++;
                filteredGoals.push_back(goals[i]);
            }
        }
        localInterestingPatterns[patternGoals]++;
        if(patternGoals > mostPatternGoals)
        {
            mostPatternGoals = patternGoals;
            bestPattern = pattern;
        }
    }
    
    patternLock.lock();
    
    for(i = 0; i < interestingPatterns.size(); i++)
        interestingPatterns[i] += localInterestingPatterns[i];
    
    validAGlobal+=validA;
    validBGlobal+=validB;
    validX1Global+=validX1;
    validX2Global+=validX2;
    validX3Global+=validX3;
    validOGlobal+=validO;
    
    if(mostPatternGoals > mostPatternGoalsGlobal) { mostPatternGoalsGlobal = mostPatternGoals; bestPatternGlobal = bestPattern; }
    
    patternLock.unlock();
    
//    std::cout<<"THREAD (" << threadNum << ") COMPLETE\n";
}


void HexagonEnvironment::ConstraintSpaceSearchParallel(std::vector<HexagonSearchState> goals, std::vector<double> &interestingPatterns, int THRESHOLD, uint64_t numPatterns, int threadNum, int totalThreads)
{
    long best = goals.size(), validA = 0, validB = 0, validX1 = 0, validX2 = 0, validX3 = 0, validO = 0,mostPatternGoals=0, bestPattern;
    std::vector<double> localInterestingPatterns(interestingPatterns.size());
    uint64_t patternGoals = 0;
    bool debug = false;//threadNum==0;//pattern % 1000000 == 0;
    bool goalValid, valid;
    int location, loc, piece;
    int size = goals.size();
    int i,j,p,y;
    int x, x1, x2;//, p1, p2;
    HexagonSearchState goal;
    
    std::vector<double> goalxs(10);
//
//    p1 = comb % 4;
//    p2 = comb / 4;
//
//    if(p1 == p2) p2 = 3;
//
//    p1+=4;
//    p2+=4;
    
    // hole patterns -> max solutions + max min color-constraint-configs solution
    for (uint64_t pattern = threadNum; pattern < numPatterns; pattern += totalThreads)
    {
        patternGoals = 0;
        if(pattern % 1000000 == 0)
        {
            std::cout << "Pattern " << pattern << " / " << numPatterns << " ("<< ((pattern*100)/numPatterns) << "%)" << "\n";
        }
                
        for (i = 0; i < size; i++)
        {
            goal = goals[i];
            goalValid = true;
            
            if(debug)
            {
                std::cout << "Goal pieces " << goal.cnt << " " << i << "/" << size << "\n";
            }
            
            goalValid = GoalValidHoles(goal, pattern);
                                    
            if(goalValid)
            {
                patternGoals++;
            }
        }
        
        localInterestingPatterns[patternGoals]++;
        
        if(patternGoals > mostPatternGoals)
        {
            mostPatternGoals = patternGoals;
            bestPattern = pattern;
        }
    }
    
    patternLock.lock();
    
    for(i = 0; i < interestingPatterns.size(); i++)
        interestingPatterns[i] += localInterestingPatterns[i];
//
//    validAGlobal+=validA;
//    validBGlobal+=validB;
//    validX1Global+=validX1;
//    validX2Global+=validX2;
//    validX3Global+=validX3;
//    validOGlobal+=validO;
//
    if(mostPatternGoals > mostPatternGoalsGlobal)
    {
        mostPatternGoalsGlobal = mostPatternGoals;
        bestPatternGlobal = bestPattern;
    }
    
    patternLock.unlock();
    
    std::cout<<"THREAD (" << threadNum << ") COMPLETE\n";
}

// eliminate invalid pieces
// use vector rather than dict
// batch writes
// prune search
// hexagon is one *
// butterfly is one *
// trapezoids are three
// elbow is three
// parallelogram is three (specific) (or even one)

// opengl = stub
// make open gl = stub
// build/sfml
// hogw/bin/release

// clear: 0, odd: 1, even: 2, full: 3


//std::string pieceNames[numPieces] = {"hexagon", "butterfly","elbow","line","mountains","wrench","triangle","hook","trapezoid","snake"};
//    kHexagon = 0
//    kButterfly = 1
//    kElbow = 2
//    kLine = 3
//    kMountains = 4
//    kWrench = 5
//    kTriangle = 6
//    kHook = 7
//    kTrapezoid = 8
//    kSnake = 9

void HexagonEnvironment::FullAnalysis(std::vector<HexagonSearchState> goals, std::vector<std::vector<HexagonSearchState>> &selectedSolutions)
{
    all = true;

    int THREADS = 1;
    int THRESHOLD = std::ceil(goals.size()/2.0);
    
    int numColors = 5;

    uint64_t numPatterns = 1;
    
    for (int i = 0; i < numPieces; i++) {
        numPatterns *= numPatternsForPiece[i];
    }
    
//    numPatterns *= (numColors-1) * (numColors) / 2;
//    numPatterns *= 5;
    
//    numPatterns *= pow(numColors, pieces.size());
    
    
//    for (comb = 0; comb < 12; comb++)
//    comb = 5;
    {
        mostPatternGoalsGlobal = 0;
        std::cout << "\n------------------------------------------------------\n";
        std::cout << "Running hole space search...";
        std::cout << "\n------------------------------------------------------\n";
        std::vector<std::thread> v;
        std::vector<std::thread> v2;
        
        std::vector<double> interestingPatterns(goals.size()+1);
        
        for (int i = 0; i < THREADS; i++)
        {
            v.emplace_back(&HexagonEnvironment::FilterGoalsUsingPattern, this, goals, std::ref(interestingPatterns), THRESHOLD, numPatterns, i, THREADS);
        }
        
        for (auto& t : v)
        {
            t.join();
        }
        
        std::cout << "\n------------------------------------------------------\n";
        std::cout << "Finished hole space search";
        std::cout << "\n------------------------------------------------------\n";
        
//        filteredGoals = goals;//TODOX
        
        selectedSolutions[0] = filteredGoals;
        
        std::cout << "\n------------------------------------------------------\n";
        std::cout << "Running color space search...";
        std::cout << "\n------------------------------------------------------\n";
        
        for (int i = 0; i < THREADS; i++) {
            v2.emplace_back(&HexagonEnvironment::ColorConstraintSpaceSearchParallelExperiment, this, std::ref(filteredGoals), std::ref(interestingPatterns), THRESHOLD, numPatterns, numColors, i, THREADS, std::ref(selectedSolutions));
        }

        for (auto& t : v2) {
            t.join();
        }

        std::cout << "\n------------------------------------------------------\n";
        std::cout << "Finished color space search...";
        std::cout << "\n------------------------------------------------------\n";
        
        //    std::cout << "A: " << validAGlobal << " B: " << validBGlobal << " X1: " << validX1Global << " X2: " << validX2Global << " X3: " << validX3Global << " O: " << validOGlobal << "\n"; TODO

//        for (int i = 0; i < filteredGoals.size(); i++) {
//            std::cout << "Goal: " << i << " patterns: " << interestingPatterns[i] << "\n";
//        }
//
//        std::cout << "\n------------------------------------------------------\n";
//        std::cout << "Smallest bin goal: " << bestPatternGlobal << " | Number of color patterns: " << mostPatternGoalsGlobal;
//        std::cout << "\n------------------------------------------------------\n\n";
        
        
//        for (int i = 0; i < mostPatternGoalsGlobal+1; i++) {
//            std::cout << "Goals: " << i << " patterns: " << interestingPatterns[i] << "\n";
//        }
//
//        std::cout << "\n------------------------------------------------------\n";
//        std::cout << "Best pattern: " << bestPatternGlobal << " | Most pattern goals: " << mostPatternGoalsGlobal;
//        std::cout << "\n------------------------------------------------------\n\n";
    }
    
    
    std::cout << "\n------------------------------------------------------\n";
    std::cout << "Analyzing inital states...";
    std::cout << "\n------------------------------------------------------\n";
    
    std::vector<std::vector<int>> initStatePatterns(goals.size());
    
    
    std::vector<std::vector<int>> colors(numColors);
    
    int pp1 = comb % 4, pp2 = comb / 4;
    
    if(pp1 == pp2) pp2 = 3;
    
    
//    const int mapPiece[numPieces] =    {2, 1, 7, 6, 3, 5, 4, a, 8, 9};
//    const int revMapPiece[numPieces+1] = {7, 1, 0, 4, 6, 5, 3, 2, 8, 9, 8};// 8, 8/i 9/j
    
    colors[0].push_back(0); // all sym
    colors[0].push_back(1);
    
    colors[1].push_back(3); // rot sym
    colors[1].push_back(9);
    
    colors[2].push_back(2); // flip sym
    colors[2].push_back(8);
    colors[2].push_back(8);
    
    colors[3].push_back(pp1+4);
    colors[3].push_back(pp2+4);
    
    for (int i = 0; i < 4; i++) {
        if(i != pp1 && i != pp2)
            colors[4].push_back(i+4);
    }
    
    for(int i = 0; i < 6; i++)
    {
        std::cout << "Analyzing group: " << i << " ("<< selectedSolutions[i].size() << " items)\n";
        for (int j = 0; j < selectedSolutions[i].size(); j++)
        {
//            std::cout<<"analyzing init for: " << j << "\n";
            for (int pattern = 0; pattern < 11 ^ 10; pattern ++)
            {
//                std::cout<<pattern<<"\n";
                bool unique = true;
                uint64_t bits1 = 0;
                for (int x = 0; x < 10; x++)
                {
                    int p = pattern / pow(11, x);
                    p %= 11;
                    p--;
                    if(p!=-1)
                        bits1 |= locations[selectedSolutions[i][j].state[p].piece][selectedSolutions[i][j].state[p].location];
                }
                
                for (int k = 0; k < selectedSolutions[i].size(); k++)
                {
                    if(j == k || selectedSolutions[i][j].index == selectedSolutions[i][k].index || selectedSolutions[i][j].forbiddenPiece != selectedSolutions[i][j].forbiddenPiece) continue;
                    
                    if(i != 0)
                    {
                        HexagonSearchState goal = selectedSolutions[i][k];
                        bool goalValid = true;//TODOX
                        for (auto con : selectedSolutions[i][j].constraints)
                        {
                            int constraintType  = con % 5;
                            int constraint = constraintType;
                            int con1 = (con / 10) % numPieces;
                            int con2 = (con / 10) / numPieces;
                            
//                            std::cout << "Category: "<< i << " comparing: " << selectedSolutions[i][j].index << " VS " << selectedSolutions[i][k].index << " type: " << constraint << " clrs: " << con1<< "|"<< con2<<"\n";
                            //                            goal.constraints.push_back((i * numPieces + j) * 10 + constraintType);
                            bool lookingForFirstTrapezoid = true;
                            for (int p = 0; p < colors[con1].size(); p++)
                            {
                                int p1 = colors[con1][p];
                                int actualP = -1;
                                bool firstTrapezoid = true;
                                for (int pp = 0; pp < goal.cnt; pp++)
                                {
                                    if(goal.state[pp].piece == p1)
                                    {
                                        if(p1 == 8 && lookingForFirstTrapezoid)
                                            lookingForFirstTrapezoid = false;
                                        else if(p1 == 8 && !lookingForFirstTrapezoid && firstTrapezoid)
                                        {
                                            firstTrapezoid = false;
                                            continue;
                                        }
                                        
                                        actualP = pp;
                                        break;
                                    }
                                }
                                bool lookingForFirstQTrapezoid = true;
                                for (int q = 0; q < colors[con2].size(); q++)
                                {
                                    int q1 = colors[con2][q];
                                    int actualQ = -1;
                                    bool firstQTrapezoid = true;
                                    for (int qq = 0; qq < goal.cnt; qq++)
                                    {
                                        if(goal.state[qq].piece == q1)
                                        {
                                            if(q1 == 8 && lookingForFirstQTrapezoid)
                                                lookingForFirstQTrapezoid = false;
                                            if(q1 == 8 && !lookingForFirstQTrapezoid && firstQTrapezoid)
                                            {
                                                firstQTrapezoid = false;
                                                continue;
                                            }
                                            
                                            actualQ = qq;
                                            break;
                                        }
                                    }
                                    
                                    if(actualP == actualQ || actualP == -1 || actualQ == -1)
                                        continue;
                                    
//                                    std::cout << "validating " << actualP << " against " << actualQ << " type " << constraint <<"\n";
                                    
                                    if(   ( goal.edgeAdjacencies  [actualP + 11 * actualQ] && constraint == 1)
                                       || (!goal.edgeAdjacencies  [actualP + 11 * actualQ] && constraint == 2)
                                       || ((goal.edgeAdjacencies  [actualP + 11 * actualQ] || goal.cornerAdjacencies[actualP + 11 * actualQ]) && constraint == 3)
                                       || ((goal.edgeAdjacencies [actualP + 11 * actualQ]  ||!goal.cornerAdjacencies[actualP + 11 * actualQ]) && constraint == 4))
                                    {
                                        goalValid = false;
                                        break;
                                    }
                                    
                                    if((goal.edgeAdjacencies[actualP + 11 * actualQ] && constraint == 2) || ((!goal.edgeAdjacencies[actualP + 11 * actualQ] && goal.cornerAdjacencies[actualP + 11 * actualQ]) && constraint == 4))
                                        goalValid = true;
                                }
//                                std::cout << "Result: " << goalValid << "\n";
                                if(!goalValid) break;
                            }
                            if(!goalValid)
                                break;
                        }
                        
                        if(!goalValid) continue;
                    }
                      
                    HexagonSearchState tmp = selectedSolutions[i][k];
                    for (int y = 0; y < 6; y++)
                    {
                        uint64_t bits2 = 0;
                        for (int x = 0; x < 10; x++) {
                            int p = pattern / pow(11, x);
                            p %= 11;
                            p--;
                            if(p!=-1)
                                bits2 |= locations[tmp.state[p].piece][tmp.state[p].location];
                        }

                        if(bits1 == bits2)
                        {
                            unique = false;
                            break;
                        }
                        RotateCW(tmp);
                    }

                    if(!unique)
                        break;

                    Flip(tmp);
                    for (int y = 0; y < 6; y++)
                    {
                        uint64_t bits2 = 0;
                        for (int x = 0; x < 10; x++) {
                            int p = pattern / pow(11, x);
                            p %= 11;
                            p--;
                            if(p!=-1)
                                bits2 |= locations[tmp.state[p].piece][tmp.state[p].location];
                        }

                        if(bits1 == bits2)
                        {
                            unique = false;
                            break;
                        }
                        RotateCW(tmp);
                    }

                    if(!unique)
                        break;
                }
                
                if(unique)
                {
                    std::vector<std::string> initPieces;
                    for (int x = 0; x < 10; x++)
                    {
                        int p = pattern / pow(11, x);
                        p %= 11;
                        p--;
                        if(p!=-1)
                            initPieces.push_back(pieceNames[selectedSolutions[i][j].state[p].piece]);
                    }
                    
                    initStatePatterns[i].push_back(pattern);
//                    std::cout<<"BEST INIT STATE FOR: " << selectedSolutions[i][j].index << " (" << pattern << ") "  << " is with: ";
                    
                    selectedSolutions[i][j].initState = pattern;
//
//                    for (auto t : initPieces) {
//                        std::cout <<t<< " | ";
//                    }
//                    std::cout<<"\n";
                    break;
                }
            }
        }
    }
    
    std::cout << "\n------------------------------------------------------\n";
    std::cout << "Finished analyzing inital states";
    std::cout << "\n------------------------------------------------------\n";
//    std::vector<double> nums(goals.size()+1);
//
//
//    for (int i = 0; i < nums.size(); i++) {
//        nums[i] = i;
//    }
    
//    bool success;
//    StringReference *errorMessage = CreateStringReferenceLengthValue(0, L' ');
//    RGBABitmapImageReference *imageReference = CreateRGBABitmapImageReference();
//
//
//    success = DrawScatterPlot(imageReference, 1024, 1024, &nums, &interestingPatterns, errorMessage);
//
//    if(success){
//        std::vector<double> *pngdata = ConvertToPNG(imageReference->image);
//        WriteToFile(pngdata, "/Users/yazeedsabil/Desktop/svgs_clean/0example1.png");
//        DeleteImage(imageReference->image);
//        std::cout << "image gen success";
//    }else{
//        std::cerr << "Error: ";
//        for(wchar_t c : *errorMessage->string){
//            std::wcerr << c;
//        }
//        std::cerr << std::endl;
//
//        std::cout << errorMessage->string;
//    }
//
//    FreeAllocations();

    
//    std::ofstream ofs("/Users/yazeedsabil/Desktop/svgs_clean/hexagon.txt");

    // create class instance
//    std::map<int,string> whatever;

    // populate map.

    // save data to archive
//    {
//        boost::archive::text_oarchive oa(ofs);
//        // write map instance to archive
//        oa << interestingPatterns;
//        // archive and stream closed when destructors are called
//    }
}


void HexagonEnvironment::ConstraintSpaceSearch(std::vector<HexagonSearchState> goals)
{
    all = true;

    int THREADS = 8;
    
    int numColors = 5;

    uint64_t numPatterns = 1;
    
    for (int i = 0; i < numPieces; i++) {
        numPatterns *= numPatternsForPiece[i];
    }
    
//    numPatterns *= (numColors-1) * (numColors) / 2;
//    numPatterns *= 5;
    
//    numPatterns *= pow(numColors, pieces.size());
    
    
    for (comb = 0; comb < 12; comb++)
    {
        int combwas = comb;
        mostPatternGoalsGlobal = 0;
        std::cout << "\n------------------------------------------------------\n";
        std::cout << "Comination: " << comb;
        std::cout << "\n------------------------------------------------------\n";
        std::vector<std::thread> v;
        std::vector<std::thread> v2;
        
        std::vector<double> interestingPatterns(goals.size()+1);
        
        for (int i = 0; i < THREADS; i++)
        {
            v.emplace_back(&HexagonEnvironment::ConstraintSpaceSearchParallel, this, goals, std::ref(interestingPatterns), 0, numPatterns, i, THREADS);
        }
        
        for (auto& t : v)
        {
            t.join();
        }
        
        std::cout << "\n------------------------------------------------------\n";
        std::cout << "Finished hole space search";
        std::cout << "\n------------------------------------------------------\n";
        
//        filteredGoals = goals;//TODOX
        
//        selectedSolutions[0] = filteredGoals;
        
//        std::cout << "\n------------------------------------------------------\n";
//        std::cout << "Running color space search...";
//        std::cout << "\n------------------------------------------------------\n";
//
//        for (int i = 0; i < THREADS; i++) {
//            v2.emplace_back(&HexagonEnvironment::ColorConstraintSpaceSearchParallelExperiment, this, std::ref(filteredGoals), std::ref(interestingPatterns), THRESHOLD, numPatterns, numColors, i, THREADS, std::ref(selectedSolutions));
//        }
//
//        for (auto& t : v2) {
//            t.join();
//        }
//
//        std::cout << "\n------------------------------------------------------\n";
//        std::cout << "Finished color space search...";
//        std::cout << "\n------------------------------------------------------\n";
        
//        for (int i = 0; i < filteredGoals.size(); i++)
//        {
//            std::cout << "Goal: " << i << " patterns: " << interestingPatterns[i] << "\n";
//        }
//
//        std::cout << "\n------------------------------------------------------\n";
//        std::cout << "Smallest bin goal: " << bestPatternGlobal << " | Number of color patterns: " << mostPatternGoalsGlobal;
//        std::cout << "\n------------------------------------------------------\n\n";
        
        
        for (int i = 0; i < mostPatternGoalsGlobal+1; i++) {
            std::cout << "Goals: " << i << " patterns: " << interestingPatterns[i] << "\n";
        }

        std::cout << "\n------------------------------------------------------\n";
        std::cout << "Best pattern: " << bestPatternGlobal << " | Most pattern goals: " << mostPatternGoalsGlobal;
        std::cout << "\n------------------------------------------------------\n\n";
        
        
        std::vector<double> nums(goals.size()+1);

        for (int i = 0; i < nums.size(); i++) {
            nums[i] = i;
        }
        
        bool success;
        StringReference *errorMessage = CreateStringReferenceLengthValue(0, L' ');
        RGBABitmapImageReference *imageReference = CreateRGBABitmapImageReference();

        success = DrawScatterPlot(imageReference, 1024, 1024, &nums, &interestingPatterns, errorMessage);

        if(success){
            std::vector<double> *pngdata = ConvertToPNG(imageReference->image);
            WriteToFile(pngdata, "/Users/yazeedsabil/Desktop/Temp/svgs_clean/0example" +std::to_string(comb)+".png");
            DeleteImage(imageReference->image);
            std::cout << "image gen success";
        }else{
            std::cerr << "Error: ";
            for(wchar_t c : *errorMessage->string){
                std::wcerr << c;
            }
            std::cerr << std::endl;

            std::cout << errorMessage->string;
        }
        
        FreeAllocations();
        
        
    }
    

    
//    std::ofstream ofs("/Users/yazeedsabil/Desktop/svgs_clean/hexagon.txt");

    // create class instance
//    std::map<int,string> whatever;

    // populate map.

    // save data to archive
//    {
//        boost::archive::text_oarchive oa(ofs);
//        // write map instance to archive
//        oa << interestingPatterns;
//        // archive and stream closed when destructors are called
//    }
}



//QUE: is this on purpose?
HexagonAction HexagonEnvironment::GetAction(const HexagonSearchState &s1, const HexagonSearchState &s2) const
{
	assert(false);
	return {0, 0};
}

void HexagonEnvironment::ApplyAction(HexagonSearchState &s, HexagonAction a) const
{
	s.state[s.cnt] = a;
	s.cnt++;
	s.bits ^= locations[a.piece][a.location];
}

void HexagonEnvironment::UndoAction(HexagonSearchState &s, HexagonAction a) const
{
	s.cnt--;
	s.bits ^= locations[a.piece][a.location];
}


void HexagonEnvironment::GetNextState(const HexagonSearchState &s1, HexagonAction a, HexagonSearchState &s2) const
{
	s2 = s1;
	ApplyAction(s2, a);
}

//QUE: how does this work?
bool HexagonEnvironment::InvertAction(HexagonAction &a) const
{
	return true;
}

/** Goal Test if the goal is stored **/
bool HexagonEnvironment::GoalTest(const HexagonSearchState &node) const
{
	return node.bits == (((1ull)<<54)-1); // all 54 1s set
//	return false;
}


uint64_t HexagonEnvironment::GetStateHash(const HexagonSearchState &node) const
{
	return 0;
}

uint64_t HexagonEnvironment::GetActionHash(HexagonAction act) const
{
	return 0;
}



// entropyRecur()
// from the given state
// step 1: base case if its solved => return 0
// call get successors
// filteredSuccessors = successors with removing moves you can't perform (based on inference rules)
// if filteredSuccssors.length == 0 return inf
// requiredSuccessors = filter by: if piece can only go to one place OR if the location can only fit one piece
// for succ : filteredSuccors:
//      childEntropy = min(entropyRecur(succ), childEntropy)
// return log2(filteredSucs.length)+childEntropy;



bool HexagonEnvironment::SizeOfEmtpyRegionRule(const HexagonSearchState &s) const
{
//    return true; // 9.321
    // When placing a piece, the unfilled regions need to have a number of open triangles which are either mod 6 or mod 3, depending on the trapezoid. This limits the number of possible placements.
    
    // steps:
    // write code that detects size of connected regions of empty triangles, add those trianlges in a list such that you don't explore them again
    // now you have the list of empty regions, should be vector<vector<int>> emptyRegions
    // get count for each and make sure they're either: mod 6 (in case we don't have trapezoids left), or that they're -3 mod 6 (in case we do)
    
    
    int remainingTrapezoids = 0;
    
    if(find(pieces.begin(), pieces.end(), kTrapezoid) != pieces.end())
    {
        remainingTrapezoids = 2;
        
        for (int i = 0; i < s.cnt; i++) {
            if(s.state[i].piece == kTrapezoid)
            {
                remainingTrapezoids--;
            }
        }
    }
    
    for (auto space : s.emptySpaces) {
        int spaceSize = 0;
        for (int i = 0; i < 54; i++)
        {
            if(((space>>i)&1) == 1)
                spaceSize++;
        }
        
        if(spaceSize%6 != 0 && !(remainingTrapezoids > 0 && (spaceSize-3)%6 == 0))
            return false;
    }
    
    return true;
}

bool HexagonEnvironment::PiecesAreComposedOfTrapezoidsRule(const HexagonSearchState &s) const
{
//    return true;// 21.2
    // There are certain patterns that can never be filled, even if they meet the parity constraint, given that all the pieces are composed of trapezoids, which reduces the number of places a piece might be placed.
    
    // steps:
    // get empty regions list
    // for all 6 sized spaces: check that there's a 2-trapezoid configuration that would fit the space
    
    
    for (auto space : s.emptySpaces) {
        int spaceSize = 0;
        for (int i = 0; i < 54; i++)
        {
            if(((space>>i)&1) == 1)
                spaceSize++;
        }
        
        if(spaceSize != 6)
            continue;
        
        bool configFound = false;
        for (int trap1 = 1; trap1 <= locations[kTrapezoid][0]; trap1++) {
            for (int trap2 = 1; trap2 <= locations[kTrapezoid][0]; trap2++) {
                uint64_t config = 0;
                config |= locations[kTrapezoid][trap1];
                config |= locations[kTrapezoid][trap2];
                
                if(space == config)
                {
                    configFound = true;
                    break;
                }
            }
            if(configFound) break;
        }
        
        if(!configFound)
        {
            return false;
        }
    }
    
    return true;
}

//21.2
bool HexagonEnvironment::PieceThatFitsTheSpaceIsNotAvailableRule(const HexagonSearchState &s) const
{
//    return true;//19.5
    // there can be spaces that can fit pieces, but that piece isnât available due to being played already, or not matching other (color/bump) constraints.
    
    // if both trapezoids are available return true
    
    
    int remainingTrapezoids = 0;
    
    if(find(pieces.begin(), pieces.end(), kTrapezoid) != pieces.end())
    {
        remainingTrapezoids = 2;
        
        for (int i = 0; i < s.cnt; i++) {
            if(s.state[i].piece == kTrapezoid)
            {
                remainingTrapezoids--;
            }
        }
    }
    
    if(remainingTrapezoids == 2) return true;
    
    // get empty regions list
    
    // if any of them is size 3 and no trapezoids are available return false
    
    // for each one of size 6, make sure that there's a remaining piece that has a location that can fit there, if so return true
    
    
    for (auto space : s.emptySpaces) {
        int spaceSize = 0;
        for (int i = 0; i < 54; i++)
        {
            if(((space>>i)&1) == 1)
                spaceSize++;
        }
        
        if(spaceSize == 3 && remainingTrapezoids == 0)
            return false;
        
        if(spaceSize != 6) continue;
        
        bool locCovered = false;
        
        for(auto piece : pieces)
        {
            bool piecePlayed = false;
            for (int p = 0; p < s.cnt; p++) {
                if(s.state[p].piece == piece)
                {
                    piecePlayed = true;
                    break;
                }
            }
            
            if(piecePlayed) continue;
            
            for (int loc = 1; loc <= locations[piece][0]; loc++) {
                if(locations[piece][loc] == space)
                {
                    locCovered = true;
                    break;
                }
            }
            
            if(locCovered) break;
        }
        
        if(!locCovered)
            return false;
    }
        
    return true;
}

uint64_t HexagonEnvironment::LocationCanOnlyFitACertainPieceReqRule(const HexagonSearchState &s) const
{
//    return 0;
    // if location can only fit one piece then it has to go there
    
    // loop through empty regions
    //      if its size 3 and a trapezoid exists return true
    //      int fits = 0;
    //      if its size 6 loop through remaining pieces and then loop through all their possible locations (given constraints?)
    //          fits++
    //      return fits == 1;
    
    
    
    int remainingTrapezoids = 0;
    
    if(find(pieces.begin(), pieces.end(), kTrapezoid) != pieces.end())
    {
        remainingTrapezoids = 2;
        
        for (int i = 0; i < s.cnt; i++) {
            if(s.state[i].piece == kTrapezoid)
            {
                remainingTrapezoids--;
            }
        }
    }
    
    if(remainingTrapezoids == 2) return 0;
    
    for (auto &space : s.emptySpaces)
    {
//        int spaceSize = 0;
//        for (int i = 0; i < 54; i++)
//        {
//            if(((space>>i)&1) == 1)
//                spaceSize++;
//        }
        
//        if(spaceSize == 3 && remainingTrapezoids > 0)
//            return true;
        
//        if(spaceSize != 6 && spaceSize != 3) return false;
        
//        if(spaceSize != 6) continue;
        
        int fits = 0, thePiece;
        
        for(auto piece : pieces)
        {
            if(remainingTrapezoids > 0 && piece != kTrapezoid) continue;
            
            int piecePlayed = 0;
            for (int p = 0; p < s.cnt; p++) {
                if(s.state[p].piece == piece)
                {
                    piecePlayed++;
                    break;
                }
            }
            
            if(piecePlayed) continue;
            
            for (int loc = 1; loc <= locations[piece][0]; loc++) {
                if(locations[piece][loc] == space)
                {
                    thePiece = piece;
                    fits++;
                    break;
                }
            }
        }
        
        if(fits == 1)
        {
//            std::cout<<"\n\n\nThis is the only piece: " << pieceNames[thePiece] << " that can fit the space\n" << PrintBits(space)<<"\n\n";
            return space;
        }
    }
    
    return 0;
}

int HexagonEnvironment::PieceCanOnlyGoInOnePlaceReqRule(const HexagonSearchState &s) const
{
//    return -1;
    // if piece can only go to one place then its requied to go there
    
    // loop through remaining pieces
    //      int fits = 0;
    //      loop through empty regions
    //          if its size 6 loop through all piece possible locations (given constraints?)
    //              fits++
    //      return fits == 1;
    
    
    
    for(auto piece : pieces)
    {
        if(piece == kTrapezoid) continue;
        
        bool piecePlayed = false;
        
        for (int p = 0; p < s.cnt; p++)
        {
            if(s.state[p].piece == piece)
            {
                piecePlayed = true;
                break;
            }
        }
        
        if(piecePlayed) continue;
        
        int fits = 0;
        uint64_t theSpace;
//
//        for (auto space : s.emptySpaces)
//        {
//            int spaceSize = 0;
//            for (int i = 0; i < 54; i++)
//            {
//                if(((space>>i)&1) == 1)
//                    spaceSize++;
//            }
////
//            if(spaceSize != 6) return false;
//
////            if(spaceSize != 6) continue;
//
//            for (int loc = 1; loc <= locations[piece][0]; loc++) {
//                if(locations[piece][loc] == space)
//                {
//                    theSpace = space;
//                    fits++;
//                    break;
//                }
//            }
//        }
        
        
        for (int loc = 1; loc <= locations[piece][0]; loc++)
        {
            if((locations[piece][loc]&s.bits) == 0)
            {
                theSpace = locations[piece][loc];
                fits++;
            }
        }
        
        if(fits == 1)
        {
//            std::cout<<"\n\n\nThis piece: " << pieceNames[piece] << " can only fit in this space\n" << PrintBits(theSpace)<<"\n\n";
            return piece;
        }
    }
   
    return -1;
}

void HexagonEnvironment::GetEmptySpaces(HexagonSearchState &s) const
{
    s.emptySpaces.clear();
    uint64_t exploredTriangles = 0, emptySpace = 0, emptyTrianglesAtLevel = 0, emptyTrianglesAtNextLevel = 0, neighbors = 0;
    
    for (int i = 0; i < 54; i++)
    {
        if(((s.bits>>i)&1) == 1 || ((exploredTriangles>>i)&1) == 1)
            continue;
        
        emptySpace = 0;
        
        emptySpace ^= (((uint64_t)1)<<i);
        
        exploredTriangles |= (((uint64_t)1)<<i);
        
        emptyTrianglesAtLevel = GetNeighboringTrianlgesBits(i);

        while(emptyTrianglesAtLevel != 0)
        {
            emptyTrianglesAtNextLevel = 0;
            for (int t = 0; t < 54; t++)
            {
                if(((emptyTrianglesAtLevel>>t)&1) == 0 || t == i || ((s.bits>>t)&1) == 1 || ((exploredTriangles>>t)&1) == 1)
                    continue;

                emptySpace |= (((uint64_t)1)<<t);

                exploredTriangles |= (((uint64_t)1)<<t);

                neighbors = GetNeighboringTrianlgesBits(t);

                for (int child = 0; child < 54; child++)
                {
                    if(((neighbors>>child)&1) == 0 || child == t || ((s.bits>>child)&1) == 1 || ((exploredTriangles>>child)&1) == 1)
                        continue;

                    emptyTrianglesAtNextLevel |= (((uint64_t)1)<<child);
                }
            }
            emptyTrianglesAtLevel = emptyTrianglesAtNextLevel;
        }
        
        // SANITY CHECK
        // check that shape is convex
//
//        int spaceSize = 0;
//        for (int i = 0; i < 54; i++)
//        {
//            if(((emptySpace>>i)&1) == 1)
//                emptySpace++;
//        }
        
//        if(spaceSize > 1)
//        for (int xstep = 0; xstep < 54; xstep++) {
//            if(((emptySpace>>xstep)&1) == 0)
//                continue;
//
//            uint64_t neigh = GetNeighboringTrianlgesBits(xstep);
//            bool found = false;
//            for (int xstep2 = 0; xstep2 < 54; xstep2++) {
//                if(((emptySpace>>xstep2)&1) == 0 || xstep == xstep2)
//                    continue;
//
//                if(((neigh>>xstep2)&1) == 1)
//                {
//                    found = true;
//                    break;
//                }
//            }
//
//            if(!found)
//            {
//                std::cout<<"FREAKOUT";
//            }
//
//        }
        if(emptySpace == 671154232)
        {
            std::cout<<"CATCCHHHHH";
        }
        s.emptySpaces.push_back(emptySpace);
    }
    
}

// 1 .
// 3 ...
// 9 ... ... ...
// 27 ... ... ... ... ... ... ... ... ...
// 54

int leafNum, deadEnds;
vectorCache<HexagonSearchState> succsCache;
//vectorCache<bool> boolCache;
vectorCache<int> intCache;
long expansions;

float HexagonEnvironment::GetEntropy(HexagonSearchState &s) const
{
    if(GoalTest(s)) // Base case
    {
//        leafNum++;
//        std::cout<< s.cnt << " reached leaf #" << leafNum << "\n";
        return 0;
    }
        
    std::vector<HexagonSearchState> &succs = *succsCache.getItem();
    
    std::vector<HexagonSearchState> &filteredSuccs = *succsCache.getItem();
    
    std::vector<HexagonSearchState> &tempSucc = *succsCache.getItem();
    
    std::vector<int> &numItems = *intCache.getItem();
    numItems.resize(pieces.size());
    
    GetSuccessors(s, succs);
    
    uint64_t exists = 0;
    
    bool parentHasOneTrapezoid = false;
    
    for (int i = 0; i < s.cnt; i++)
    {
        if(s.state[i].piece == kTrapezoid)
            parentHasOneTrapezoid = !parentHasOneTrapezoid;
    }

    for (auto &succ : succs)//consider trapezoids separately
    {
        bool firstTrapezoidFound = false;
        for (int i = 0; i < succ.cnt; i++)
        {
            if(succ.state[i].piece != kTrapezoid || (succ.state[i].piece == kTrapezoid && (!parentHasOneTrapezoid || firstTrapezoidFound)))
                exists |= (((uint64_t)1)<<succ.state[i].piece);
            if(succ.state[i].piece == kTrapezoid)
                firstTrapezoidFound = true;
//            std::cout << succ.state[i].piece << " ";
        }
        
//        std::cout << "\n";
        
        GetEmptySpaces(succ);
////        std::cout<< "\n\n\n" << std::bitset<54>(succ.bits)<<"\n\n";
//        std::cout << "\n\n\n" << PrintBits(succ.bits) << "\n\n";
//        for (auto em : succ.emptySpaces)
//        {
////            std::cout<< std::bitset<54>(em)<<"\n";
//            std::cout<< PrintBits(em) << "\n\n";
//        }
    }

    for (int i = 0; i < pieces.size(); i++)
    {
        if(((exists>>pieces[i])&1) == 0)
        {
//            std::cout<<"Piece missing: " << pieces[i] <<"\n";
            return INFINITY;
        }
    }

    uint64_t req1 = LocationCanOnlyFitACertainPieceReqRule(s);
    int req2 = PieceCanOnlyGoInOnePlaceReqRule(s);

    if (!(req1 == 0 && req2 == -1))
    {
        
        for (auto &succ : succs)
        {
            if((req1 != 0 && (succ.bits & req1) == 6) || (req2 != -1 && succ.state[succ.cnt - 1].piece == req2))
            {
                return GetEntropy(succ);
            }
        }
    }
    
    for (const auto &succ : succs)
    {
        if(!SizeOfEmtpyRegionRule(succ))
            continue;

        if(!PiecesAreComposedOfTrapezoidsRule(succ))
            continue;

        if(!PieceThatFitsTheSpaceIsNotAvailableRule(succ))
            continue;

        numItems[succ.state[succ.cnt - 1].piece]++;
        
//        std::cout << succ.state[succ.cnt - 1].piece << " " << numItems[succ.state[succ.cnt - 1].piece] << "\n";
        
        tempSucc.push_back(succ);
    }
    
    int minP = 99999, bestP = -1;
    
    for (int i = 0; i < numItems.size(); i++)
    {
        if(numItems[i] < minP && numItems[i] > 0)
        {
            minP = numItems[i];
            bestP = i;
            
//            std::cout << "found best: " << bestP << " " << minP << "\n";
        }
    }
    
    for (const auto &succ : tempSucc)
    {
        if(succ.state[succ.cnt - 1].piece != bestP)
            continue;
        
        filteredSuccs.push_back(succ);
    }
    
//    std::cout << "filtered " << tempSucc.size() << " into " << filteredSuccs.size() << " " << bestP << " " << minP << "\n";
    
    succsCache.returnItem(&tempSucc);

    if(filteredSuccs.size() == 0)
    {
//        std::cout << "dead end\n";
        return INFINITY;
    }
    
    float childEntropy = INFINITY;
    
    int cur = 0;
    
    for (auto &succ : filteredSuccs)
    {
        //ctrl cmd y
        cur++;
        expansions++;
//        if(s.cnt == 2)
//            std::cout<<"expansions " << expansions << " | " << childEntropy << " ("<<cur<<"/"<<filteredSuccs.size()<<")\n";
        
        childEntropy = min(GetEntropy(succ), childEntropy);
    }
    
    childEntropy += log2(filteredSuccs.size());
    
    succsCache.returnItem(&succs);
    succsCache.returnItem(&filteredSuccs);
    
//    if(childEntropy != INFINITY)
//    std::cout<<"entropy returned: " << childEntropy << "\n";
    
    return childEntropy;
}

/** Prints out the triangles used for this piece in HOG2 coordinates */
void HexagonEnvironment::GeneratePieceCoordinates(tPieceName p)
{
	// 1. Start with environment with only one piece type
//	HexagonEnvironment e;
	std::vector<tPieceName> v;
	v.push_back(p);
	/*e.*/SetPieces(v);
	
	// 2. Get legal actions
	std::vector<HexagonSearchState> succ;
	HexagonSearchState s;
    /*e.*/GetSuccessors(s, succ);

	// 3. Place the piece on the board
	s = succ[0];
	
	assert(s.cnt == 1); // should only be 1 piece on the board
	
	uint64_t state = s.bits;
	
	std::cout << pieceNames[p] << "\t";
//	// count how many objects we have
	int count = 0;
	for (int t = 0; t < 54; t++)
	{
		if (((state>>t)&1) == 1)
		{
			count++;
		}
	}
    
    int pp1 = comb % 4, pp2 = comb / 4;
    if(pp1 == pp2) pp2 = 3;
    
    pp1+=4; pp2+=4;
    
    //int noFlipMoveCount[numPieces] =
    //{
    ////    kHexagon = 0, 2/c
    ////    kButterfly = 1, 1/b
    ////    kElbow = 2, 7/h
    ////    kLine = 3, 6/g
    ////    kMountains = 4, 3/d
    ////    kWrench = 5, 5/f
    ////    kTriangle = 6, 4/e
    ////    kHook = 7, 0/a
    ////    kTrapezoid = 8, 8/i 9/j
    ////    kSnake = 9
    //};

    
    int piece = s.state[0].piece;
    int loc = s.state[0].location;
    
    std::cout << count << "\n";//piece

    uint64_t pattern = goldenPattern;
    uint64_t div = 1;

    for (int j = 0; j < piece; j++) {
        div *= numPatternsForPiece[j];
    }

    int x = (pattern / div) % numPatternsForPiece[piece];
    int x1, x2;

    if(numPatternsForPiece[piece] == 1)
    {
        x1 = x2 = 0;
    }
    else if(piece == 3 || piece == 9)
    {
        // flip odd, even, no constraint
        // rot: one side fits and not the other, or neither
        x1 = x % 2 == 0 ? 0 : 3;
        x2 = x / 2 == 0 ? 0 : 3;
    }
    else
    {
        if(numPatternsForPiece[piece] == 3)
        {
            x1 = x2 = x;
        }
        else
        {
            if(pp1 == piece || pp2 == piece)
            {
                // no - o/e
                x1 = x < 2 ? (x+1) : 3;
                x2 = x > 1 ? (x-1) : 3;
            }
            else
            {
                // o/e e/o
                x1 = (x / 2) + 1;
                x2 = (x % 2) + 1;
            }
        }
    }
    
//    std::cout << "x: " << x << " x1: " << x1 << " x2: " << x2  << " pp1: " << pp1 << " pp2: " << pp2 << "\n";
//
//    std::cout << "G O: " << std::bitset<54>(state) << "\n";
//    std::cout << "G 0: " << std::bitset<54>(localized_holes_side1_odd[piece][1][1]) << "\n";
//    std::cout << "G 1: " << std::bitset<54>(localized_holes_side1_even[piece][1][1]) << "\n";
//    std::cout << "G 2: " << std::bitset<54>(localized_holes_side2_odd[piece][1][1]) << "\n";
//    std::cout << "G 3: " << std::bitset<54>(localized_holes_side2_even[piece][1][1]) << "\n";
    
    std::cout << "\n\n" << x ;
    std::cout << "\n\n" << PrintBits(state,localized_holes_side1_odd[piece][1][1]) << "\n\n";
    std::cout << "\n\n" << PrintBits(state,localized_holes_side1_even[piece][1][1]) << "\n\n";
//    std::cout << "\n\n" << PrintBits(localized_holes_side1_odd[piece][1][1]) << "\n\n";
//    std::cout << "\n\n" << PrintBits(localized_holes_side1_even[piece][1][1]) << "\n\n";
//    std::cout << "\n\n" << PrintBits(localized_holes_side2_odd[piece][1][1]) << "\n\n";
//    std::cout << "\n\n" << PrintBits(localized_holes_side2_even[piece][1][1]) << "\n\n";
    
	// drawing doesn't have to be so fast! (compared to enumeration operations)
    //
	for (int t = 0; t < 54; t++)
	{
		if (((state>>t)&1) == 1)
		{
			int xx, y;
			Graphics::point p1, p2, p3;
			IndexToXY(t, xx, y);
			GetCorners(xx, y, p1, p2, p3);
			
			std::cout.precision(20);
			std::cout << std::fixed;

			std::cout << " " << p1 << " " << p2 << " " << p3 << "\t";

            
            bool side1 = x1 == 0 || (x1 == 1 && ((localized_holes_side1_odd[piece][1][1]>>t)&1) == 1) || (x1 == 2 && ((localized_holes_side1_even[piece][1][1]>>t)&1) == 1);
            bool side2 = x2 == 0 || (x2 == 1 && ((localized_holes_side1_odd[piece][1][1]>t)&1) == 1) || (x2 == 2 && ((localized_holes_side1_even[piece][1][1]>>t)&1) == 1);

            int type = (side1 ? 1 : 0) + (side2 ? 2 : 0);
            
            // 0: none
            // 1: side 1 only
            // 2: side 2 only
            // 3: both
            
//            std::cout << "\n" << ((localized_holes_side1_odd[piece][1][1]>>t)&1) << " " << ((localized_holes_side1_even[piece][1][1]>>t)&1) << " "<<  type << "\n";
            
            std::cout <<  type << "\t";
            
            // 0: full
            // 1: odd-odd or even-even //flip
            // 2: full-none or none-full //rot
            // 3: none-odd or none-even //g1
            // 4: odd-even or even-odd //g2
            
		}
	}
	std::cout << "\n";
}

/** Prints out the outer coorsinates of the board */
void HexagonEnvironment::GenerateBoardBorder()
{
	// 1. Start with environment with only one piece type
//	HexagonEnvironment e;
    
    uint64_t dots = BitsFromArray({1,3,5,8,10,12,14,17,19,21,23,25,27,29,31,33,35,37,38,40,42,44,46,47,49,51,53});
    
    std::cout << "\n\n" << PrintBits((((1ull)<<54)-1), dots) << "\n\n";
	
	std::cout << "Board\t";
//	// count how many objects we have
	int count = 54;
	std::cout << count << "\n";
	// drawing doesn't have to be so fast! (compared to enumeration operations)
	for (int t = 0; t < 54; t++)
	{
		int x, y;
		Graphics::point p1, p2, p3;
		IndexToXY(t, x, y);
		GetCorners(x, y, p1, p2, p3);
		
		std::cout.precision(20);
		std::cout << std::fixed;
		
		std::cout << " " << p1 << " " << p2 << " " << p3 << "\t";
        
        std::cout << (((dots>>t)&1) == 1 ? 1 : 0) << "\t";
	}
	std::cout << "\n";
}

void HexagonEnvironment::Draw(Graphics::Display &display) const
{
	
}

/** Draws available pieces and constraints */
void HexagonEnvironment::DrawSetup(Graphics::Display &display) const
{
	hex.DrawSetup(display);
}

void HexagonEnvironment::Draw(Graphics::Display &display, const HexagonSearchState &s) const
{
	display.FillSquare({0,0}, 1.0, Colors::white);
	for (int t = 0; t < 54; t++)
	{
		int x, y;
		Graphics::point p1, p2, p3;
		IndexToXY(t, x, y);
		GetCorners(x, y, p1, p2, p3);
		display.FillTriangle(p1, p2, p3, Colors::lightgray);
	}

	HexagonSearchState tmp;
	for (int i = 0; i < s.cnt; i++)
	{
		tmp.Reset();
		ApplyAction(tmp, s.state[i]);
		uint64_t state = tmp.bits;

		// drawing doesn't have to be so fast! (compared to enumeration operations)
		for (int t = 0; t < 54; t++)
		{
			if (((state>>t)&1) == 1)
			{
				int x, y;
				Graphics::point p1, p2, p3;
				IndexToXY(t, x, y);
				GetCorners(x, y, p1, p2, p3);
				display.FillTriangle(p1, p2, p3, rgbColor::hsl((float)i/12, (i%2)?0.75f:0.25f, 0.5f));
			}
		}
	}
}

void HexagonEnvironment::IndexToXY(int index, int &x, int &y)  const
{
	switch (index)
	{
		case 0: x = 2; y = 0; return;
		case 1: x = 3; y = 0; return;
		case 2: x = 4; y = 0; return;
		case 3: x = 5; y = 0; return;
		case 4: x = 6; y = 0; return;
		case 5: x = 7; y = 0; return;
		case 6: x = 8; y = 0; return;

		case 7: x = 1; y = 1; return;
		case 8: x = 2; y = 1; return;
		case 9: x = 3; y = 1; return;
		case 10: x = 4; y = 1; return;
		case 11: x = 5; y = 1; return;
		case 12: x = 6; y = 1; return;
		case 13: x = 7; y = 1; return;
		case 14: x = 8; y = 1; return;
		case 15: x = 9; y = 1; return;

		case 16: x = 0; y = 2; return;
		case 17: x = 1; y = 2; return;
		case 18: x = 2; y = 2; return;
		case 19: x = 3; y = 2; return;
		case 20: x = 4; y = 2; return;
		case 21: x = 5; y = 2; return;
		case 22: x = 6; y = 2; return;
		case 23: x = 7; y = 2; return;
		case 24: x = 8; y = 2; return;
		case 25: x = 9; y = 2; return;
		case 26: x = 10; y = 2; return;

		case 27: x = 0; y = 3; return;
		case 28: x = 1; y = 3; return;
		case 29: x = 2; y = 3; return;
		case 30: x = 3; y = 3; return;
		case 31: x = 4; y = 3; return;
		case 32: x = 5; y = 3; return;
		case 33: x = 6; y = 3; return;
		case 34: x = 7; y = 3; return;
		case 35: x = 8; y = 3; return;
		case 36: x = 9; y = 3; return;
		case 37: x = 10; y = 3; return;

		case 38: x = 1; y = 4; return;
		case 39: x = 2; y = 4; return;
		case 40: x = 3; y = 4; return;
		case 41: x = 4; y = 4; return;
		case 42: x = 5; y = 4; return;
		case 43: x = 6; y = 4; return;
		case 44: x = 7; y = 4; return;
		case 45: x = 8; y = 4; return;
		case 46: x = 9; y = 4; return;

		case 47: x = 2; y = 5; return;
		case 48: x = 3; y = 5; return;
		case 49: x = 4; y = 5; return;
		case 50: x = 5; y = 5; return;
		case 51: x = 6; y = 5; return;
		case 52: x = 7; y = 5; return;
		case 53: x = 8; y = 5; return;
	}
	x=-1;y=-1;
}


void HexagonEnvironment::GetCorners(int x, int y, Graphics::point &p1, Graphics::point &p2, Graphics::point &p3) const
{
	return hex.GetCorners(x, y, p1, p2, p3);
}

bool HexagonEnvironment::GetBorder(int x, int y, int xoff, int yoff, Graphics::point &p1, Graphics::point &p2) const
{
	return hex.GetBorder(x, y, xoff, yoff, p1, p2);
}

bool HexagonEnvironment::Valid(int x, int y) const
{
	return hex.Valid(x, y);
}

//std::vector<rgbColor> pieceColors;

#pragma mark -
#pragma mark Hexagon Display Code
#pragma mark -


Hexagon::Hexagon()
{
	
}
Hexagon::~Hexagon()
{
	
}

void Hexagon::LoadSolution(const char *file, HexagonState &s)
{
	Load(file, s, true);
}

void Hexagon::LoadPuzzle(const char *file, HexagonState &s)
{
	Load(file, s, false);
}

void Hexagon::Load(const char *file, HexagonState &s, bool solution)
{
    s.state.FillMax();
	this->solution.state.FillMax();
	FILE *f = fopen(file, "r");
	if (f == 0)
	{
		printf("Error opening file for rea\n");
		return;
	}
	int h, w;
	fscanf(f, "type triangle\n");
	int cnt = fscanf(f, "height %d\nwidth %d\nmap\n", &h, &w);
	if (cnt != 2)
	{
		printf("Error reading height/width from file\n");
		return;
	}
	if (h != 6 || w != 11)
	{
		printf("Invalid height/width from file. Requires 6/11.\n");
		return;
	}
	// read constraints (if any)
	char buffer[255];
	fgets(buffer, 255, f);
	if (strncmp("Constraint:", buffer, 11) != 0)
	{
		printf("Error: expected 'Constraint:'\n");
		return;
	}
	char *tmp;
	
	// must touch diagonally
    tmp = strcasestr(buffer, "Diag");
    if (tmp != NULL)
    {
        diagPieces.resize(3);
        sscanf(&tmp[5], "%d %d %d", &diagPieces[0], &diagPieces[1], &diagPieces[2]);
    }
    
    tmp = strcasestr(buffer, "NotDiag");
    if (tmp != NULL)
    {
        notDiagPieces.resize(3);
        sscanf(&tmp[5], "%d %d %d", &notDiagPieces[0], &notDiagPieces[1], &notDiagPieces[2]);// check this 5
    }
	
	tmp = strcasestr(buffer, "NoFlip");

	if (tmp != NULL)
	{
		noFlipPieces.resize(3);
		sscanf(&tmp[7], "%d %d %d", &noFlipPieces[0], &noFlipPieces[1], &noFlipPieces[2]);
	}

	tmp = strcasestr(buffer, "NotTouch");

	if (tmp != NULL)
	{
		notTouchPieces.resize(3);
		sscanf(&tmp[9], "%d %d %d", &notTouchPieces[0], &notTouchPieces[1], &notTouchPieces[2]);
	}

	tmp = strcasestr(buffer, " Touch"); // Add space -- otherwise matches NotTouch

	if (tmp != NULL)
	{
		touchPieces.resize(3);
		sscanf(&tmp[7], "%d %d %d", &touchPieces[0], &touchPieces[1], &touchPieces[2]);
	}
	
	for (int x = 0; x < 66; x++)
	{
		char c = fgetc(f);
		while (isspace(c))
			c = fgetc(f);
		if (c == 'x')
		{
			s.state.Set(x, -1);
			this->solution.state.Set(x, -1);
		}
		else if (isalpha(c))
		{
			this->solution.state.Set(x, tolower(c)-'a');
			if (solution)
			{
				s.state.Set(x, tolower(c)-'a');
			}
			else {
				s.state.Set(x, 11);
			}
		}
		else if (isdigit(c))
		{
			this->solution.state.Set(x, tolower(c)-'0');
			s.state.Set(x, tolower(c)-'0');
		}
	}
	fclose(f);
//	this->solution = s;
	
	// Get all of the colors
	for (int y = 0; y < 6; y++)
	{
		for (int x = 0; x < 11; x++)
		{
			if (!Valid(x, y))
				continue;
			int piece = this->solution.state.Get(y*11+x);
			if (piece > pieceColors.size())
				pieceColors.resize(piece+1);
			pieceColors[piece] = rgbColor::hsl((piece)/11.0, (piece%2)?1.0:0.5, 0.5);
		}
	}
    for (auto i : diagPieces)
        pieceColors[i] = rgbColor::hsl((diagPieces[0])/11.0, (diagPieces[0]%2)?1.0:0.5, 0.5);
    for (auto i : notDiagPieces)
        pieceColors[i] = rgbColor::hsl((notDiagPieces[0])/11.0, (notDiagPieces[0]%2)?1.0:0.5, 0.5);
	for (auto i : noFlipPieces)
		pieceColors[i] = rgbColor::hsl((noFlipPieces[0])/11.0, (noFlipPieces[0]%2)?1.0:0.5, 0.5);
	for (auto i : touchPieces)
		pieceColors[i] = rgbColor::hsl((touchPieces[0])/11.0, (touchPieces[0]%2)?1.0:0.5, 0.5);
	for (auto i : notTouchPieces)
		pieceColors[i] = rgbColor::hsl((notTouchPieces[0])/11.0, (notTouchPieces[0]%2)?1.0:0.5, 0.5);
}

//
//void HexagonEnvironment::ConvertToSearchState(){
//
//}


HexagonSearchState HexagonEnvironment::GetInitState(HexagonSearchState &hss)
{
    std::vector<int> initPieces;
    
    HexagonSearchState init;
    init.index = hss.index;
    init.constraints = hss.constraints;
    init.dots = hss.dots;
    
    for (int x = 0; x < 10; x++)
    {
        int p = hss.initState / pow(11, x);
        p %= 11;
        p--;
        if(p!=-1)
            initPieces.push_back(p);
    }
    
    init.cnt = initPieces.size();
    
    for (int i = 0; i < initPieces.size(); i++) {
        init.state[i].piece = hss.state[initPieces[i]].piece;
        init.state[i].location = hss.state[initPieces[i]].location;
        init.bits ^= locations[hss.state[initPieces[i]].piece][hss.state[initPieces[i]].location];
    }
    
    return init;
}

void HexagonEnvironment::ConvertToHexagonState(HexagonSearchState &hss, HexagonState &hs, int initPattern){
    int trapizodeLocs = 0;
    hs.constraints = hss.constraints;
    hs.dots = hss.dots;
    
    std::vector<int> initPieces;

    if(initPattern != -1)
    {
        for (int x = 0; x < 10; x++)
        {
            int p = initPattern / pow(11, x);
            p %= 11;
            p--;
            if(p!=-1)
                initPieces.push_back(hss.state[p].piece);
        }
    }
    
    for (int u = 0; u < 66; u++) {
        hs.state.Set(u, 11);
    }
    
    hs.state.Set(0, -1);
    hs.state.Set(1, -1);
    hs.state.Set(9, -1);
    hs.state.Set(10, -1);
    hs.state.Set(11, -1);
    hs.state.Set(21, -1);

    hs.state.Set(65, -1);
    hs.state.Set(64, -1);
    hs.state.Set(56, -1);
    hs.state.Set(55, -1);
    hs.state.Set(54, -1);
    hs.state.Set(44, -1);
    
    for(int x = 0; x < hss.cnt; x++)
    {
        /*
         
         xxhhhhcccxx
         xhhe66cccbx
         ddeee66bbbb
         ddd5ee66bjj
         xdi55aaaajx
         xxii555aaxx
         
         */
        
        int piece = hss.state[x].piece;
        int location = hss.state[x].location;
        uint64_t loc = locations[piece][location];//[hss.state[x].piece, hss.state[x].location];
        
        if(initPattern != -1 && (find(initPieces.begin(), initPieces.end(), piece) == initPieces.end()))
            continue;
        
//        std::cout << "RESIZING COLORS " << pieceColors.size();
//        if (piece > pieceColors.size())
//            pieceColors.resize(piece+1);
//        pieceColors[piece] = rgbColor::hsl((piece)/11.0, (piece%2)?1.0:0.5, 0.5);
        
//        std::cout << "RESIZING COLORS END " << pieceColors.size();
        
        
//        std::cout << hss.state[x].piece << " " << hss.state[x].location<< " " << loc << '\n';

        
        for (int t = 0; t < 66; t++)// goes to 66 for hss!
        {
//            uint64_t fixedLoc = loc + 2 + (loc > 300 ? 3 : 0) + (loc > 400 ? 1 : 0) + (loc > 500 ? 3 : 0);
            
            int fixedT = (t == 0 || t == 1 || t == 9 || t == 10 || t == 11 || t == 21 || t == 65 || t == 64 || t == 56 || t == 55 || t == 54 || t == 44) ? -1 : (t / 11 == 0 ? (t-2) : (t / 11 == 1 ? (t-5) : (t / 11 == 2 || t / 11 == 3 ? (t-6) : (t / 11 == 4 ? (t-7) : (t-10)))));
            
            if(fixedT < 0) continue;
            
            if ((loc>>fixedT)&1)
            {
                int mappedPiece = mapPiece[piece];
                if(mappedPiece == 8) trapizodeLocs++;
                hs.state.Set(t, mappedPiece == 8 && trapizodeLocs > 3 ? 10 : mappedPiece);

//                int x1, y1;
//                IndexToXY(t, x1, y1);
                
//                printf("%d : %d => %d\n", t, fixedT, mapPiece[piece]);
//                flip_loc |= (one<<flipTable[x]);
            }
        }
        
    }
    
//    printf("trapizode locs: %s \n", trapizodeLocs);

}

void HexagonEnvironment::BuildLocationTable()
{
    //    uint64_t newLocations[numPieces][14*6*2+1];
    uint64_t one = 1;
    bool V = false;
    
    for(int piece = 0; piece < numPieces; piece++)
    {
        std::vector<uint64_t> locs;
        
        uint64_t loc_orig = locations_orig[piece][1];//loop through rotations and flips
        
        
        for (int flip = 0; flip < 2; flip++)
        {
            uint64_t flip_loc = flip == 1 ? 0 : loc_orig;
            
            if(flip == 1)
            {
                for (int x = 0; x < 54; x++) // simple and dumb
                {
                    if ((loc_orig>>x)&1)
                    {
                        flip_loc |= (one<<flipTable[x]);
                    }
                }
            }
            
            for (int rots = 0; rots < 6; rots++)
            {
                uint64_t loc = flip_loc;//rots == 0 ? flip_loc : 0;
                
                for(int rot = 0; rot < rots; rot++)
                {
                    uint64_t rot_loc = 0;
                    for (int x = 0; x < 54; x++) // simple and dumb
                    {
                        if ((loc>>x)&1)
                        {
                            rot_loc |= (one<<rotateCWTable[x]);
                        }
                    }
                    loc = rot_loc;
                }
                
                std::vector<int> b;
                
                for (int t = 0; t < 54; t++)
                {
                    if ((loc>>t)&1)
                    {
                        b.push_back(t);
                    }
                }
                
                int size = b.size();//sizeof(b)/sizeof(*b);
                
                if(V)
                {
                    std::cout << "(";
                    for(int p = 0; p < size; p++)
                    {printf("%d", b[p]);if(p<(size-1))std::cout << ", ";}
                    std::cout << ")\n";
                }
                
                int bits[size][2];
                
                for(int p = 0; p < size; p++)
                {
                    int loc = b[p];
                    loc += loc < 7 ? 2 : (loc < 16 ? 5 : (loc < 38 ? 6 : (loc < 47 ? 7 : 10)));
                    
                    bits[p][0] = loc % 11;
                    bits[p][1] = loc / 11;
                }
                
                if(V)
                {
                    std::cout << "(";
                    for(int p = 0; p < size; p++)
                    {printf("(%d,%d)", bits[p][0],bits[p][1]);if(p<(size-1))std::cout << ", ";}
                    std::cout << ")\n\n";
                }
                
                for (int y = -6; y < 6; y++)
                {
                    for (int x = -10; x < 10; x++)
                    {
                        if(((bits[0][0]+x)+11*(bits[0][1]+y))%2 != (bits[0][0]+11*bits[0][1])%2)
                            continue;
                        
                        int bits2[size][2];
                        
                        for(int p = 0; p < size; p++)// can be moved down
                        {
                            bits2[p][0] = bits[p][0] + x;
                            bits2[p][1] = bits[p][1] + y;
                        }
                        
                        bool valid = true;
                        
                        int bitsr[size];
                        uint64_t location = 0;
                        
                        for(int p = 0; p < size; p++)
                        {
                            if((bits2[p][0] < 2 && bits2[p][1] % 5 == 0) ||
                               (bits2[p][0] < 1 && (bits2[p][1]-1) % 3 == 0) ||
                               (bits2[p][0] > 8 && bits2[p][1] % 5 == 0) ||
                               (bits2[p][0] > 9 && (bits2[p][1]-1) % 3 == 0) ||
                               bits2[p][0] > 10 || bits2[p][0] < 0 || bits2[p][1] > 5 || bits2[p][1] < 0)
                            {
                                valid = false;
                                break;
                            }
                            
                            int bit = bits2[p][0] + 11*bits2[p][1];
                            bit -= bits2[p][1] == 0 ? 2 : (bits2[p][1] == 1 ? 5 : (bits2[p][1] == 2 || bits2[p][1] == 3 ? 6 : (bits2[p][1] == 4 ? 7 : 10)));
                            
                            bitsr[p] = bit;
                            
                            location |= (one<<bit);
                        }
                        
                        if(!valid)
                            continue;
                        
                        if (find(locs.begin(), locs.end(), location) == locs.end())
                            locs.push_back(location);
                        
                        if(V)
                        {
                            std::cout << "(";
                            for(int p = 0; p < size; p++)
                            {printf("%d", bitsr[p]);if(p<(size-1))std::cout << ", ";}
                            std::cout << ")\n";
                        }
                        
                        //                        std::vector<int> b2;
                        //
                        //                        for (int t = 0; t < 54; t++)
                        //                        {
                        //                            if ((location>>t)&1)
                        //                            {
                        //                                b2.push_back(t);
                        //                            }
                        //                        }
                        //
                        //                        int size2 = b2.size();//sizeof(b)/sizeof(*b);
                        //
                        //                        if(true)
                        //                        {
                        //                            std::cout << "(";
                        //                            for(int p = 0; p < size2; p++)
                        //                            {printf("%d", b2[p]);if(p<(size2-1))std::cout << ", ";}
                        //                            std::cout << ")\n";
                        //                        }
                    }
                }
            }
            
            if(flip == 0)
                noFlipMoveCount[piece] = locs.size();
        }
        
        locations[piece][0] = locs.size();
        
        for(int loc = 0; loc < locs.size(); loc++)
        {
            locations[piece][1+loc] = locs[loc];
            std::vector<int> b;
            
            for (int t = 0; t < 54; t++)
            {
                if ((locations[piece][1+loc]>>t)&1)
                {
                    b.push_back(t);
                }
            }
            
            int size = b.size();//sizeof(b)/sizeof(*b);
            
            if(printLocTables)
            {
                std::cout << "["<<(loc+1)<<"] (";
                for(int p = 0; p < size; p++)
                {printf("%d", b[p]);if(p<(size-1))std::cout << ", ";}
                std::cout << ")\n";
            }
        }
        
        //        std::vector<int> b;
        //
        //        for (int t = 0; t < 54; t++)
        //        {
        //            if ((locations[0][10]>>t)&1)
        //            {
        //                b.push_back(t);
        //            }
        //        }
        //
        //        int size = b.size();//sizeof(b)/sizeof(*b);
        //
        //        if(true)
        //        {
        //            std::cout << "+++ (";
        //            for(int p = 0; p < size; p++)
        //            {printf("%d", b[p]);if(p<(size-1))std::cout << ", ";}
        //            std::cout << ")\n";
        //        }
        if(printLocTables)
            std::cout << "\n\n";
    }
}

    
    void HexagonEnvironment::BuildHolesTable()
    {
    //    uint64_t newLocations[numPieces][14*6*2+1];
        uint64_t one = 1;
        bool V = false;
        int hole_locs_size;

        for(int piece = 0; piece < numPieces; piece++)
        {
            uint64_t loc_orig = locations_orig[piece][1];//loop through rotations and flips
//            uint64_t hole_loc_orig = hole_locations_orig[piece][1];//loop through rotations and flips
// print when adding
            for (int even = 0; even < 2; even ++)
            {
                uint64_t hole_loc_orig = even == 1 ? hole_locations_orig[piece][2]: hole_locations_orig[piece][1];

                for (int flip = 0; flip < 2; flip++)//TODO check flips
                {
                    std::vector<uint64_t> locs;
                    std::vector<std::vector<uint64_t>> hole_locs;
                    
                    uint64_t flip_loc = flip == 1 ? 0 : loc_orig;
                    uint64_t hole_flip_loc = flip == 1 ? 0 : hole_loc_orig;
                    
                    if(flip == 1)
                    {
                        for (int x = 0; x < 54; x++) // simple and dumb
                        {
                            if ((loc_orig>>x)&1)
                            {
                                flip_loc |= (one<<flipTable[x]);
                            }
                            
                            if ((hole_loc_orig>>x)&1)
                            {
                                hole_flip_loc |= (one<<flipTable[x]);
                            }
                        }
                        //hole flip normally? (confirm)
                    }
                    
                    
                    //                if(flip_loc != hole_flip_loc)
                    //                {
                    //
                    //                    std::cout << "R 0: " << std::bitset<54>(flip_loc) << "\n";
                    //                    std::cout << "R 1: " << std::bitset<54>(hole_flip_loc) << "\n";
                    //
                    //                }
                    
                    for (int rots = 0; rots < 6; rots++)
                    {
                        uint64_t loc = flip_loc;//rots == 0 ? flip_loc : 0;
                        uint64_t hole_loc = hole_flip_loc;//rots == 0 ? flip_loc : 0;
                        
                        for(int rot = 0; rot < rots; rot++)
                        {
                            uint64_t rot_loc = 0;
                            uint64_t hole_rot_loc = 0;
                            
                            for (int x = 0; x < 54; x++) // simple and dumb
                            {
                                if ((loc>>x)&1)
                                {
                                    rot_loc |= (one<<rotateCWTable[x]);
                                }
                                if ((hole_loc>>x)&1)
                                {
                                    hole_rot_loc |= (one<<rotateCWTable[x]);
                                }
                            }
                            loc = rot_loc;
                            hole_loc = hole_rot_loc;
                            
                            //hole rot normally? (confirm)
                        }
                        
                        
                        //                    if(loc != hole_loc)
                        //                    {
                        //
                        //                        std::cout << "R 0: " << std::bitset<54>(loc) << "\n";
                        //                        std::cout << "R 1: " << std::bitset<54>(hole_loc) << "\n";
                        //
                        //                    }
                        
                        std::vector<int> b;
                        std::vector<int> hole_b;
                        
                        for (int t = 0; t < 54; t++)
                        {
                            if ((loc>>t)&1)
                            {
                                b.push_back(t);
                            }
                            if ((hole_loc>>t)&1)
                            {
                                hole_b.push_back(t);
                            }
                        }
                        
                        int size = b.size();//sizeof(b)/sizeof(*b);
                        int hole_size = hole_b.size();//sizeof(b)/sizeof(*b);
                        
                        if(V)
                        {
                            std::cout << "(";
                            for(int p = 0; p < size; p++)
                            {printf("%d", b[p]);if(p<(size-1))std::cout << ", ";}
                            std::cout << ")\n";
                        }
                        
                        int bits[size][2], hole_bits[hole_size][2];
                        
                        for(int p = 0; p < size; p++)
                        {
                            int loc = b[p];
                            loc += loc < 7 ? 2 : (loc < 16 ? 5 : (loc < 38 ? 6 : (loc < 47 ? 7 : 10)));
                            
                            bits[p][0] = loc % 11;
                            bits[p][1] = loc / 11;
                        }
                        
                        for(int p = 0; p < hole_size; p++)
                        {
                            int loc = hole_b[p];
                            loc += loc < 7 ? 2 : (loc < 16 ? 5 : (loc < 38 ? 6 : (loc < 47 ? 7 : 10)));
                            
                            hole_bits[p][0] = loc % 11;
                            hole_bits[p][1] = loc / 11;
                        }
                        
//                        for(int p = 0; p < hole_size; p++)
//                        {
//                            if(b[p] != hole_b[p])// || bits[p][0] != hole_bits[p][0])
//                            {
//                                std::cout << b[p] << " " << hole_b[p] << "CATCH";
//                                
//                            }
//                        }
                        if(V)
                        {
                            std::cout << "(";
                            for(int p = 0; p < size; p++)
                            {printf("(%d,%d)", bits[p][0],bits[p][1]);if(p<(size-1))std::cout << ", ";}
                            std::cout << ")\n\n";
                        }
                        
                        for (int y = -6; y < 6; y++)
                        {
                            for (int x = -10; x < 10; x++)
                            {
                                if(((bits[0][0]+x)+11*(bits[0][1]+y))%2 != (bits[0][0]+11*bits[0][1])%2)
                                    continue;
                                
                                int bits2[size][2], hole_bits2[hole_size][2];
                                
                                for(int p = 0; p < size; p++)// can be moved down
                                {
                                    bits2[p][0] = bits[p][0] + x;
                                    bits2[p][1] = bits[p][1] + y;
                                    
                                    //peform same movement for hole bits
                                }
                                
                                for(int p = 0; p < hole_size; p++)// can be moved down
                                {
                                    hole_bits2[p][0] = hole_bits[p][0] + x;
                                    hole_bits2[p][1] = hole_bits[p][1] + y;
                                    
                                    //peform same movement for hole bits
                                }
                                
                                bool valid = true;
                                
                                //                            int bitsr[size], hole_bitsr[hole_size];
                                uint64_t location = 0;
                                uint64_t hole_location = 0;
                                
                                for(int p = 0; p < size; p++)
                                {
                                    if((bits2[p][0] < 2 && bits2[p][1] % 5 == 0) ||
                                       (bits2[p][0] < 1 && (bits2[p][1]-1) % 3 == 0) ||
                                       (bits2[p][0] > 8 && bits2[p][1] % 5 == 0) ||
                                       (bits2[p][0] > 9 && (bits2[p][1]-1) % 3 == 0) ||
                                       bits2[p][0] > 10 || bits2[p][0] < 0 || bits2[p][1] > 5 || bits2[p][1] < 0)
                                    {
                                        valid = false;
                                        break;
                                    }
                                    
                                    //                                int bit = bits2[p][0] + 11*bits2[p][1];
                                    //                                bit -= bits2[p][1] == 0 ? 2 : (bits2[p][1] == 1 ? 5 : (bits2[p][1] == 2 || bits2[p][1] == 3 ? 6 : (bits2[p][1] == 4 ? 7 : 10)));
                                    //
                                }
                                
                                if(!valid)
                                    continue;
                                
                                for (int p = 0; p < hole_size; p++) {
                                    int hole_bit = hole_bits2[p][0] + 11*hole_bits2[p][1];
                                    hole_bit -= hole_bits2[p][1] == 0 ? 2 : (hole_bits2[p][1] == 1 ? 5 : (hole_bits2[p][1] == 2 || hole_bits2[p][1] == 3 ? 6 : (hole_bits2[p][1] == 4 ? 7 : 10)));
                                    
                                    hole_location |= (one<<hole_bit);
                                }
                                
                                for (int p = 0; p < size; p++) {
                                    int bit = bits2[p][0] + 11*bits2[p][1];
                                    bit -= bits2[p][1] == 0 ? 2 : (bits2[p][1] == 1 ? 5 : (bits2[p][1] == 2 || bits2[p][1] == 3 ? 6 : (bits2[p][1] == 4 ? 7 : 10)));
                                    
                                    location |= (one<<bit);
                                }
                                
                                //                            std::cout << "RF 5: " << piece << " " << rots << " " << flip << " " << (location == hole_location ? "EQ" : "NE") << "\n";
                                
                                
                                if (find(locs.begin(), locs.end(), location) == locs.end())
                                {
                                    locs.push_back(location);
                                    //                                hole_locs.push_back(hole_location);
                                    
                                    std::vector<uint64_t> ls;
                                    ls.push_back(hole_location);
                                    
                                    hole_locs.push_back(ls);
                                    
                                    
                                    //                                std::cout << "S 0: " << std::bitset<54>(location) << "\n";
                                    //                                std::cout << "S 1: " << std::bitset<54>(hole_location) << "\n";
                                    
                                }
                                else
                                {
                                    int w = find(locs.begin(), locs.end(), location) - locs.begin();
                                    
                                    //                                std::cout << "HOLE AGAIN " << w << " " << hole_locs[w].size() << "\n";
                                    
                                    if(find(hole_locs[w].begin(), hole_locs[w].end(), hole_location) == hole_locs[w].end())
                                    {
                                        hole_locs[w].push_back(hole_location);
                                        
                                        if(piece == 3 && w == 1 && hole_locs[w].size() == 2)
                                        {
//                                            std::cout << "G 0: " << std::bitset<54>(location) << "\n";
//                                            std::cout << "G 1: " << std::bitset<54>(hole_locs[w][0]) << "\n";
//                                            std::cout << "G 2: " << std::bitset<54>(hole_locs[w][1]) << "\n";
//                                            std::cout << "G 3: " << rots << " " << even << " " << flip << "\n";
                                        }
                                    }
                                }
                                
                                if(V)
                                {
                                    //                                std::cout << "(";
                                    //                                for(int p = 0; p < size; p++)
                                    //                                {printf("%d", bitsr[p]);if(p<(size-1))std::cout << ", ";}
                                    //                                std::cout << ")\n";
                                }
                                
                                //                        std::vector<int> b2;
                                //
                                //                        for (int t = 0; t < 54; t++)
                                //                        {
                                //                            if ((location>>t)&1)
                                //                            {
                                //                                b2.push_back(t);
                                //                            }
                                //                        }
                                //
                                //                        int size2 = b2.size();//sizeof(b)/sizeof(*b);
                                //
                                //                        if(true)
                                //                        {
                                //                            std::cout << "(";
                                //                            for(int p = 0; p < size2; p++)
                                //                            {printf("%d", b2[p]);if(p<(size2-1))std::cout << ", ";}
                                //                            std::cout << ")\n";
                                //                        }
                            }
                        }
                    }
                    
                    
                    for(int loc = 0; loc < hole_locs.size(); loc++)
                    {
                        (flip == 0 ? (even == 0 ? localized_holes_side1_odd : localized_holes_side1_even) : (even == 0 ? localized_holes_side2_odd : localized_holes_side2_even))[piece][loc+1][0] = hole_locs[loc].size();
                        for (int q = 0; q < hole_locs[loc].size(); q++) {
                            (flip == 0 ? (even == 0 ? localized_holes_side1_odd : localized_holes_side1_even) : (even == 0 ? localized_holes_side2_odd : localized_holes_side2_even))[piece][loc+1][1+q] = hole_locs[loc][q];
                        }
                        
//                        if(piece == 3)
//                        {
//
//                            std::cout << "piece " << piece << " no flip moves " << noFlipMoveCount[piece] << " total moves " << locations[piece][0] << " 1o " << localized_holes_side1_odd[piece][loc][0]<< " 1e " << localized_holes_side1_even[piece][loc][0]<< " 2o " << localized_holes_side2_odd[piece][loc][0]<< " 2e " << localized_holes_side2_even[piece][loc][0] << "\n";
//                        }
                    }
                    
                    hole_locs_size = hole_locs.size();
//
                    
                }
            }
            
            
            if(piece == 2)
            {
//                std::cout << "\n\n" << localized_holes_side1_odd[piece][1][0] << "\n" << std::bitset<54>(locations[piece][78]) << "\n" << std::bitset<54>(localized_holes_side1_odd[piece][78][1])<< "\n" << std::bitset<54>(localized_holes_side1_even[piece][78][1]) << "\n";

                for(int loc = 0; loc < noFlipMoveCount[piece]; loc++)
                {
//                    std::cout << "piece " << piece << " loc " << (loc+1) <<  " no flip moves " << noFlipMoveCount[piece] << " total moves " << locations[piece][0] << " 1o " << localized_holes_side1_odd[piece][loc+1][0]<< " 1e " << localized_holes_side1_even[piece][loc+1][0] << "\n";
                }

                for(int loc = 0; loc < noFlipMoveCount[piece]; loc++)
                {
//                    std::cout << "piece " << piece << " loc " << (loc+1) <<  " no flip moves " << noFlipMoveCount[piece] << " total moves " << locations[piece][0] << " 2o " << localized_holes_side2_odd[piece][loc+1][0]<< " 2e " << localized_holes_side2_even[piece][loc+1][0] << "\n";
                }

            }
            
            

//            localized_holes[piece][0] = hole_locs.size();
            
//            std::cout << "SIZE " << hole_locs.size() << "\n";

//                uint64_t locz_holes = (flip == 0 ? localized_holes : localized_holes_flipped);
            
            


        }
        
//                std::vector<int> b; EDIT: print function from here to end of "for"
//
//                for (int t = 0; t < 54; t++)
//                {
//                    if ((localized_holes[piece][1+loc]>>t)&1)
//                    {
//                        b.push_back(t);
//                    }
//                }
//
//                int size = b.size();//sizeof(b)/sizeof(*b);
//
//                if(true)
//                {
//                    std::cout << "["<<(loc+1)<<"] (";
//                    for(int p = 0; p < size; p++)
//                    {printf("%d", b[p]);if(p<(size-1))std::cout << ", ";}
//                    std::cout << ")\n";
//                }
        
        //        std::vector<int> b;
        //
        //        for (int t = 0; t < 54; t++)
        //        {
        //            if ((locations[0][10]>>t)&1)
        //            {
        //                b.push_back(t);
        //            }
        //        }
        //
        //        int size = b.size();//sizeof(b)/sizeof(*b);
        //
        //        if(true)
        //        {
        //            std::cout << "+++ (";
        //            for(int p = 0; p < size; p++)
        //            {printf("%d", b[p]);if(p<(size-1))std::cout << ", ";}
        //            std::cout << ")\n";
        //        }

    //            std::cout << "\n\n";
//
//
//    std::array<std::array<uint64_t, numPieces>, (14*6*2+1)> xs;
//
//    return xs;
//    int bits[] = {0,1,2};
//    bool done = false;
//    int size = sizeof(bits)/sizeof(*bits), inc = 0, aff = bits[0] % 2 == 0 ? 1 : -1;
//
//    for (int j = 0; j < size; j++)
//        bits[j] -= 2;
//
//
//
//
//    while(true)
//    {
//        bool touchingLeft = false, touchingRight = false;
//
//        for (int j = 0; j < size; j++)
//        {
//            int bit = bits[j] + 2;
//            touchingRight = touchingRight || bit == 6 || bit == 15 || bit == 26 || bit == 37 || bit == 46 || bit == 53;
//            touchingLeft = touchingLeft || bit == 0 || bit == 7 || bit == 16 || bit == 27 || bit == 38 || bit == 47;
//
//            if(bit > 53)
//            {
//                done = true;
//                break;
//            }
//
//            if(((bits[j] <= 6 && bit > 6) || (bits[j] <= 15 && bit > 15)))
//            {inc = -1 * aff; printf("\n");}
//
//            if(((bits[j] <= 37 && bit > 37) || (bits[j] <= 46 && bit > 46)))
//            {inc = 1 * aff; printf("\n");}
//
//            bits[j] = bit + inc;
//        }
//
//
//        if(done)
//            break;
//
//
//
//        if(!(touchingLeft && touchingRight))
//        {
////            table.add(bits);
//            printf("(%d, %d, %d)  ", bits[0], bits[1], bits[2]);
//        }
////        else
////        {
////            for (int j = 0; j < size; j++)
////                bits[j] += inc;
////        }
//
//        inc = 0;
//    }
//
//    bits(0, 1, 2), bits(2, 3, 4), bits(4, 5, 6),
//    bits(7, 8, 9), bits(9, 10, 11), bits(11, 12, 13), bits(13, 14, 15),
//    bits(16, 17, 18), bits(18, 19, 20), bits(20, 21, 22), bits(22, 23, 24), bits(24, 25, 26),
//    bits(28, 29, 30), bits(30, 31, 32), bits(32, 33, 34), bits(34, 35, 36),
//    bits(39, 40, 41), bits(41, 42, 43), bits(43, 44, 45),
//    bits(48, 49, 50), bits(50, 51, 52),
    
    
//
//    // downward pieces
//    bits(1, 2, 3), bits(3, 4, 5),
//    bits(8, 9, 10), bits (10, 11, 12), bits(12, 13, 14),
//    bits(17, 18, 19), bits(19, 20, 21), bits(21, 22, 23), bits(23, 24, 25),
//    bits(27, 28, 29), bits(29, 30, 31), bits(31, 32, 33), bits(33, 34, 35), bits(35, 36, 37),
//    bits(38, 39, 40), bits(40, 41, 42), bits(42, 43, 44), bits(44, 45, 46),
//    bits(47, 48, 49), bits(49, 50, 51), bits(51, 52, 53),
//    // one clockwise rotation
//    bits(5, 6, 14), bits(14, 15, 25), bits(25, 26, 37),
//    bits(3, 4, 12), bits(12, 13, 23), bits(23, 24, 35), bits(35, 36, 46),
//    bits(1, 2, 10), bits(10, 11, 21), bits(21, 22, 33), bits(33, 34, 44), bits(44, 45, 53),
//    bits(8, 9, 19), bits(19, 20, 31), bits(31, 32, 42), bits(42, 43, 51),
//    bits(17, 18, 29), bits(29, 30, 40), bits(40, 41, 49),
//    bits(27, 28, 38), bits(38, 39, 47),
//    // one clockwise rotation downward
//    bits(6, 14, 15), bits(15, 25, 26),
//    bits(4, 12, 13), bits(13, 23, 24), bits(24, 35, 36),
//    bits(2, 10, 11), bits(11, 21, 22), bits(22, 33, 34), bits(34, 44, 45),
//    bits(0, 8, 9), bits(9, 19, 20), bits(20, 31, 32), bits(32, 42, 43), bits(43, 51, 52),
//    bits(7, 17, 18), bits(18, 29, 30), bits(30, 40, 41), bits(41, 49, 50),
//    bits(16, 27, 28), bits(28, 38, 39), bits(39, 47, 48),
//    // two clockwise rotations
//    bits(27, 16, 17), bits(17, 7, 8), bits(8, 0, 1),
//    bits(38, 28, 29), bits(29, 18, 19), bits(19, 9, 10), bits(10, 2, 3),
//    bits(47, 39, 40), bits(40, 30, 31), bits(31, 20, 21), bits(21, 11, 12), bits(12, 4, 5),
//    bits(49, 41, 42), bits(42, 32, 33), bits(33, 22, 23), bits(23, 13, 14),
//    bits(51, 43, 44), bits(44, 34, 35), bits(35, 24, 25),
//    bits(53, 45, 46), bits(46, 36, 37),
//    // two clockwise rotations downward
//    bits(16, 17, 7), bits(7, 8, 0),
//    bits(28, 29, 18), bits(18, 19, 9), bits(9, 10, 2),
//    bits(39, 40, 30), bits(30, 31, 20), bits(20, 21, 11), bits(11, 12, 4),
//    bits(48, 49, 41), bits(41, 42, 32), bits(32, 33, 22), bits(22, 23, 13), bits(13, 14, 6),
//    bits(50, 51, 43), bits(43, 44, 34), bits(34, 35, 24), bits(24, 25, 15),
//    bits(52, 53, 45), bits(45, 46, 36), bits(36, 37, 26)

    //    bits(0, 1, 2, 3, 4, 5),
//    bits(7, 8, 9, 10, 11, 12), bits(9, 10, 11, 12, 13, 14),
//    bits(16, 17, 18, 19, 20, 21), bits(18, 19, 20, 21, 22, 23), bits(20, 21, 22, 23, 24, 25),
//    bits(28, 29, 30, 31, 32, 33), bits(30, 31, 32, 33, 34, 35), bits(32, 33, 34, 35, 36, 37),
//    bits(39, 40, 41, 42, 43, 44), bits(41, 42, 43, 44, 45, 46),
//    bits(48, 49, 50, 51, 52, 53),
    
//    bits(28, 38, 39, 47, 48, 49), bits(16, 27, 28, 38, 39, 40),
//    bits(30, 40, 41, 49, 50, 51), bits(18, 29, 30, 40, 41, 42), bits(7, 17, 18, 29, 30, 31),
//    bits(32, 42, 43, 51, 52, 53), bits(20, 31, 32, 42, 43, 44), bits(9, 19, 20, 31, 32, 33), bits(0, 8, 9, 19, 20, 21),
//    bits(22, 33, 34, 44, 45, 46), bits(11, 21, 22, 33, 34, 35), bits(2, 10, 11, 21, 22, 23),
//    bits(13, 23, 24, 35, 36, 37),
}

/*
 
 pieces:
     flips:
         rotations:
            locations
            - similar? add to location holes list
            - new? add a new location
 
 
 
 [bits(), bits(), ...]
    |
    V
 [holes(), holes(), holes(), ...]
 
*/


std::string HexagonEnvironment::PrintHexagonState(HexagonState &hs){
    std::string res = "";
    for (int t = 0; t < 66; t++)// goes to 66 for hss!
    {
        if(t % 11 == 0 && t != 0) res += "\n";
        int p = hs.state.Get(t);
        res += p == 15 ? "x" : std::to_string(p);
    }
    
    return res;
}

void Hexagon::GetSuccessors(const HexagonState &nodeID, std::vector<HexagonState> &neighbors) const
{
	
}

void Hexagon::GetActions(const HexagonState &nodeID, std::vector<HexagonAction> &actions) const
{
	
}

HexagonAction Hexagon::GetAction(const HexagonState &s1, const HexagonState &s2) const
{
	HexagonAction a;
	return a;
}

void Hexagon::ApplyAction(HexagonState &s, HexagonAction a) const
{
	
}

void Hexagon::GetNextState(const HexagonState &, HexagonAction , HexagonState &) const
{
	
}

bool Hexagon::InvertAction(HexagonAction &a) const
{
	return true;
}


uint64_t Hexagon::GetStateHash(const HexagonState &node) const
{
	return 0;
}

uint64_t Hexagon::GetActionHash(HexagonAction act) const
{
	return 0;
}

/** Goal Test if the goal is stored **/
bool Hexagon::GoalTest(const HexagonState &node) const
{
	return true;
}

void Hexagon::RotateCW(HexagonState &s) const
{
	
}


bool Hexagon::GetBorder(int x, int y, int xoff, int yoff, Graphics::point &p1, Graphics::point &p2) const
{
	const float triangleWidth = 2.0/7;
	const float triangleHeight = triangleWidth/1.154700538379252; // 2/sqrt(3)
	const float xMargin = triangleWidth/2;
	const float yMargin = (2.0-triangleHeight*6)/2;
//	const float triangleHeight = 2.0/7;
//	const float triangleWidth = 1.154700538379252*triangleHeight; // 2/sqrt(3)
//	const float margin = triangleHeight/2;
	
	if (0==(x+y)%2) // points up
	{
		if (yoff < 0)
		{
			return false;
		}
		else if (xoff > 0)
		{
			p1 = {
				-1+xMargin+(x+2)*triangleWidth/2,
				-1+yMargin+(y+1)*triangleHeight
			};
			p2 = {
				-1+xMargin+(x+1)*triangleWidth/2,
				-1+yMargin+(y)*triangleHeight
			};
		}
		else if (xoff < 0)
		{
			p1 = {
				-1+xMargin+x*triangleWidth/2,
				-1+yMargin+(y+1)*triangleHeight
			};
			p2 = {
				-1+xMargin+(x+1)*triangleWidth/2,
				-1+yMargin+(y)*triangleHeight
			};
		}
		else if (yoff > 0)
		{
			p1 = {
				-1+xMargin+x*triangleWidth/2,
				-1+yMargin+(y+1)*triangleHeight
			};
			p2 = {
				-1+xMargin+(x+2)*triangleWidth/2,
				-1+yMargin+(y+1)*triangleHeight
			};
		}
		return true;
	}
	else { // points down
		if (yoff > 0)
		{
			return false;
		}
		else if (xoff > 0)
		{
			// upper right
			p1 = {
				-1+xMargin+(x+2)*triangleWidth/2,
				-1+yMargin+(y)*triangleHeight
			};
			// bottom tip
			p2 = {
				-1+xMargin+(x+1)*triangleWidth/2,
				-1+yMargin+(y+1)*triangleHeight
			};
		}
		else if (xoff < 0)
		{
			// upper left
			p1 = {
				-1+xMargin+(x)*triangleWidth/2,
				-1+yMargin+(y)*triangleHeight
			};
			// bottom tip
			p2 = {
				-1+xMargin+(x+1)*triangleWidth/2,
				-1+yMargin+(y+1)*triangleHeight
			};
		}
		else if (yoff < 0)
		{
			// upper right
			p1 = {
				-1+xMargin+(x+2)*triangleWidth/2,
				-1+yMargin+(y)*triangleHeight
			};
			// upper left
			p2 = {
				-1+xMargin+(x)*triangleWidth/2,
				-1+yMargin+(y)*triangleHeight
			};
		}
		return true;
//		// upper right
//		p1 = {
//			-1+margin+(x+2)*triangleHeight/2,
//			-1+margin+(y)*triangleHeight
//		};
//		// upper left
//		p2 = {
//			-1+margin+(x)*triangleHeight/2,
//			-1+margin+(y)*triangleHeight
//		};
//		// bottom tip
//		p3 = {
//			-1+margin+(x+1)*triangleHeight/2,
//			-1+margin+(y+1)*triangleHeight
//		};
//		return false;
	}
}

void Hexagon::GetCorners(int x, int y, Graphics::point &p1, Graphics::point &p2, Graphics::point &p3) const
{
	const float triangleWidth = 2.0/7;
	const float triangleHeight = triangleWidth/1.154700538379252; // 2/sqrt(3)
	const float xMargin = triangleWidth/2;
	const float yMargin = (2.0-triangleHeight*6)/2;

	if (0==(x+y)%2) // points up
	{
		p1 = {
			-1+xMargin+x*triangleWidth/2,
			-1+yMargin+(y+1)*triangleHeight
		};
		p2 = {
			-1+xMargin+(x+2)*triangleWidth/2,
			-1+yMargin+(y+1)*triangleHeight
		};
		p3 = {
			-1+xMargin+(x+1)*triangleWidth/2,
			-1+yMargin+(y)*triangleHeight
		};
	}
	else { // points down
		p1 = {
			-1+xMargin+(x+2)*triangleWidth/2,
			-1+yMargin+(y)*triangleHeight
		};
		p2 = {
			-1+xMargin+(x)*triangleWidth/2,
			-1+yMargin+(y)*triangleHeight
		};
		p3 = {
			-1+xMargin+(x+1)*triangleWidth/2,
			-1+yMargin+(y+1)*triangleHeight
		};
	}
}

bool Hexagon::Valid(int x, int y) const
{
	static bool valid[6][11] =
	{
		{false, false, true, true, true, true, true, true, true, false, false},
		{false, true, true, true, true, true, true, true, true, true, false},
		{true, true, true, true, true, true, true, true, true, true, true},
		{true, true, true, true, true, true, true, true, true, true, true},
		{false, true, true, true, true, true, true, true, true, true, false},
		{false, false, true, true, true, true, true, true, true, false, false}
	};
	return valid[y][x];
}

void Hexagon::Draw(Graphics::Display &display) const
{
	// Draw board
	display.FillRect(Graphics::rect({0,0}, 1.0), Colors::white);
	for (int y = 0; y < 6; y++)
	{
		for (int x = 0; x < 11; x++)
		{
			if (!Valid(x, y))
				//if (!valid[y][x])
				continue;
			Graphics::point p1, p2, p3;
			GetCorners(x, y, p1, p2, p3);
			display.FillTriangle(p1, p2, p3, Colors::lightgray);
			display.FrameTriangle(p1, p2, p3, 0.01f, Colors::darkgray);
		}
	}
	float xLoc = -1, yLoc = -1;
	float dim = 0.1;
	
	if (noFlipPieces.size() != 0)
	{
		display.FillRect({xLoc, yLoc, xLoc+dim, yLoc+dim}, pieceColors[noFlipPieces[0]]);
		display.DrawText("Cannot Flip", {xLoc+1.2f*dim, yLoc+dim/2.0f}, Colors::black, dim*0.8f, Graphics::textAlignLeft, Graphics::textBaselineMiddle);
		xLoc = 0;
	}
    if (diagPieces.size() != 0)
    {
        display.FillRect({xLoc, yLoc, xLoc+dim, yLoc+dim}, pieceColors[diagPieces[0]]);
        display.DrawText("Must Touch Diagonally", {xLoc+1.2f*dim, yLoc+dim/2.0f}, Colors::black, dim*0.8f, Graphics::textAlignLeft, Graphics::textBaselineMiddle);
        xLoc = 0;
    }
    if (notDiagPieces.size() != 0)
    {
        display.FillRect({xLoc, yLoc, xLoc+dim, yLoc+dim}, pieceColors[diagPieces[0]]);
        display.DrawText("Must Not Touch Diagonally", {xLoc+1.2f*dim, yLoc+dim/2.0f}, Colors::black, dim*0.8f, Graphics::textAlignLeft, Graphics::textBaselineMiddle);
        xLoc = 0;
    }
	if (notTouchPieces.size() != 0)
	{
		display.FillRect({xLoc, yLoc, xLoc+dim, yLoc+dim}, pieceColors[notTouchPieces[0]]);
		display.DrawText("Cannot Touch", {xLoc+1.2f*dim, yLoc+dim/2.0f}, Colors::black, dim*0.8f, Graphics::textAlignLeft, Graphics::textBaselineMiddle);
		xLoc = 0;
	}
	if (touchPieces.size() != 0)
	{
		display.FillRect({xLoc, yLoc, xLoc+dim, yLoc+dim}, pieceColors[touchPieces[0]]);
		display.DrawText("Must Touch Edges", {xLoc+1.2f*dim, yLoc+dim/2.0f}, Colors::black, dim*0.8f, Graphics::textAlignLeft, Graphics::textBaselineMiddle);
		xLoc = 0;
	}
}

void Hexagon::DrawSetup(Graphics::Display &display) const
{
	// Draw board
	display.FillRect(Graphics::rect({0,0}, 1.0), Colors::white);

	// Horribly inefficient for now; just looking for correctness
	// Could all be pre-computed and cached
	for (int piece = 0; piece < 10; piece++)
	{
		bool found = false;
		Graphics::rect bounds;
		// get bounding box for piece
		for (int y = 0; y < 6; y++)
		{
			for (int x = 0; x < 11; x++)
			{
				if (!Valid(x, y))
					continue;
				int p = solution.state.Get(y*11+x);
				if (piece == p)
				{
					Graphics::point p1, p2, p3;
					GetCorners(x, y, p1, p2, p3);

					if (!found)
					{
						found = true;
						bounds = Graphics::rect(p1, p2);
					}
					else
                    {
						bounds |= Graphics::rect(p1, p2);
					}
					bounds |= Graphics::rect(p2, p1);
					bounds |= Graphics::rect(p2, p3);
					bounds |= Graphics::rect(p3, p2);
					bounds |= Graphics::rect(p1, p3);
					bounds |= Graphics::rect(p3, p1);
				}
			}
		}

		float newWidth = 0.45f;
		float newHeight = 0.45f;
		float border = 0.01;
		float scale = 0.45f/std::max(bounds.right-bounds.left, bounds.bottom-bounds.top);
		float baseX = -0.9f+(piece%4)*(newWidth+border);
		float baseY = -0.7f+(piece>>2)*(newHeight+border);
//		std::cout << "Piece " << piece << " rect: " << bounds << "\n";
		// draw piece scaled
		for (int y = 0; y < 6; y++)
		{
			for (int x = 0; x < 11; x++)
			{
				if (!Valid(x, y))
					continue;
				int p = solution.state.Get(y*11+x);
				if (piece == p)
				{
					Graphics::point p1, p2, p3;
					GetCorners(x, y, p1, p2, p3);
					p1.x = baseX+(p1.x-bounds.left)*scale;
					p1.y = baseY+(p1.y-bounds.top)*scale;
					p2.x = baseX+(p2.x-bounds.left)*scale;
					p2.y = baseY+(p2.y-bounds.top)*scale;
					p3.x = baseX+(p3.x-bounds.left)*scale;
					p3.y = baseY+(p3.y-bounds.top)*scale;
					display.FillTriangle(p1, p2, p3, pieceColors[piece]);
				}
			}
		}
	}
	
	// Draw constraints at top
	{
		float xLoc = -1, yLoc = -1;
		float dim = 0.1;
		
		if (noFlipPieces.size() != 0)
		{
			display.FillRect({xLoc, yLoc, xLoc+dim, yLoc+dim}, pieceColors[noFlipPieces[0]]);
			display.DrawText("Cannot Flip", {xLoc+1.2f*dim, yLoc+dim/2.0f}, Colors::black, dim*0.8f, Graphics::textAlignLeft, Graphics::textBaselineMiddle);
			xLoc = 0;
		}
        if (diagPieces.size() != 0)
        {
//            display.FillRect({xLoc, yLoc, xLoc+dim, yLoc+dim}, pieceColors[diagPieces[0]]);
//            display.DrawText("Must Touch Diagonally", {xLoc+1.2f*dim, yLoc+dim/2.0f}, Colors::black, dim*0.8f, Graphics::textAlignLeft, Graphics::textBaselineMiddle);
//            xLoc = 0;
            
            display.FillRect({xLoc, yLoc, xLoc+dim, yLoc+dim}, pieceColors[diagPieces[0]]);
            xLoc += 1.2f * dim;
            display.FillRect({xLoc, yLoc, xLoc+dim, yLoc+dim}, pieceColors[diagPieces[1]]);
            xLoc += 1.2f * dim;
            display.DrawText("Must Touch Corners", {xLoc, yLoc+dim/2.0f}, Colors::black, dim*0.8f, Graphics::textAlignLeft, Graphics::textBaselineMiddle);
            xLoc = 0;
        }
        if (notDiagPieces.size() != 0)
        {
//            display.FillRect({xLoc, yLoc, xLoc+dim, yLoc+dim}, pieceColors[notDiagPieces[0]]);
//            display.DrawText("Must Not Touch Diagonally", {xLoc+1.2f*dim, yLoc+dim/2.0f}, Colors::black, dim*0.8f, Graphics::textAlignLeft, Graphics::textBaselineMiddle);
//            xLoc = 0;
            
            display.FillRect({xLoc, yLoc, xLoc+dim, yLoc+dim}, pieceColors[notDiagPieces[0]]);
            xLoc += 1.2f * dim;
            display.FillRect({xLoc, yLoc, xLoc+dim, yLoc+dim}, pieceColors[notDiagPieces[1]]);
            xLoc += 1.2f * dim;
            display.DrawText("Must Not Touch Corners", {xLoc, yLoc+dim/2.0f}, Colors::black, dim*0.8f, Graphics::textAlignLeft, Graphics::textBaselineMiddle);
            xLoc = 0;
        }
		if (notTouchPieces.size() != 0)
		{
//			display.FillRect({xLoc, yLoc, xLoc+dim, yLoc+dim}, pieceColors[notTouchPieces[0]]);
//			display.DrawText("Cannot Touch", {xLoc+1.2f*dim, yLoc+dim/2.0f}, Colors::black, dim*0.8f, Graphics::textAlignLeft, Graphics::textBaselineMiddle);
//			xLoc = 0;
            
            display.FillRect({xLoc, yLoc, xLoc+dim, yLoc+dim}, pieceColors[notTouchPieces[0]]);
            xLoc += 1.2f * dim;
            display.FillRect({xLoc, yLoc, xLoc+dim, yLoc+dim}, pieceColors[notTouchPieces[1]]);
            xLoc += 1.2f * dim;
            display.DrawText("Must Not Touch Edges", {xLoc, yLoc+dim/2.0f}, Colors::black, dim*0.8f, Graphics::textAlignLeft, Graphics::textBaselineMiddle);
            xLoc = 0;
		}
		if (touchPieces.size() != 0)
		{
            display.FillRect({xLoc, yLoc, xLoc+dim, yLoc+dim}, pieceColors[touchPieces[0]]);
            xLoc += 1.2f * dim;
            display.FillRect({xLoc, yLoc, xLoc+dim, yLoc+dim}, pieceColors[touchPieces[1]]);
            xLoc += 1.2f * dim;
			display.DrawText("Must Touch Edges", {xLoc, yLoc+dim/2.0f}, Colors::black, dim*0.8f, Graphics::textAlignLeft, Graphics::textBaselineMiddle);
			xLoc = 0;
		}
	}
}

const int revMapPiece[numPieces+1] = {7, 1, 0, 4, 6, 5, 3, 2, 8, 9, 8};// 8, 8/i 9/j
const float specialColors[5] = {0, 0.2, 0.5, 0.65, 0.8};

void Hexagon::Draw(Graphics::Display &display, const HexagonState &s) const
{
	// Draw objects
	for (int y = 0; y < 6; y++)
	{
		for (int x = 0; x < 11; x++)
		{
			if (!Valid(x, y))
				continue;
			Graphics::point p1, p2, p3;
			GetCorners(x, y, p1, p2, p3);
			int piece = s.state.Get(y*11+x);
			if (piece < 11)
			{
                /**
                 
                 int noFlipMoveCount[numPieces] =
                 {
                 //    kHexagon = 0, 2/c
                     4, // no flip symmetry
                 //    kButterfly = 1, 1/b
                     42, // no flip symmetry
                 //    kElbow = 2, 7/h
                     72, // no symmetry
                 //    kLine = 3, 6/g
                     72/2,
                 //    kMountains = 4, 3/d
                     156/2,
                 //    kWrench = 5, 5/f
                     156/2,
                 //    kTriangle = 6, 4/e
                     144/2,
                 //    kHook = 7, 0/a
                     168/2,
                 //    kTrapezoid = 8, 8/i 9/j
                     126,
                 //    kSnake = 9
                     72/2
                 };
                 
                 */
                int convPiece = revMapPiece[piece];
                int pp1 = comb % 4, pp2 = comb / 4;

                if(pp1 == pp2) pp2 = 3;
                
//                std::cout << "Piece: " << piece << " " << convPiece << " || " << pp1 << " " << pp2 << "\n";

                display.FillTriangle(p1, p2, p3, rgbColor::hsl(specialColors[convPiece < 2 ? 0 : ((convPiece == 3 || convPiece == 9) ? 1 : ((convPiece == 2 || convPiece == 8) ? 2 : ((convPiece == (pp1+4) || convPiece == (pp2+4)) ? 3 : 4)))], 0.5, 0.5));//pieceColors[piece]);(piece%2)?1.0:
			}
		}
	}
	// Draw Borders
	for (int y = 0; y < 6; y++)
	{
		for (int x = 0; x < 11; x++)
		{
			if (!Valid(x, y))
				//if (!valid[y][x])
				continue;
			Graphics::point p1, p2, p3;
			GetCorners(x, y, p1, p2, p3);
			int piece = s.state.Get(y*11+x);

			if ((x == 10) || (piece != s.state.Get(y*11+x+1)))
			{
				if (GetBorder(x, y, 1, 0, p1, p2))
				{
					display.DrawLine(p1, p2, 0.02, Colors::black);
				}
			}
			if ((x == 0) || (x > 0 && piece != s.state.Get(y*11+x-1)))
			{
				if (GetBorder(x, y, -1, 0, p1, p2))
				{
					display.DrawLine(p1, p2, 0.02, Colors::black);
				}
			}
			if ((y == 5) || (y < 5 && piece != s.state.Get((y+1)*11+x)))
			{
				if (GetBorder(x, y, 0, 1, p1, p2))
				{
					display.DrawLine(p1, p2, 0.02, Colors::black);
				}
			}
			if ((y == 0) || (y > 0 && piece != s.state.Get((y-1)*11+x)))
			{
				if (GetBorder(x, y, 0, -1, p1, p2))
				{
					display.DrawLine(p1, p2, 0.02, Colors::black);
				}
			}
		}
	}
    
    float dim = 0.1;
    float xLoc = -1 + dim/2.0f, yLoc = -1 + dim/2.0f;
    
//    colors = rgbColor::hsl(convPiece < 2 ? 0 : ((convPiece == 3 || convPiece == 9) ? 0.2 : ((convPiece == 2 || convPiece == 8) ? 0.4 : ((convPiece == (pp1+4) || convPiece == (pp2+4)) ? 0.6 : 0.8))), 0.5, 0.5)
//    std::cout << "NUM OF CONSTRAINTS " << s.constraints.size() << "\n";
    
    
    

    for (auto con : s.constraints) {
        int constraintType = con % 5;
        int p1 = (con / 10) % numPieces;
        int p2 = (con / 10) / numPieces;
                
        display.FillRect({xLoc, yLoc, xLoc+dim, yLoc+dim}, rgbColor::hsl(specialColors[p1], 0.5, 0.5));
        xLoc += 1.2f * dim;
        display.DrawText((constraintType == 1 ? "Must Not Touch Edges With" : (constraintType == 2 ? "Must Touch Edges With" : (constraintType == 3 ? "Must Not Touch Corners With" : "Must Touch Corners With"))), {xLoc, yLoc+dim/2.0f}, Colors::black, dim*0.8f, Graphics::textAlignLeft, Graphics::textBaselineMiddle);
        
        xLoc += (constraintType == 1 ? 11 : (constraintType == 2 ? 9.45 : (constraintType == 3 ? 11.5 : 10))) * dim;
        
        display.FillRect({xLoc, yLoc, xLoc+dim, yLoc+dim},rgbColor::hsl(specialColors[p2], 0.5, 0.5));
        xLoc = -0.9f;
        yLoc += 1.2f * dim;
    }
    
    xLoc = -1;
    yLoc = -1;

    display.DrawText(s.dots == (((1ull)<<54)-1) ? "Free" : "Dots", {1-dim/2.0f, dim+ yLoc}, Colors::black, dim*0.8f, Graphics::textAlignRight, Graphics::textBaselineMiddle);
    
    xLoc = -1;
    yLoc = -1;

    if(s.entropy != 0)
    {
        std::stringstream ss;
        ss << s.entropy;
        std::string str = ss.str();
        const char* buf = str.c_str();
        
        display.DrawText(buf, {1-dim/2.0f, 1 - dim}, rgbColor::hsl(0.33f - (s.entropy/24.0f)/3.0f, 0.5, 0.5), dim*0.8f, Graphics::textAlignRight, Graphics::textBaselineMiddle);
    }
    
    if(s.forbiddenPiece == -1) return;
    
    display.DrawText("Forbidden:", {-0.75f, 0.75}, Colors::black, dim*0.8f, Graphics::textAlignCenter, Graphics::textBaselineMiddle);
    
    float forbiddenScale = 0.25f, forbiddenX = -0.75f, forbiddenY = 1;
    
    int index = -1;
    
    for (int y = 0; y < 6; y++)
    {
        for (int x = 0; x < 11; x++)
        {
            if (!Valid(x, y))
                continue;
            
            index++;
            
            if(((locations[s.forbiddenPiece][1]>>index)&1) == 0) continue;
            
            Graphics::point p1, p2, p3;
            GetCorners(x, y, p1, p2, p3);
            
            p1 = { forbiddenX + p1.x * forbiddenScale , forbiddenY + p1.y * forbiddenScale};
            p2 = { forbiddenX + p2.x * forbiddenScale , forbiddenY + p2.y * forbiddenScale};
            p3 = { forbiddenX + p3.x * forbiddenScale , forbiddenY + p3.y * forbiddenScale};
            
//            int piece = s.state.Get(y*11+x);
            int piece = mapPiece[s.forbiddenPiece];
            if (piece < 11)
            {
                int convPiece = revMapPiece[piece];
                int pp1 = comb % 4, pp2 = comb / 4;

                if(pp1 == pp2) pp2 = 3;
                
                display.FillTriangle(p1, p2, p3, rgbColor::hsl(specialColors[convPiece < 2 ? 0 : ((convPiece == 3 || convPiece == 9) ? 1 : ((convPiece == 2 || convPiece == 8) ? 2 : ((convPiece == (pp1+4) || convPiece == (pp2+4)) ? 3 : 4)))], 0.5, 0.5));
            }
        }
    }
            
//    index = -1;
//
//    for (int y = 0; y < 6; y++)
//    {
//        for (int x = 0; x < 11; x++)
//        {
//            if (!Valid(x, y))
//                continue;
//
//            index++;
//
//            if(((locations[s.forbiddenPiece][1]>>index)&1) == 0) continue;
//
//            Graphics::point p1, p2, p3;
//            GetCorners(x, y, p1, p2, p3);
//
//            p1 = { -0.75f + p1.x * 0.25f , 0.75f + p1.y * 0.25f};
//            p2 = { -0.75f + p2.x * 0.25f , 0.75f + p2.y * 0.25f};
//            p3 = { -0.75f + p3.x * 0.25f , 0.75f + p3.y * 0.25f};
//
////            int piece = s.state.Get(y*11+x);
//            int piece = mapPiece[s.forbiddenPiece];
//
//            if ((x == 10) || (piece != s.state.Get(y*11+x+1)))
//            {
//                if (GetBorder(x, y, 1, 0, p1, p2))
//                {
//                    p1 = { -0.75f + p1.x * 0.25f , 0.75f + p1.y * 0.25f};
//                    p2 = { -0.75f + p2.x * 0.25f , 0.75f + p2.y * 0.25f};
//                    display.DrawLine(p1, p2, 0.02, Colors::black);
//                }
//            }
//            if ((x == 0) || (x > 0 && piece != s.state.Get(y*11+x-1)))
//            {
//                if (GetBorder(x, y, -1, 0, p1, p2))
//                {
//                    p1 = { -0.75f + p1.x * 0.25f , 0.75f + p1.y * 0.25f};
//                    p2 = { -0.75f + p2.x * 0.25f , 0.75f + p2.y * 0.25f};
//                    display.DrawLine(p1, p2, 0.02, Colors::black);
//                }
//            }
//            if ((y == 5) || (y < 5 && piece != s.state.Get((y+1)*11+x)))
//            {
//                if (GetBorder(x, y, 0, 1, p1, p2))
//                {
//                    p1 = { -0.75f + p1.x * 0.25f , 0.75f + p1.y * 0.25f};
//                    p2 = { -0.75f + p2.x * 0.25f , 0.75f + p2.y * 0.25f};
//                    display.DrawLine(p1, p2, 0.02, Colors::black);
//                }
//            }
//            if ((y == 0) || (y > 0 && piece != s.state.Get((y-1)*11+x)))
//            {
//                if (GetBorder(x, y, 0, -1, p1, p2))
//                {
//                    p1 = { -0.75f + p1.x * 0.25f , 0.75f + p1.y * 0.25f};
//                    p2 = { -0.75f + p2.x * 0.25f , 0.75f + p2.y * 0.25f};
//                    display.DrawLine(p1, p2, 0.02, Colors::black);
//                }
//            }
//        }
//    }
}

