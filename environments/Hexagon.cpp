//
//  Hexagon.cpp
//  Hexagon
//
//  Created by Nathan Sturtevant on 11/13/21.
//  Copyright Â© 2021 MovingAI. All rights reserved.
//

#include "Hexagon.h"
#include <ctype.h>
#include <string>
#include <map>
#include<cmath>
#include <thread>
#include <cstdlib>
//#include "pbPlots.hpp"
//#include "supportLib.hpp"
#include "vectorCache.h"
#include <sstream>

using namespace std;

#include "SVGUtil.h"
//#include <boost/serialization/map.hpp>
//#include <boost/serialization/set.hpp>
//#include <fstream>

#pragma mark -
#pragma mark Efficient Hexagon Search Code
#pragma mark -

constexpr uint64_t bits(uint64_t a, uint64_t b)
{
//    const uint64_t one = 1;
    return ((((uint64_t)1)<<a)|(((uint64_t)1)<<b));
}

constexpr uint64_t bits(uint64_t a, uint64_t b, uint64_t c, uint64_t d)
{
//    const uint64_t one = 1;
    return ((((uint64_t)1)<<a)|(((uint64_t)1)<<b)|(((uint64_t)1)<<c)|(((uint64_t)1)<<d));
}

constexpr uint64_t bits(uint64_t a, uint64_t b, uint64_t c)
{
//    const uint64_t one = 1;
    return ((((uint64_t)1)<<a)|(((uint64_t)1)<<b)|(((uint64_t)1)<<c));
}

constexpr uint64_t bits(uint64_t a, uint64_t b, uint64_t c, uint64_t d, uint64_t e, uint64_t f)
{
    return bits(a, b, c)|bits(d, e, f);
}

//(1, 2, 3, 9, 10, 11)
const int rotateCWTable[54] =
{5,6,14,15,25,26,37,3,4,12,13,23,24,35,36,46,1,2,10,11,21,22,33,34,44,45,53,0,8,9,19,20,31,32,42,43,51,52,7,17,18,29,30,40,41,49,50,16,27,28,38,39,47,48};

const int flipTable[54] =
{47,48,49,50,51,52,53,38,39,40,41,42,43,44,45,46,27,28,29,30,31,32,33,34,35,36,37,16,17,18,19,20,21,22,23,24,25,26,7,8,9,10,11,12,13,14,15,0,1,2,3,4,5,6};
// 49,39,40,41,42,30
const int mapPiece[numPieces] =    {2, 1, 7, 6, 3, 5, 4, 0, 8, 9};

int noFlipMoveCount[numPieces] =
{
//	kHexagon = 0, 2/c
	4, // no flip symmetry
//	kButterfly = 1, 1/b
	42, // no flip symmetry
//	kElbow = 2, 7/h
	72, // no symmetry
//	kLine = 3, 6/g
	72/2,
//	kMountains = 4, 3/d
	156/2,
//	kWrench = 5, 5/f
	156/2,
//	kTriangle = 6, 4/e
	144/2,
//	kHook = 7, 0/a
	168/2,
//	kTrapezoid = 8, 8/i 9/j
	126,
//	kSnake = 9
	72/2
};

bool printLocTables = false;

uint64_t locations[numPieces][192+1];
uint64_t localized_holes[numPieces][192+1][12+1];

uint64_t localized_holes_side1_odd[numPieces][192+1][12+1];
uint64_t localized_holes_side1_even[numPieces][192+1][12+1];
uint64_t localized_holes_side2_odd[numPieces][192+1][12+1];
uint64_t localized_holes_side2_even[numPieces][192+1][12+1];

const uint64_t hole_locations_orig[numPieces][3] = // 0 1
{
    {
        0, // kHexagon
        bits(0, 2, 9),
        bits(1, 8, 10),

    },
    {
        1, // kButterfly
        bits(1, 3, 10),
        bits(2, 9, 11),
    },
    {
        1, // kElbow
        bits(0, 2, 7),
        bits(1, 3, 8),
    },
    {
        1, // kLine
        bits(0, 2, 4),
        bits(1, 3, 5),
    },
    {
        1, // kMountain
        bits(0, 2, 7, 9),
        bits(1, 8),
    },
    {
        1, // kWrench
        bits(0, 2, 4),
        bits(1, 3, 8),
    },
    {
        1, // kTriangle
        bits(2, 4),
        bits(1, 3, 5, 10),
    },
    {
        1, // kHook
        bits(0, 9, 11),
        bits(1, 8, 10),
    },
    {
        1, // kTrapezoid
        bits(0, 2),
        2,
    },
    {
        1, // kSnake
        bits(0, 2, 11),
        bits(1, 10, 12),
    },
};

const uint64_t locations_orig[numPieces][14*6*2+1] =
{ // pieces
	{ // hexagon piece - symmetric in all ways
//		4, // count
//		bits(0, 1, 2, 8, 9, 10), bits(2, 3, 4, 10, 11, 12),
//		bits(9, 10, 11, 19, 20, 21), bits(20, 21, 22, 31, 32, 33)

		// re-ordered so first 4 are the ones we want. The remaining ones are used for symmetry building
		4, // kHexagon count
		bits(0, 1, 2, 8, 9, 10), bits(2, 3, 4, 10, 11, 12), bits(9, 10, 11, 19, 20, 21), bits(20, 21, 22, 31, 32, 33),
		bits(7, 8, 9, 17, 18, 19), bits(11, 12, 13, 21, 22, 23), bits(13, 14, 15, 23, 24, 25), bits(4, 5, 6, 12, 13, 14),
		bits(16, 17, 18, 27, 28, 29), bits(18, 19, 20, 29, 30, 31), bits(22, 23, 24, 33, 34, 35), bits(24, 25, 26, 35, 36, 37),
		bits(28, 29, 30, 38, 39, 40), bits(30, 31, 32, 40, 41, 42), bits(32, 33, 34, 42, 43, 44), bits(34, 35, 36, 44, 45, 46),
		bits(39, 40, 41, 47, 48, 49), bits(41, 42, 43, 49, 50, 51), bits(43, 44, 45, 51, 52, 53)

		
//		19, // count
//		bits(0, 1, 2, 8, 9, 10), bits(2, 3, 4, 10, 11, 12), bits(4, 5, 6, 12, 13, 14),
//		bits(7, 8, 9, 17, 18, 19), bits(9, 10, 11, 19, 20, 21), bits(11, 12, 13, 21, 22, 23), bits(13, 14, 15, 23, 24, 25),
//		bits(16, 17, 18, 27, 28, 29), bits(18, 19, 20, 29, 30, 31), bits(20, 21, 22, 31, 32, 33), bits(22, 23, 24, 33, 34, 35), bits(24, 25, 26, 35, 36, 37l),
//		bits(28, 29, 30, 38, 39, 40), bits(30, 31, 32, 40, 41, 42), bits(32, 33, 34, 42, 43, 44), bits(34, 35, 36, 44, 45, 46),
//		bits(39, 40, 41, 47, 48, 49), bits(41, 42, 43, 49, 50, 51), bits(43, 44, 45, 51, 52, 53)
	},
	{ // butterfly (not in my original set) - symmetric left to right and top to bottom
		42, // kButterfly count
		bits(1, 2, 3, 9, 10, 11), bits(3, 4, 5, 11, 12, 13),
		bits(8, 9, 10, 18, 19, 20), bits(10, 11, 12, 20, 21, 22), bits(12, 13, 14, 22, 23, 24),
		bits(17, 18, 19, 28, 29, 30), bits(19, 20, 21, 30, 31, 32), bits(21, 22, 23, 32, 33, 34), bits(23, 24, 25, 34, 35, 36),
		bits(29, 30, 31, 39, 40, 41), bits(31, 32, 33, 41, 42, 43), bits(33, 34, 35, 43, 44, 45),
		bits(40, 41, 42, 48, 49, 50), bits(42, 43, 44, 50, 51, 52),
		// rotated clockwise
		bits(6, 14, 15, 12, 13, 23), bits(15, 25, 26, 23, 24, 35),
		bits(4, 12, 13, 10, 11, 21), bits(13, 23, 24, 21, 22, 33), bits(24, 35, 36, 33, 34, 44),
		bits(2, 10, 11, 8, 9, 19), bits(11, 21, 22, 19, 20, 31), bits(22, 33, 34, 31, 32, 42), bits(34, 44, 45, 42, 43, 51),
		bits(9, 19, 20, 17, 18, 29), bits(20, 31, 32, 29, 30, 40), bits(32, 42, 43, 40, 41, 49),
		bits(18, 29, 30, 27, 28, 38), bits(30, 40, 41, 38, 39, 47),
		// rotated CCW
		bits(16, 17, 7, 29, 18, 19), bits(7, 8, 0, 19, 9, 10),
		bits(28, 29, 18, 40, 30, 31), bits(18, 19, 9, 31, 20, 21), bits(9, 10, 2, 21, 11, 12),
		bits(39, 40, 30, 49, 41, 42), bits(30, 31, 20, 42, 32, 33), bits(20, 21, 11, 33, 22, 23), bits(11, 12, 4, 23, 13, 14),
		bits(41, 42, 32, 51, 43, 44), bits(32, 33, 22, 44, 34, 35), bits(22, 23, 13, 35, 24, 25),
		bits(43, 44, 34, 53, 45, 46), bits(34, 35, 24, 46, 36, 37)
	},
	{ // elbow piece - note this has rotational symmetry with fliping the piece over
		// so it has 6 30 degree rotations possible
		12*6, // kElbow count
		bits(0, 1, 2, 3, 7, 8), bits(2, 3, 4, 5, 9, 10),
		bits(7, 8, 9, 10, 16, 17), bits(9, 10, 11, 12, 18, 19), bits(11, 12, 13, 14, 20, 21),
		bits(18, 19, 20, 21, 28, 29), bits(20, 21, 22, 23, 30, 31), bits(22, 23, 24, 25, 32, 33),
		bits(30, 31, 32, 33, 39, 40), bits(32, 33, 34, 35, 41, 42), bits(34, 35, 36, 37, 43, 44),
		bits(41, 42, 43, 44, 48, 49),
		// rotated 60
		bits(1, 2, 3, 4, 12, 13), bits(3, 4, 5, 6, 14, 15),
		bits(8, 9, 10, 11, 21, 22), bits(10, 11, 12, 13, 23, 24), bits(12, 13, 14, 15, 25, 26),
		bits(17, 18, 19, 20, 31, 32), bits(19, 20, 21, 22, 33, 34), bits(21, 22, 23, 24, 35, 36),
		bits(27, 28, 29, 30, 40, 41), bits(29, 30, 31, 32, 42, 43), bits(31, 32, 33, 34, 44, 45),
		bits(40, 41, 42, 43, 51, 52),
		// rotated 120 (elbow points right)
		bits(15, 25, 26, 37, 36, 46), bits(24, 35, 36, 46, 45, 53),
		bits(6, 14, 15, 25, 24, 35), bits(13, 23, 24, 35, 34, 44), bits(22, 33, 34, 44, 43, 51),
		bits(4, 12, 13, 23, 22, 33), bits(11, 21, 22, 33, 32, 42), bits(20, 31, 32, 42, 41, 49),
		bits(2, 10, 11, 21, 20, 31), bits(9, 19, 20, 31, 30, 40), bits(18, 29, 30, 40, 39, 47),
		bits(0, 8, 9, 19, 18, 29),
		// rotated 180 (elbow bottom right)
		bits(48, 49, 50, 51, 43, 44), bits(50, 51, 52, 53, 45, 46),
		bits(43, 44, 45, 46, 36, 37), bits(41, 42, 43, 44, 34, 35), bits(39, 40, 41, 42, 32, 33),
		bits(32, 33, 34, 35, 24, 25), bits(30, 31, 32, 33, 22, 23), bits(28, 29, 30, 31, 20, 21),
		bits(20, 21, 22, 23, 13, 14), bits(18, 19, 20, 21, 11, 12), bits(16, 17, 18, 19, 9, 10),
		bits(9, 10, 11, 12, 4, 5),
		// rotated 240 (elbow bottom left)
		bits(47, 48, 49, 50, 38, 39), bits(49, 50, 51, 52, 40, 41),
		bits(38, 39, 40, 41, 27, 28), bits(40, 41, 42, 43, 29, 30), bits(42, 43, 44, 45, 31, 32),
		bits(29, 30, 31, 32, 17, 18), bits(31, 32, 33, 34, 19, 20), bits(33, 34, 35, 36, 21, 22),
		bits(19, 20, 21, 22, 8, 9), bits(21, 22, 23, 24, 10, 11), bits(23, 24, 25, 26, 12, 13),
		bits(10, 11, 12, 13, 1, 2),
		// rotated 300 (elbow left)
		bits(7, 17, 16, 27, 28, 38), bits(0, 8, 7, 17, 18, 29),
		bits(18, 29, 28, 38, 39, 47), bits(9, 19, 18, 29, 30, 40), bits(2, 10, 9, 19, 20, 31),
		bits(20, 31, 30, 40, 41, 49), bits(11, 21, 20, 31, 32, 42), bits(4, 12, 11, 21, 22, 33),
		bits(22, 33, 32, 42, 43, 51), bits(13, 23, 22, 33, 34, 44), bits(6, 14, 13, 23, 24, 35),
		bits(24, 35, 34, 44, 45, 53)
	},
	{ // long parallelogram - symmetric left to right
		24*3, // kLine count
		// regular - flipped
		bits(0, 1, 2, 3, 4, 5),
		bits(7, 8, 9, 10, 11, 12), bits(9, 10, 11, 12, 13, 14),
		bits(16, 17, 18, 19, 20, 21), bits(18, 19, 20, 21, 22, 23), bits(20, 21, 22, 23, 24, 25),
		bits(28, 29, 30, 31, 32, 33), bits(30, 31, 32, 33, 34, 35), bits(32, 33, 34, 35, 36, 37),
		bits(39, 40, 41, 42, 43, 44), bits(41, 42, 43, 44, 45, 46),
		bits(48, 49, 50, 51, 52, 53),
		// one clockwise rotation, flipped
		bits(5, 6, 14, 15, 25, 26),
		bits(3, 4, 12, 13, 23, 24), bits(12, 13, 23, 24, 35, 36),
		bits(1, 2, 10, 11, 21, 22), bits(10, 11, 21, 22, 33, 34), bits(21, 22, 33, 34, 44, 45),
		bits(8, 9, 19, 20, 31, 32), bits(19, 20, 31, 32, 42, 43), bits(31, 32, 42, 43, 51, 52),
		bits(17, 18, 29, 30, 40, 41), bits(29, 30, 40, 41, 49, 50),
		bits(27, 28, 38, 39, 47, 48),
		// one CCW rotation, flipped
		bits(27, 16, 17, 7, 8, 0),
		bits(38, 28, 29, 18, 19, 9), bits(29, 18, 19, 9, 10, 2),
		bits(47, 39, 40, 30, 31, 20), bits(40, 30, 31, 20, 21, 11), bits(31, 20, 21, 11, 12, 4),
		bits(49, 41, 42, 32, 33, 22), bits(42, 32, 33, 22, 23, 13), bits(33, 22, 23, 13, 14, 6),
		bits(51, 43, 44, 34, 35, 24), bits(44, 34, 35, 24, 25, 15),
		bits(53, 45, 46, 36, 37, 26),
		// kLine initial
		bits(1, 2, 3, 4, 5, 6),
		bits(8, 9, 10, 11, 12, 13), bits(10, 11, 12, 13, 14, 15),
		bits(17, 18, 19, 20, 21, 22), bits(19, 20, 21, 22, 23, 24), bits(21, 22, 23, 24, 25, 26),
		bits(27, 28, 29, 30, 31, 32), bits(29, 30, 31, 32, 33, 34), bits(31, 32, 33, 34, 35, 36),
		bits(38, 39, 40, 41, 42, 43), bits(40, 41, 42, 43, 44, 45),
		bits(47, 48, 49, 50, 51, 52),
		// one clockwise rotation
		bits(6, 14, 15, 25, 26, 37),
		bits(4, 12, 13, 23, 24, 35), bits(13, 23, 24, 35, 36, 46),
		bits(2, 10, 11, 21, 22, 33), bits(11, 21, 22, 33, 34, 44), bits(22, 33, 34, 44, 45, 53),
		bits(0, 8, 9, 19, 20, 31), bits(9, 19, 20, 31, 32, 42), bits(20, 31, 32, 42, 43, 51),
		bits(7, 17, 18, 29, 30, 40), bits(18, 29, 30, 40, 41, 49),
		bits(16, 27, 28, 38, 39, 47),
		// one CCW rotation
		bits(16, 17, 7, 8, 0, 1),
		bits(28, 29, 18, 19, 9, 10), bits(18, 19, 9, 10, 2, 3),
		bits(39, 40, 30, 31, 20, 21), bits(30, 31, 20, 21, 11, 12), bits(20, 21, 11, 12, 4, 5),
		bits(48, 49, 41, 42, 32, 33), bits(41, 42, 32, 33, 22, 23), bits(32, 33, 22, 23, 13, 14),
		bits(50, 51, 43, 44, 34, 35), bits(43, 44, 34, 35, 24, 25),
		bits(52, 53, 45, 46, 36, 37),	},
	{ // two trapezoids on top of each other [kMountain] (note some are removed because they leave unfillable gaps
		52*3, // kMountains count
		// original
		bits(0, 1, 2, 7, 8, 9), bits(2, 3, 4, 9, 10, 11), bits(4, 5, 6, 11, 12, 13),
		bits(7, 8, 9, 16, 17, 18), bits(9, 10, 11, 18, 19, 20), bits(11, 12, 13, 20, 21, 22), bits(13, 14, 15, 22, 23, 24),
		bits(18, 19, 20, 28, 29, 30), bits(20, 21, 22, 30, 31, 32), bits(22, 23, 24, 32, 33, 34), //bits(24, 25, 26, 34, 35, 36),
		bits(30, 31, 32, 39, 40, 41), bits(32, 33, 34, 41, 42, 43), //bits(34, 35, 36, 43, 44, 45),
		bits(41, 42, 43, 48, 49, 50), //bits(43, 44, 45, 50, 51, 52),
		// original flipped both left/right and up/down
		/*bits(1, 2, 3, 8, 9, 10),*/ bits(3, 4, 5, 10, 11, 12),
		/*bits(8, 9, 10, 17, 18, 19),*/ bits(10, 11, 12, 19, 20, 21), bits(12, 13, 14, 21, 22, 23),
		/*bits(17, 18, 19, 27, 28, 29),*/ bits(19, 20, 21, 29, 30, 31), bits(21, 22, 23, 31, 32, 33), bits(23, 24, 25, 33, 34, 35),
		bits(29, 30, 31, 38, 39, 40), bits(31, 32, 33, 40, 41, 42), bits(33, 34, 35, 42, 43, 44), bits(35, 36, 37, 44, 45, 46),
		bits(40, 41, 42, 47, 48, 49), bits(42, 43, 44, 49, 50, 51), bits(44, 45, 46, 51, 52, 53),
		
		// original rotated CW - 52+
		bits(5, 6, 14, 3, 4, 12), bits(14, 15, 25, 12, 13, 23), bits(25, 26, 37, 23, 24, 35),
		bits(3, 4, 12, 1, 2, 10), bits(12, 13, 23, 10, 11, 21), bits(23, 24, 35, 21, 22, 33), bits(35, 36, 46, 33, 34, 44),
		bits(10, 11, 21, 8, 9, 19), bits(21, 22, 33, 19, 20, 31), bits(33, 34, 44, 31, 32, 42),
		bits(19, 20, 31, 17, 18, 29), bits(31, 32, 42, 29, 30, 40),
		bits(29, 30, 40, 27, 28, 38),
		// flipped top to bottom and left to right
		bits(15, 25, 26, 13, 23, 24),
		bits(13, 23, 24, 11, 21, 22), bits(24, 35, 36, 22, 33, 34),
		bits(11, 21, 22, 9, 19, 20), bits(22, 33, 34, 20, 31, 32), bits(34, 44, 45, 32, 42, 43),
		bits(9, 19, 20, 7, 17, 18), bits(20, 31, 32, 18, 29, 30), bits(32, 42, 43, 30, 40, 41), bits(43, 51, 52, 41, 49, 50),
		bits(18, 29, 30, 16, 27, 28), bits(30, 40, 41, 28, 38, 39), bits(41, 49, 50, 39, 47, 48),
		
		// original rotated CCW - 104+
		bits(27, 16, 17, 38, 28, 29), bits(17, 7, 8, 29, 18, 19), bits(8, 0, 1, 19, 9, 10),
		bits(38, 28, 29, 47, 39, 40), bits(29, 18, 19, 40, 30, 31), bits(19, 9, 10, 31, 20, 21), bits(10, 2, 3, 21, 11, 12),
		bits(40, 30, 31, 49, 41, 42), bits(31, 20, 21, 42, 32, 33), bits(21, 11, 12, 33, 22, 23),
		bits(42, 32, 33, 51, 43, 44), bits(33, 22, 23, 44, 34, 35),
		bits(44, 34, 35, 53, 45, 46),
		// flipped top to bottom and left to right (180 degree rotation)
		bits(7, 8, 0, 18, 19, 9),
		bits(18, 19, 9, 30, 31, 20), bits(9, 10, 2, 20, 21, 11),
		bits(30, 31, 20, 41, 42, 32), bits(20, 21, 11, 32, 33, 22), bits(11, 12, 4, 22, 23, 13),
		bits(41, 42, 32, 50, 51, 43), bits(32, 33, 22, 43, 44, 34), bits(22, 23, 13, 34, 35, 24), bits(13, 14, 6, 24, 25, 15),
		bits(43, 44, 34, 52, 53, 45), bits(34, 35, 24, 45, 46, 36), bits(24, 25, 15, 36, 37, 26),

		// original flipped top to bottom
		bits(1, 2, 3, 10, 11, 12), //bits(3, 4, 5, 12, 13, 14),
		bits(8, 9, 10, 19, 20, 21), bits(10, 11, 12, 21, 22, 23), //bits(12, 13, 14, 23, 24, 25),
		bits(17, 18, 19, 29, 30, 31), bits(19, 20, 21, 31, 32, 33), bits(21, 22, 23, 33, 34, 35), //bits(23, 24, 25, 35, 36, 37),
		bits(27, 28, 29, 38, 39, 40), bits(29, 30, 31, 40, 41, 42), bits(31, 32, 33, 42, 43, 44), bits(33, 34, 35, 44, 45, 46),
		bits(38, 39, 40, 47, 48, 49), bits(40, 41, 42, 49, 50, 51), bits(42, 43, 44, 51, 52, 53),
		// original flipped left to right
		bits(0, 1, 2, 9, 10, 11), bits(2, 3, 4, 11, 12, 13), bits(4, 5, 6, 13, 14, 15),
		bits(7, 8, 9, 18, 19, 20), bits(9, 10, 11, 20, 21, 22), bits(11, 12, 13, 22, 23, 24), bits(13, 14, 15, 24, 25, 26),
		/*16-18,28-30,*/ bits(18, 19, 20, 30, 31, 32), bits(20, 21, 22, 32, 33, 34), bits(22, 23, 24, 34, 35, 36),
		/*28-30,39-41,*/ bits(30, 31, 32, 41, 42, 43), bits(32, 33, 34, 43, 44, 45),
		/*39-41,48-50,*/ bits(41, 42, 43, 50, 51, 52),
		
		// original rotated CW flipped top to bottom
		bits(6, 14, 15, 13, 23, 24),
		bits(4, 12, 13, 11, 21, 22), bits(13, 23, 24, 22, 33, 34),
		bits(2, 10, 11, 9, 19, 20), bits(11, 21, 22, 20, 31, 32), bits(22, 33, 34, 32, 42, 43),
		bits(0, 8, 9, 7, 17, 18), bits(9, 19, 20, 18, 29, 30), bits(20, 31, 32, 30, 40, 41), bits(32, 42, 43, 41, 49, 50),
		bits(7, 17, 18, 16, 27, 28), bits(18, 29, 30, 28, 38, 39), bits(30, 40, 41, 39, 47, 48),
		// original rotated CW flipped left to right
		bits(5, 6, 14, 12, 13, 23), bits(14, 15, 25, 23, 24, 35), bits(25, 26, 37, 35, 36, 46),
		bits(3, 4, 12, 10, 11, 21), bits(12, 13, 23, 21, 22, 33), bits(23, 24, 35, 33, 34, 44), bits(35, 36, 46, 44, 45, 53),
		bits(10, 11, 21, 19, 20, 31), bits(21, 22, 33, 31, 32, 42), bits(33, 34, 44, 42, 43, 51),
		bits(19, 20, 31, 29, 30, 40), bits(31, 32, 42, 40, 41, 49),
		bits(29, 30, 40, 38, 39, 47),
		
		// original rotated CCW flipped top to bottom
		bits(16, 17, 7, 18, 19, 9),
		bits(28, 29, 18, 30, 31, 20), bits(18, 19, 9, 20, 21, 11),
		bits(39, 40, 30, 41, 42, 32), bits(30, 31, 20, 32, 33, 22), bits(20, 21, 11, 22, 23, 13),
		bits(48, 49, 41, 50, 51, 43), bits(41, 42, 32, 43, 44, 34), bits(32, 33, 22, 34, 35, 24), bits(22, 23, 13, 24, 25, 15),
		bits(50, 51, 43, 52, 53, 45), bits(43, 44, 34, 45, 46, 36), bits(34, 35, 24, 36, 37, 26),
		// original rotated CCW flipped left to right
		bits(27, 16, 17, 29, 18, 19), bits(17, 7, 8, 19, 9, 10), bits(8, 0, 1, 10, 2, 3),
		bits(38, 28, 29, 40, 30, 31), bits(29, 18, 19, 31, 20, 21), bits(19, 9, 10, 21, 11, 12), bits(10, 2, 3, 12, 4, 5),
		bits(40, 30, 31, 42, 32, 33), bits(31, 20, 21, 33, 22, 23), bits(21, 11, 12, 23, 13, 14),
		bits(42, 32, 33, 44, 34, 35), bits(33, 22, 23, 35, 24, 25),
		bits(44, 34, 35, 46, 36, 37),
	},
	{ // long piece a bit like the elbow but asymmetric
		13*6*2, // kWrench count
		// meaning there are 6 rotations x 2 after flipping
		// standard
		bits(0, 1, 2, 3, 4, 8), bits(2, 3, 4, 5, 6, 10),
		bits(7, 8, 9, 10, 11, 17), bits(9, 10, 11, 12, 13, 19), bits(11, 12, 13, 14, 15, 21),
		bits(16, 17, 18, 19, 20, 27), bits(18, 19, 20, 21, 22, 29), bits(20, 21, 22, 23, 24, 31), bits(22, 23, 24, 25, 26, 33),
		bits(28, 29, 30, 31, 32, 38), bits(30, 31, 32, 33, 34, 40), bits(32, 33, 34, 35, 36, 42),
		bits(39, 40, 41, 42, 43, 47),
		// rotated 60
		bits(4, 5, 6, 14, 15, 25), bits(13, 14, 15, 25, 26, 37),
		bits(2, 3, 4, 12, 13, 23), bits(11, 12, 13, 23, 24, 35), bits(22, 23, 24, 35, 36, 46),
		bits(0, 1, 2, 10, 11, 21), bits(9, 10, 11, 21, 22, 33), bits(20, 21, 22, 33, 34, 44), bits(32, 33, 34, 44, 45, 53),
		bits(7, 8, 9, 19, 20, 31), bits(18, 19, 20, 31, 32, 42), bits(30, 31, 32, 42, 43, 51),
		bits(16, 17, 18, 29, 30, 40),
		// rotated 120
		bits(25, 26, 36, 37, 45, 46), bits(35, 36, 45, 46, 52, 53),
		bits(14, 15, 24, 25, 34, 35), bits(23, 24, 34, 35, 43, 44), bits(33, 34, 43, 44, 50, 51),
		bits(5, 6, 13, 14, 22, 23), bits(12, 13, 22, 23, 32, 33), bits(21, 22, 32, 33, 41, 42), bits(31, 32, 41, 42, 48, 49),
		bits(3, 4, 11, 12, 20, 21), bits(10, 11, 20, 21, 30, 31), bits(19, 20, 30, 31, 39, 40),
		bits(1, 2, 9, 10, 18, 19),
		// rotated 180
		bits(47, 48, 49, 50, 51, 43), bits(49, 50, 51, 52, 53, 45),
		bits(38, 39, 40, 41, 42, 32), bits(40, 41, 42, 43, 44, 34), bits(42, 43, 44, 45, 46, 36),
		bits(27, 28, 29, 30, 31, 20), bits(29, 30, 31, 32, 33, 22), bits(31, 32, 33, 34, 35, 24), bits(33, 34, 35, 36, 37, 26),
		bits(17, 18, 19, 20, 21, 11), bits(19, 20, 21, 22, 23, 13), bits(21, 22, 23, 24, 25, 15),
		bits(10, 11, 12, 13, 14, 6),
		// rotated 240
		bits(28, 38, 39, 47, 48, 49), bits(16, 27, 28, 38, 39, 40),
		bits(30, 40, 41, 49, 50, 51), bits(18, 29, 30, 40, 41, 42), bits(7, 17, 18, 29, 30, 31),
		bits(32, 42, 43, 51, 52, 53), bits(20, 31, 32, 42, 43, 44), bits(9, 19, 20, 31, 32, 33), bits(0, 8, 9, 19, 20, 21),
		bits(22, 33, 34, 44, 45, 46), bits(11, 21, 22, 33, 34, 35), bits(2, 10, 11, 21, 22, 23),
		bits(13, 23, 24, 35, 36, 37),
		// rotated 300
		bits(0, 1, 7, 8, 17, 18), bits(7, 8, 16, 17, 27, 28),
		bits(2, 3, 9, 10, 19, 20), bits(9, 10, 18, 19, 29, 30), bits(18, 19, 28, 29, 38, 39),
		bits(4, 5, 11, 12, 21, 22), bits(11, 12, 20, 21, 31, 32), bits(20, 21, 30, 31, 40, 41), bits(30, 31, 39, 40, 47, 48),
		bits(13, 14, 22, 23, 33, 34), bits(22, 23, 32, 33, 42, 43), bits(32, 33, 41, 42, 49, 50),
		bits(34, 35, 43, 44, 51, 52),
		// standard - flipped
		bits(0, 1, 2, 3, 4, 12), bits(2, 3, 4, 5, 6, 14),
		bits(7, 8, 9, 10, 11, 21), bits(9, 10, 11, 12, 13, 23), bits(11, 12, 13, 14, 15, 25),
		bits(16, 17, 18, 19, 20, 31), bits(18, 19, 20, 21, 22, 33), bits(20, 21, 22, 23, 24, 35), bits(22, 23, 24, 25, 26, 37),
		bits(28, 29, 30, 31, 32, 42), bits(30, 31, 32, 33, 34, 44), bits(32, 33, 34, 35, 36, 46),
		bits(41, 42, 43, 44, 45, 53),
		// rotated 60 - flipped
		bits(24, 5, 6, 14, 15, 25), bits(36, 14, 15, 25, 26, 37),
		bits(22, 3, 4, 12, 13, 23), bits(34, 12, 13, 23, 24, 35), bits(45, 23, 24, 35, 36, 46),
		bits(20, 1, 2, 10, 11, 21), bits(32, 10, 11, 21, 22, 33), bits(43, 21, 22, 33, 34, 44), bits(52, 33, 34, 44, 45, 53),
		bits(30, 8, 9, 19, 20, 31), bits(41, 19, 20, 31, 32, 42), bits(50, 31, 32, 42, 43, 51),
		bits(48, 29, 30, 40, 41, 49),
		// rotated 120 - flipped
		bits(44, 26, 36, 37, 45, 46), bits(51, 36, 45, 46, 52, 53),
		bits(33, 15, 24, 25, 34, 35), bits(42, 24, 34, 35, 43, 44), bits(49, 34, 43, 44, 50, 51),
		bits(21, 6, 13, 14, 22, 23), bits(31, 13, 22, 23, 32, 33), bits(40, 22, 32, 33, 41, 42), bits(47, 32, 41, 42, 48, 49),
		bits(19, 4, 11, 12, 20, 21), bits(29, 11, 20, 21, 30, 31), bits(38, 20, 30, 31, 39, 40),
		bits(27, 9, 19, 18, 28, 29),
		// rotated 180 - flipped
		bits(47, 48, 49, 50, 51, 39), bits(49, 50, 51, 52, 53, 41),
		bits(38, 39, 40, 41, 42, 28), bits(40, 41, 42, 43, 44, 30), bits(42, 43, 44, 45, 46, 32),
		bits(27, 28, 29, 30, 31, 16), bits(29, 30, 31, 32, 33, 18), bits(31, 32, 33, 34, 35, 20), bits(33, 34, 35, 36, 37, 22),
		bits(17, 18, 19, 20, 21, 7), bits(19, 20, 21, 22, 23, 9), bits(21, 22, 23, 24, 25, 11),
		bits(8, 9, 10, 11, 12, 0),
		// rotated 240 - flipped
		bits(28, 38, 39, 47, 48, 29), bits(16, 27, 28, 38, 39, 17),
		bits(30, 40, 41, 49, 50, 31), bits(18, 29, 30, 40, 41, 19), bits(7, 17, 18, 29, 30, 8),
		bits(32, 42, 43, 51, 52, 33), bits(20, 31, 32, 42, 43, 21), bits(9, 19, 20, 31, 32, 10), bits(0, 8, 9, 19, 20, 1),
		bits(22, 33, 34, 44, 45, 23), bits(11, 21, 22, 33, 34, 12), bits(2, 10, 11, 21, 22, 3),
		bits(4, 12, 13, 23, 24, 5),
		// rotated 300 - flipped
		bits(0, 1, 7, 8, 17, 2), bits(7, 8, 16, 17, 27, 9),
		bits(2, 3, 9, 10, 19, 4), bits(9, 10, 18, 19, 29, 11), bits(18, 19, 28, 29, 38, 20),
		bits(4, 5, 11, 12, 21, 6), bits(11, 12, 20, 21, 31, 13), bits(20, 21, 30, 31, 40, 22), bits(30, 31, 39, 40, 47, 32),
		bits(13, 14, 22, 23, 33, 15), bits(22, 23, 32, 33, 42, 24), bits(32, 33, 41, 42, 49, 34),
		bits(24, 25, 34, 35, 44, 26),
	},
	{ // triangle piece
		12*6*2, // kTriangle count
		// regular
		bits(1, 2, 3, 4, 5, 10),
		bits(8, 9, 10, 11, 12, 19), bits(10, 11, 12, 13, 14, 21),
		bits(17, 18, 19, 20, 21, 29), bits(19, 20, 21, 22, 23, 31), bits(21, 22, 23, 24, 25, 33),
		bits(27, 28, 29, 30, 31, 38), bits(29, 30, 31, 32, 33, 40), bits(31, 32, 33, 34, 35, 42), bits(33, 34, 35, 36, 37, 44),
		bits(38, 39, 40, 41, 42, 47), bits(40, 41, 42, 43, 44, 49),
		// rotated 60
		bits(6, 13, 14, 15, 25, 26),
		bits(4, 11, 12, 13, 23, 24), bits(13, 22, 23, 24, 35, 36),
		bits(2, 9, 10, 11, 21, 22), bits(11, 20, 21, 22, 33, 34), bits(22, 32, 33, 34, 44, 45),
		bits(0, 7, 8, 9, 19, 20), bits(9, 18, 19, 20, 31, 32), bits(20, 30, 31, 32, 42, 43), bits(32, 41, 42, 43, 51, 52),
		bits(7, 16, 17, 18, 29, 30), bits(18, 28, 29, 30, 40, 41),
		// rotated 120
		bits(35, 36, 37, 45, 46, 53),
		bits(23, 24, 25, 34, 35, 44), bits(33, 34, 35, 43, 44, 51),
		bits(12, 13, 14, 22, 23, 33), bits(21, 22, 23, 32, 33, 42), bits(31, 32, 33, 41, 42, 49),
		bits(3, 4, 5, 11, 12, 21), bits(10, 11, 12, 20, 21, 31), bits(19, 20, 21, 30, 31, 40), bits(29, 30, 31, 39, 40, 47),
		bits(1, 2, 3, 9, 10, 19), bits(8, 9, 10, 18, 19, 29),
		// rotated 180
		bits(48, 49, 50, 51, 52, 43),
		bits(41, 42, 43, 44, 45, 34), bits(39, 40, 41, 42, 43, 32),
		bits(32, 33, 34, 35, 36, 24), bits(30, 31, 32, 33, 34, 22), bits(28, 29, 30, 31, 32, 20),
		bits(22, 23, 24, 25, 26, 15), bits(20, 21, 22, 23, 24, 13), bits(18, 19, 20, 21, 22, 11), bits(16, 17, 18, 19, 20, 9),
		bits(6, 11, 12, 13, 14, 15), bits(9, 10, 11, 12, 13, 4),
		// rotated 240
		bits(27, 28, 38, 39, 40, 47),
		bits(29, 30, 40, 41, 42, 49), bits(17, 18, 29, 30, 31, 40),
		bits(31, 32, 42, 43, 44, 51), bits(19, 20, 31, 32, 33, 42), bits(8, 9, 19, 20, 21, 31),
		bits(33, 34, 44, 45, 46, 53), bits(21, 22, 33, 34, 35, 44), bits(10, 11, 21, 22, 23, 33), bits(1, 2, 10, 11, 12, 21),
		bits(23, 24, 35, 36, 37, 46), bits(12, 13, 23, 24, 25, 35),
		// rotated 300
		bits(0, 7, 8, 16, 17, 18),
		bits(9, 18, 19, 28, 29, 30), bits(2, 9, 10, 18, 19, 20),
		bits(20, 30, 31, 39, 40, 41), bits(11, 20, 21, 30, 31, 32), bits(4, 11, 12, 20, 21, 22),
		bits(32, 41, 42, 48, 49, 50), bits(22, 32, 33, 41, 42, 43), bits(13, 22, 23, 32, 33, 34), bits(6, 13, 14, 22, 23, 24),
		bits(34, 43, 44, 50, 51, 52), bits(24, 34, 35, 43, 44, 45),
		// flipped
		bits(0, 7, 8, 9, 10, 11), bits(2, 9, 10, 11, 12, 13),
		bits(7, 16, 17, 18, 19, 20), bits(9, 18, 19, 20, 21, 22), bits(11, 20, 21, 22, 23, 24), bits(13, 22, 23, 24, 25, 26),
		bits(18, 28, 29, 30, 31, 32), bits(20, 30, 31, 32, 33, 34), bits(22, 32, 33, 34, 35, 36),
		bits(30, 39, 40, 41, 42, 43), bits(32, 41, 42, 43, 44, 45),
		bits(41, 48, 49, 50, 51, 52),
		// rotated 60 - flipped
		bits(3, 4, 5, 12, 13, 23), bits(12, 13, 14, 23, 24, 35),
		bits(1, 2, 3, 10, 11, 21), bits(10, 11, 12, 21, 22, 33), bits(21, 22, 23, 33, 34, 44), bits(33, 34, 35, 44, 45, 53),
		bits(8, 9, 10, 19, 20, 31), bits(19, 20, 21, 31, 32, 42), bits(31, 32, 33, 42, 43, 51),
		bits(17, 18, 19, 29, 30, 40), bits(29, 30, 31, 40, 41, 49),
		bits(27, 28, 29, 38, 39, 47),
		// rotated 120 - flipped
		bits(15, 24, 25, 26, 34, 35), bits(24, 34, 35, 36, 43, 44),
		bits(6, 13, 14, 15, 22, 23), bits(13, 22, 23, 24, 32, 33), bits(22, 32, 33, 34, 41, 42), bits(32, 41, 42, 43, 48, 49),
		bits(4, 11, 12, 13, 20, 21), bits(11, 20, 21, 22, 30, 31), bits(20, 30, 31, 32, 39, 40),
		bits(2, 9, 10, 11, 18, 19), bits(9, 18, 19, 20, 28, 29),
		bits(0, 7, 8, 9, 16, 17),
		// rotated 180 - flipped
		bits(42, 43, 44, 45, 46, 53), bits(40, 41, 42, 43, 44, 51),
		bits(33, 34, 35, 36, 37, 46), bits(31, 32, 33, 34, 35, 44), bits(29, 30, 31, 32, 33, 42), bits(27, 28, 29, 30, 31, 40),
		bits(21, 22, 23, 24, 25, 35), bits(19, 20, 21, 22, 23, 33), bits(17, 18, 19, 20, 21, 31),
		bits(10, 11, 12, 13, 14, 23), bits(8, 9, 10, 11, 12, 21),
		bits(1, 2, 3, 4, 5, 12),
		// rotated 240 - flipped
		bits(30, 40, 41, 48, 49, 50), bits(18, 29, 30, 39, 40, 41),
		bits(32, 42, 43, 50, 51, 52), bits(20, 31, 32, 41, 42, 43), bits(9, 19, 20, 30, 31, 32), bits(0, 8, 9, 18, 19, 20),
		bits(22, 33, 34, 43, 44, 45), bits(11, 21, 22, 32, 33, 34), bits(2, 10, 11, 20, 21, 22),
		bits(13, 23, 24, 34, 35, 36), bits(4, 12, 13, 22, 23, 24),
		bits(6, 14, 15, 24, 25, 26),
		// rotated 300 - flipped
		bits(18, 19, 27, 28, 29, 38), bits(9, 10, 17, 18, 19, 29),
		bits(30, 31, 38, 39, 40, 47), bits(20, 21, 29, 30, 31, 40), bits(11, 12, 19, 20, 21, 31), bits(4, 5, 10, 11, 12, 21),
		bits(32, 33, 40, 41, 42, 49), bits(22, 23, 31, 32, 33, 42), bits(13, 14, 21, 22, 23, 33),
		bits(34, 35, 42, 43, 44, 51), bits(24, 25, 33, 34, 35, 44),
		bits(36, 37, 44, 45, 46, 53),
	},
	{
		14*6*2, // kHook count

		// V-like piece-flip
		bits(0, 1, 8, 9, 10, 11), bits(2, 3, 10, 11, 12, 13),
		bits(7, 8, 17, 18, 19, 20), bits(9, 10, 19, 20, 21, 22), bits(11, 12, 21, 22, 23, 24),
		bits(16, 17, 27, 28, 29, 30), bits(18, 19, 29, 30, 31, 32), bits(20, 21, 31, 32, 33, 34), bits(22, 23, 33, 34, 35, 36),
		bits(28, 29, 38, 39, 40, 41), bits(30, 31, 40, 41, 42, 43), bits(32, 33, 42, 43, 44, 45),
		bits(39, 40, 47, 48, 49, 50), bits(41, 42, 49, 50, 51, 52),
		// 60-degrees-flip
		bits(4, 5, 6, 12, 13, 23), bits(13, 14, 15, 23, 24, 35),
		bits(2, 3, 4, 10, 11, 21), bits(11, 12, 13, 21, 22, 33), bits(22, 23, 24, 33, 34, 44),
		bits(0, 1, 2, 8, 9, 19), bits(9, 10, 11, 19, 20, 31), bits(20, 21, 22, 31, 32, 42), bits(32, 33, 34, 42, 43, 51),
		bits(7, 8, 9, 17, 18, 29), bits(18, 19, 20, 29, 30, 40), bits(30, 31, 32, 40, 41, 49),
		bits(16, 17, 18, 27, 28, 38), bits(28, 29, 30, 38, 39, 47),
		// 120-degree-flip
		bits(24, 25, 26, 34, 35, 37), bits(13, 14, 15, 22, 23, 25), bits(4, 5, 6, 11, 12, 14),
		bits(34, 35, 36, 43, 44, 46), bits(22, 23, 24, 32, 33, 35), bits(11, 12, 13, 20, 21, 23), bits(2, 3, 4, 9, 10, 12),
		bits(32, 33, 34, 41, 42, 44), bits(20, 21, 22, 30, 31, 33), bits(9, 10, 11, 18, 19, 21), bits(0, 1, 2, 7, 8, 10),
		bits(30, 31, 32, 39, 40, 42), bits(18, 19, 20, 28, 29, 31), bits(7, 8, 9, 16, 17, 19),
		// 180-degree-flip
		bits(42, 43, 44, 45, 52, 53), bits(40, 41, 42, 43, 50, 51),
		bits(33, 34, 35, 36, 45, 46), bits(31, 32, 33, 34, 43, 44), bits(29, 30, 31, 32, 41, 42),
		bits(23, 24, 25, 26, 36, 37), bits(21, 22, 23, 24, 34, 35), bits(19, 20, 21, 22, 32, 33), bits(17, 18, 19, 20, 30, 31),
		bits(12, 13, 14, 15, 24, 25), bits(10, 11, 12, 13, 22, 23), bits(8, 9, 10, 11, 20, 21),
		bits(3, 4, 5, 6, 13, 14), bits(1, 2, 3, 4,11, 12),
		// 240-degree-flip
		bits(30, 40, 41, 47, 48, 49), bits(32, 42, 43, 49, 50, 51), bits(34, 44, 45, 51, 52, 53),
		bits(18, 29, 30, 38, 39, 40), bits(20, 31, 32, 40, 41, 42), bits(22, 33, 34, 42, 43, 44), bits(24, 35, 36, 44, 45, 46),
		bits(9, 19, 20, 29, 30, 31), bits(11, 21, 22, 31, 32, 33), bits(13, 23, 24, 33, 34, 35), bits(15, 25, 26, 35, 36, 37),
		bits(2, 10, 11, 19, 20, 21), bits(4, 12, 13, 21, 22, 23), bits(6, 14, 15, 23, 24, 25),
		// 300-degree-flip
		bits(16, 18, 19, 27, 28, 29), bits(7, 9, 10, 17, 18, 19),
		bits(28, 30, 31, 38, 39, 40), bits(18, 20, 21, 29, 30, 31), bits(9, 11, 12, 19, 20, 21),
		bits(39, 41, 42, 47, 48, 49), bits(30, 32, 33, 40, 41, 42), bits(20, 22, 23, 31, 32, 33), bits(11, 13, 14, 21, 22, 23),
		bits(41, 43, 44, 49, 50, 51), bits(32, 34, 35, 42, 43, 44), bits(22, 24, 25, 33, 34, 35),
		bits(43, 45, 46, 51, 52, 53), bits(34, 36, 37, 44, 45, 46),
		// hook / V-like piece
		bits(0, 1, 2, 3, 8, 9), bits(2, 3, 4, 5, 10, 11),
		bits(7, 8, 9, 10, 17, 18), bits(9, 10, 11, 12, 19, 20), bits(11, 12, 13, 14, 21, 22),
		bits(16, 17, 18, 19, 27, 28), bits(18, 19, 20, 21, 29, 30), bits(20, 21, 22, 23, 31, 32), bits(22, 23, 24, 25, 33, 34),
		bits(28, 29, 30, 31, 38, 39), bits(30, 31, 32, 33, 40, 41), bits(32, 33, 34, 35, 42, 43),
		bits(39, 40, 41, 42, 47, 48), bits(41, 42, 43, 44, 49, 50),
		// 60-degrees
		bits(4, 5, 6, 12, 14, 15), bits(13, 14, 15, 23, 25, 26),
		bits(2, 3, 4, 10, 12, 13), bits(11, 12, 13, 21, 23, 24), bits(22, 23, 24, 33, 35, 36),
		bits(0, 1, 2, 8, 10, 11), bits(9, 10, 11, 19, 21, 22), bits(20, 21, 22, 31, 33, 34), bits(32, 33, 34, 42, 44, 45),
		bits(7, 8, 9, 17, 19, 20), bits(18, 19, 20, 29, 31, 32), bits(30, 31, 32, 40, 42, 43),
		bits(16, 17, 18, 27, 29, 30), bits(28, 29, 30, 38, 40, 41),
		// 120-degree
		bits(24, 25, 26, 36, 37, 46), bits(13, 14, 15, 24, 25, 35), bits(4, 5, 6, 13, 14, 23),
		bits(34, 35, 36, 45, 46, 53), bits(22, 23, 24, 34, 35, 44), bits(11, 12, 13, 22, 23, 33), bits(2, 3, 4, 11, 12, 21),
		bits(32, 33, 34, 43, 44, 51), bits(20, 21, 22, 32, 33, 42), bits(9, 10, 11, 20, 21, 31), bits(0, 1, 2, 9, 10, 19),
		bits(30, 31, 32, 41, 42, 49), bits(18, 19, 20, 30, 31, 40), bits(7, 8, 9, 18, 19, 29),
		// 180-degree
		bits(44, 45, 50, 51, 52, 53), bits(42, 43, 48, 49, 50, 51),
		bits(35, 36, 43, 44, 45, 46), bits(33, 34, 41, 42, 43, 44), bits(31, 32, 39, 40, 41, 42),
		bits(25, 26, 34, 35, 36, 37), bits(23, 24, 32, 33, 34, 35), bits(21, 22, 30, 31, 32, 33), bits(19, 20, 28, 29, 30, 31),
		bits(14, 15, 22, 23, 24, 25), bits(12, 13, 20, 21, 22, 23), bits(10, 11, 18, 19, 20, 21),
		bits(5, 6, 11, 12, 13, 14), bits(3, 4, 9, 10, 11, 12),
		// 240-degree
		bits(38, 39, 41, 47, 48, 49), bits(40, 41, 43, 49, 50, 51), bits(42, 43, 45, 51, 52, 53),
		bits(27, 28, 30, 38, 39, 40), bits(29, 30, 32, 40, 41, 42), bits(31, 32, 34, 42, 43, 44), bits(33, 34, 36, 44, 45, 46),
		bits(17, 18, 20, 29, 30, 31), bits(19, 20, 22, 31, 32, 33), bits(21, 22, 24, 33, 34, 35), bits(23, 24, 26, 35, 36, 37),
		bits(8, 9, 11, 19, 20, 21), bits(10, 11, 13, 21, 22, 23), bits(12, 13, 15, 23, 24, 25),
		// 300-degree
		bits(7, 16, 17, 27, 28, 29), bits(0, 7, 8, 17, 18, 19),
		bits(18, 28, 29, 38, 39, 40), bits(9, 18, 19, 29, 30, 31), bits(2, 9, 10, 19, 20, 21),
		bits(30, 39, 40, 47, 48, 49), bits(20, 30, 31, 40, 41, 42), bits(11, 20, 21, 31, 32, 33), bits(4, 11, 12, 21, 22, 23),
		bits(32, 41, 42, 49, 50, 51), bits(22, 32, 33, 42, 43, 44), bits(13, 22, 23, 33, 34, 35),
		bits(34, 43, 44, 51, 52, 53), bits(24, 34, 35, 44, 45, 46),
	},
	{ // small trapezoids -- symmetric left/right
		126, // kTrapezoid count
		// upright pieces
		bits(0, 1, 2), bits(2, 3, 4), bits(4, 5, 6),
		bits(7, 8, 9), bits(9, 10, 11), bits(11, 12, 13), bits(13, 14, 15),
		bits(16, 17, 18), bits(18, 19, 20), bits(20, 21, 22), bits(22, 23, 24), bits(24, 25, 26),
		bits(28, 29, 30), bits(30, 31, 32), bits(32, 33, 34), bits(34, 35, 36),
		bits(39, 40, 41), bits(41, 42, 43), bits(43, 44, 45),
		bits(48, 49, 50), bits(50, 51, 52),
		// downward pieces
		bits(1, 2, 3), bits(3, 4, 5),
		bits(8, 9, 10), bits (10, 11, 12), bits(12, 13, 14),
		bits(17, 18, 19), bits(19, 20, 21), bits(21, 22, 23), bits(23, 24, 25),
		bits(27, 28, 29), bits(29, 30, 31), bits(31, 32, 33), bits(33, 34, 35), bits(35, 36, 37),
		bits(38, 39, 40), bits(40, 41, 42), bits(42, 43, 44), bits(44, 45, 46),
		bits(47, 48, 49), bits(49, 50, 51), bits(51, 52, 53),
		// one clockwise rotation
		bits(5, 6, 14), bits(14, 15, 25), bits(25, 26, 37),
		bits(3, 4, 12), bits(12, 13, 23), bits(23, 24, 35), bits(35, 36, 46),
		bits(1, 2, 10), bits(10, 11, 21), bits(21, 22, 33), bits(33, 34, 44), bits(44, 45, 53),
		bits(8, 9, 19), bits(19, 20, 31), bits(31, 32, 42), bits(42, 43, 51),
		bits(17, 18, 29), bits(29, 30, 40), bits(40, 41, 49),
		bits(27, 28, 38), bits(38, 39, 47),
		// one clockwise rotation downward
		bits(6, 14, 15), bits(15, 25, 26),
		bits(4, 12, 13), bits(13, 23, 24), bits(24, 35, 36),
		bits(2, 10, 11), bits(11, 21, 22), bits(22, 33, 34), bits(34, 44, 45),
		bits(0, 8, 9), bits(9, 19, 20), bits(20, 31, 32), bits(32, 42, 43), bits(43, 51, 52),
		bits(7, 17, 18), bits(18, 29, 30), bits(30, 40, 41), bits(41, 49, 50),
		bits(16, 27, 28), bits(28, 38, 39), bits(39, 47, 48),
		// two clockwise rotations
		bits(27, 16, 17), bits(17, 7, 8), bits(8, 0, 1),
		bits(38, 28, 29), bits(29, 18, 19), bits(19, 9, 10), bits(10, 2, 3),
		bits(47, 39, 40), bits(40, 30, 31), bits(31, 20, 21), bits(21, 11, 12), bits(12, 4, 5),
		bits(49, 41, 42), bits(42, 32, 33), bits(33, 22, 23), bits(23, 13, 14),
		bits(51, 43, 44), bits(44, 34, 35), bits(35, 24, 25),
		bits(53, 45, 46), bits(46, 36, 37),
		// two clockwise rotations downward
		bits(16, 17, 7), bits(7, 8, 0),
		bits(28, 29, 18), bits(18, 19, 9), bits(9, 10, 2),
		bits(39, 40, 30), bits(30, 31, 20), bits(20, 21, 11), bits(11, 12, 4),
		bits(48, 49, 41), bits(41, 42, 32), bits(32, 33, 22), bits(22, 23, 13), bits(13, 14, 6),
		bits(50, 51, 43), bits(43, 44, 34), bits(34, 35, 24), bits(24, 25, 15),
		bits(52, 53, 45), bits(45, 46, 36), bits(36, 37, 26)
	},
	{ // funny last piece
		12*3*2, // kSnake count (72)
		bits(0, 1, 2, 10, 11, 12),
		bits(7, 8, 9, 19, 20, 21), bits(9, 10, 11, 21, 22, 23), bits(11, 12, 13, 23, 24, 25),
		bits(16, 17, 18, 29, 30, 31), bits(18, 19, 20, 31, 32, 33), bits(20, 21, 22, 33, 34, 35), bits(22, 23, 24, 35, 36, 37),
		bits(28, 29, 30, 40, 41, 42), bits(30, 31, 32, 42, 43, 44), bits(32, 33, 34, 44, 45, 46),
		bits(41, 42, 43, 51, 52, 53),
		// rotated 60 degrees
		bits(5, 6, 13, 14, 23, 24),
		bits(3, 4, 11, 12, 21, 22), bits(12, 13, 22, 23, 33, 34), bits(23, 24, 34, 35, 44, 45),
		bits(1, 2, 9, 10, 19, 20), bits(10, 11, 20, 21, 31, 32), bits(21, 22, 32, 33, 42, 43), bits(33, 34, 43, 44, 51, 52),
		bits(8, 9, 18, 19, 29, 30), bits(19, 20, 30, 31, 40, 41), bits(31, 32, 41, 42, 49, 50),
		bits(29, 30, 39, 40, 47, 48),
		// rotated 120 degress
		bits(26, 34, 35, 36, 37, 44),
		bits(15, 22, 23, 24, 25, 33), bits(24, 32, 33, 34, 35, 42), bits(34, 41, 42, 43, 44, 49),
		bits(6, 11, 12, 13, 14, 21), bits(13, 20, 21, 22, 23, 31), bits(22, 30, 31, 32, 33, 40), bits(32, 39, 40, 41, 42, 47),
		bits(4, 9, 10, 11, 12, 19), bits(11, 18, 19, 20, 21, 29), bits(20, 28, 29, 30, 31, 38),
		bits(9, 16, 17, 18, 19, 27),
		// flipped
		bits(4, 5, 6, 10, 11, 12), bits(9, 10, 11, 17, 18, 19), bits(11, 12, 13, 19, 20, 21), bits(13, 14, 15, 21, 22, 23),
		bits(18, 19, 20, 27, 28, 29), bits(20, 21, 22, 29, 30, 31), bits(22, 23, 24, 31, 32, 33), bits(24, 25, 26, 33, 34, 35),
		bits(30, 31, 32, 38, 39, 40), bits(32, 33, 34, 40, 41, 42), bits(34, 35, 36, 42, 43, 44),
		bits(41, 42, 43, 47, 48, 49),
		// rotated 60 degrees - flipped
		bits(13, 23, 24, 25, 26, 37),
		bits(2, 10, 11, 12, 13, 23), bits(11, 21, 22, 23, 24, 35), bits(22, 33, 34, 35, 36, 46),
		bits(0, 8, 9, 10, 11, 21), bits(9, 19, 20, 21, 22, 33), bits(20, 31, 32, 33, 34, 44), bits(32, 42, 43, 44, 45, 53),
		bits(7, 17, 18, 19, 20, 31), bits(18, 29, 30, 31, 32, 42), bits(30, 40, 41, 42, 43, 51),
		bits(16, 27, 28, 29, 30, 40),
		// rotated 120 degress - flipped
		bits(34, 35, 44, 45, 52, 53),
		bits(13, 14, 23, 24, 34, 35), bits(22, 23, 33, 34, 43, 44), bits(32, 33, 42, 43, 50, 51),
		bits(4, 5, 12, 13, 22, 23), bits(11, 12, 21, 22, 32, 33), bits(20, 21, 31, 32, 41, 42), bits(30, 31, 40, 41, 48, 49),
		bits(2, 3, 10, 11, 20, 21), bits(9, 10, 19, 20, 30, 31), bits(18, 19, 29, 30, 39, 40),
		bits(0, 1, 8, 9, 18, 19)
	}
};

HexagonEnvironment::HexagonEnvironment()
{
	pieces = {kHexagon, kElbow, kSnake, kMountains, kWrench, kTriangle, kHook, kTrapezoid, kTrapezoid, kButterfly};
	flippable = {kCanFlip, kCanFlip, kSide1, kSide1, kSide1, kCanFlip, kCanFlip, kCanFlip, kCanFlip, kCanFlip};
    BuildLocationTable();
    cout << "-< Built location table >-\n\n";
    BuildHolesTable();
    cout << "-< Built holes table >-\n\n";
	BuildFlipTable();
    cout << "-< Built flip table >-\n\n";
	BuildRotationTable();
    cout << "-< Built Rotation table >-\n\n";
}

void HexagonEnvironment::SetPieces(const vector<tPieceName> &pieces)
{
	this->pieces.resize(0);
	for (int x = 0; x < pieces.size(); x++)
		this->pieces.push_back((int)pieces[x]);
    
//    cout << "pieces: " << this->pieces.size() << "\n";
}

vector<int> HexagonEnvironment::GetPieces(){
    return this->pieces;
}

void HexagonEnvironment::SetFlippable(const array<tFlipType, numPieces> &flips)
{
	flippable = flips;
}


HexagonEnvironment::~HexagonEnvironment()
{
	
}

void HexagonEnvironment::BuildRotationTable()
{
	uint64_t one = 1;
	//	int rotate30Map[12][14*6*2+1];
	// for all pieces
	for (int x = 0; x < numPieces; x++)
	{
		int total = locations[x][0];
		if (total == 4) total = 19;
		
		// and all locations/rotations
		for (int y = 1; y <= total; y++)
		{
			// rotate the piece from the given location
			uint64_t loc = locations[x][y];
			uint64_t rot_loc = 0;
			for (int x = 0; x < 64; x++) // simple and dumb
			{
				if ((loc>>x)&1)
				{
					rot_loc |= (one<<rotateCWTable[x]);
				}
			}
			// find match to rotation
			bool success = false;
			for (int z = 1; z <= total; z++)
			{
				if (locations[x][z] == rot_loc)
				{
//                    if(rotate30Map[x][y] == 180 && z == 20)
//                        cout << "zoom " << x << " " << y << " " << z  << "\n";

					rotate30Map[x][y] = z;
					success = true;
                    
//                    if(x == 4 && y == 173)
//                    {
//                        cout << y << " | " << z;
//                    }
                    
//                    cout << "map " << rotate30Map[4][173]  << "\n";

					break;
				}
			}
			assert(success == true);
		}
	}
}

void HexagonEnvironment::BuildFlipTable()
{
	uint64_t one = 1;
	//	int flipMap[12][14*6*2+1];
	// for all pieces
	for (int x = 0; x < numPieces; x++)
	{
		int total = locations[x][0];
		if (total == 4) total = 19;

		// and all locations/rotations
		for (int y = 1; y <= total; y++)// TODOX total is obsolete
		{
			// flip the piece from the given location
			uint64_t loc = locations[x][y];
			uint64_t flip_loc = 0;
            int count = 0;
			for (int x = 0; x < 64; x++) // simple and dumb
			{
				if ((loc>>x)&1)
				{
					flip_loc |= (one<<flipTable[x]);
                    count ++;
				}
			}
//            cout << "\n\n";
			// find match to flip
			bool success = false;
			for (int z = 1; z <= total; z++)
			{
				if (locations[x][z] == flip_loc)
				{
					flipMap[x][y] = z;
					success = true;
					break;
				}
			}
            
			assert(success == true);
		}
	}
}

void HexagonEnvironment::RotateCW(HexagonSearchState &s) const
{
	HexagonSearchState tmp;
	for (int x = 0; x < s.cnt; x++)
	{
		ApplyAction(tmp, RotateCW(s.state[x]));
	}
	s = tmp;
}

HexagonAction HexagonEnvironment::RotateCW(HexagonAction a) const
{
	a.location = rotate30Map[a.piece][a.location];

	return a;
}

void HexagonEnvironment::Flip(HexagonSearchState &s) const
{
	HexagonSearchState tmp;
	for (int x = 0; x < s.cnt; x++)
	{
		ApplyAction(tmp, Flip(s.state[x]));
	}
	s = tmp;
}

HexagonAction HexagonEnvironment::Flip(HexagonAction a) const
{
	a.location = flipMap[a.piece][a.location];
	return a;
}

bool all = false;
uint64_t goldenPattern = 1143;

void HexagonEnvironment::GetSuccessors(const HexagonSearchState &nodeID, vector<HexagonSearchState> &neighbors) const
{
	static vector<HexagonAction> actions;
	GetActions(nodeID, actions);
	neighbors.resize(0);
	for (auto i : actions)
	{
		HexagonSearchState next;
		GetNextState(nodeID, i, next);
		neighbors.push_back(next);
	}
}


void HexagonEnvironment::GetActions2(const HexagonSearchState &nodeID, vector<HexagonAction> &actions) const
{
    actions.clear();
    GetInferenceActions(nodeID, actions, 0b111);
}

void HexagonEnvironment::GetActions(const HexagonSearchState &nodeID, vector<HexagonAction> &actions) const
{
	actions.clear();
    
    for (int p = (all ? 0 : nodeID.cnt); p <= (all ? (pieces.size() - 1) : nodeID.cnt); p++)
    {
        unsigned int piece = pieces[p];
        
        if(all)
        {
            int alreadyPlayed = false;
            for (int i = 0; i < nodeID.cnt; i++)
            {
                if(nodeID.state[i].piece == piece)
                {
                    alreadyPlayed += 1;
                    if(alreadyPlayed == 2 || piece != kTrapezoid) break;
                }
            }
            if(alreadyPlayed == 2 || (alreadyPlayed == 1 && piece != kTrapezoid)) continue;
        }
        
        switch (flippable[nodeID.cnt])
        {
            case kCanFlip:
            case kHoles:
                if(all)
                {
                    for (unsigned int x = 1; x <= locations[piece][0]; x++)
                    {
                        if ((nodeID.bits&locations[piece][x]) == 0 && GoalValidHoles(nodeID, goldenPattern))
                            actions.push_back({piece, x});
                    }
                }
                else
                {
                    for (unsigned int x = 1; x <= locations[piece][0]; x++)
                    {
                        if ((nodeID.bits&locations[piece][x]) == 0)
                            actions.push_back({piece, x});
                    }
                }
                break;
            case kSide1:
                for (unsigned int x = 1; x <= noFlipMoveCount[piece]; x++)
                {
                    if ((nodeID.bits&locations[piece][x]) == 0)
                        actions.push_back({piece, x});
                }
                break;
            case kSide2:
                for (unsigned int x = noFlipMoveCount[piece]+1; x <= locations[piece][0]; x++)
                {
                    if ((nodeID.bits&locations[piece][x]) == 0)
                        actions.push_back({piece, x});
                }
                break;
        }
    }
}

long bestGlobal = INT_MAX, validAGlobal = 0, validBGlobal = 0, validOGlobal = 0, validX1Global = 0, validX2Global = 0, validX3Global = 0, mostPatternGoalsGlobal = 0;

const int numPatternsForPiece[numPieces] = {1, 1, 3, 3, 4, 4, 4, 4, 3, 3};


/*
 COLOR OPTIMIZATION
 
 up to 10 colors
 
 all ways of assigning colors to pieces:
 2: 2^10 => 1024
 3: 3^10 => 59k
 4: 4^10 => 1M
 5: 5^10 => 9.7M
 6: 6^10 => 60M
 7: 7^10 => 282M
 8: 8^10 => 1B
 9: 9^10 => 3B
 10: 10^10 => 10B
  
 all ways of defining constraints:
 2: must touch edge, no touch edge, must touch corner, no touch corner => 4
 3: 12
 4: 24
 5: 40
 6: 60
 7: 84
 8: 112
 9: 144
 10: 180
 
 0 - 49
 
 10 - 5 : 5^10
 
 List of pieces and what pieces the share an edge with
 piece 0 { 1, 3 ,4}, piece 1 {0, 5, 7},..
 
 List of pieces and what pieces the share a corner with
 piece 0 { 1, 3 ,4}, piece 1 {0, 5, 7},..
 
 
 */

// 000100000
// 010000000

//for i  0  -> clrs
//      for p : c[i]
//          for j i+1 -> clrs
//              for q : c[j]
//                  if((edgeAdjacent(p,q) && must_not_be_edge_adjacent[i,j])
//                      || (!edgeAdjacent(p,q) && must_be_edge_adjacent[i,j])
//                      || (cornerAdjacent(p,q) && must_not_be_corner_adjacent[i,j])
//                      || (!cornerAdjacent(p,q) && must_be_corner_adjacent[i,j]))
//                  goalValid = false;
//                  break;


int bestPatternGlobal;
vector<int> GetNeighboringTrianlges(int loc)
{
    vector<int> res;
    if(!(loc == 6 || loc == 15 || loc == 26 || loc == 37 || loc == 46 || loc == 53))
    {
        res.push_back(loc+1);
    }
    if(!(loc == 0 || loc == 7 || loc == 16 ||
           loc == 27 || loc == 38 || loc == 47))
    {
        res.push_back(loc-1);
    }
    if(loc < 47 && ((loc % 2 == 0 && loc <= 6) || (loc % 2 == 1 && (loc > 6 && loc <= 15)) || (loc % 2 == 0 && (loc > 15 && loc <= 37)) || (loc % 2 == 1 && (loc > 37 && loc <= 46)) || (loc % 2 == 0 && (loc > 46 && loc <= 53))))
    {
        res.push_back(loc+(loc < 7 ? 8 : (loc < 16 ? 10 : (loc < 27 ? 11 : (loc < 38 ? 10 : 8)))));
    }
    else if(loc > 6 && ((loc % 2 == 1 && loc <= 6) || (loc % 2 == 0 && (loc > 6 && loc <= 15)) || (loc % 2 == 1 && (loc > 15 && loc <= 37)) || (loc % 2 == 0 && (loc > 37 && loc <= 46)) || (loc % 2 == 1 && (loc > 46 && loc <= 53))))
    {
        res.push_back(loc-(loc < 16 ? 8 : (loc < 27 ? 10 : (loc < 38 ? 11 : (loc < 47 ? 10 : 8)))));
    }
    
    return res;
}

uint64_t GetNeighboringTrianlgesBits(int loc)
{
    uint64_t res = 0;
    if(!(loc == 6 || loc == 15 || loc == 26 || loc == 37 || loc == 46 || loc == 53))
    {
        res |= (((uint64_t)1)<<(loc+1));
    }
    if(!(loc == 0 || loc == 7 || loc == 16 ||
           loc == 27 || loc == 38 || loc == 47))
    {
        res |= (((uint64_t)1)<<(loc-1));
    }
    if(loc < 47 && ((loc % 2 == 0 && loc <= 6) || (loc % 2 == 1 && (loc > 6 && loc <= 15)) || (loc % 2 == 0 && (loc > 15 && loc <= 37)) || (loc % 2 == 1 && (loc > 37 && loc <= 46)) || (loc % 2 == 0 && (loc > 46 && loc <= 53))))
    {
        res |= (((uint64_t)1)<<(loc+(loc < 7 ? 8 : (loc < 16 ? 10 : (loc < 27 ? 11 : (loc < 38 ? 10 : 8))))));
    }
    else if(loc > 6 && ((loc % 2 == 1 && loc <= 6) || (loc % 2 == 0 && (loc > 6 && loc <= 15)) || (loc % 2 == 1 && (loc > 15 && loc <= 37)) || (loc % 2 == 0 && (loc > 37 && loc <= 46)) || (loc % 2 == 1 && (loc > 46 && loc <= 53))))
    {
        res |= (((uint64_t)1)<<(loc-(loc < 16 ? 8 : (loc < 27 ? 10 : (loc < 38 ? 11 : (loc < 47 ? 10 : 8))))));
    }
    
    return res;
}

void HexagonEnvironment::BuildAdjacencies(HexagonSearchState &goal)
{
    int i, j, k, p, q;
    bool edgeAdjacent, cornerAdjacent;
    
    for(p = 0; p < goal.cnt; p++)
    {
        vector<int> bits1;
        for (i = 0; i < 54; i++)
        {
            if((locations[goal.state[p].piece][goal.state[p].location]>>i)&1)
                bits1.push_back(i);
        }
        
        for(q = p+1; q < goal.cnt; q++)
        {
            edgeAdjacent = false;
            cornerAdjacent = false;
            
            vector<int> bits2;
            for (i = 0; i < 54; i++)
            {
                if((locations[goal.state[q].piece][goal.state[q].location]>>i)&1)
                    bits2.push_back(i);
            }
            
            for (i = 0; i < bits1.size(); i++)
            {
                vector<int> neighbors = GetNeighboringTrianlges(bits1[i]);
                for (j = 0; j < bits2.size(); j++)
                {
                    if(find(neighbors.begin(), neighbors.end(), bits2[j]) != neighbors.end())
                    {
                        edgeAdjacent = true;
//                        goal.edgeAdjacencies[goal.state[p].piece+10*goal.state[q].piece] = true;
//                        goal.edgeAdjacencies[goal.state[q].piece+10*goal.state[p].piece] = true;
                        goal.edgeAdjacencies[p+11*q] = true;
                        goal.edgeAdjacencies[q+11*p] = true;
                        break;
                    }
                }
                
                if(edgeAdjacent)
                {
                    break;
                }
            }
            
            if(edgeAdjacent)
            {
                continue;
            }
            
            
            for (i = 0; i < bits1.size(); i++)
            {
                vector<int> neighbors = GetNeighboringTrianlges(bits1[i]);
                
                for (k = 0; k < neighbors.size(); k++) {
                    vector<int> secondNeighbors = GetNeighboringTrianlges(neighbors[k]);
                    for (j = 0; j < bits2.size(); j++)
                    {
                        if(find(secondNeighbors.begin(), secondNeighbors.end(), bits2[j]) != secondNeighbors.end())
                        {
                            cornerAdjacent = true;
//                            goal.cornerAdjacencies[goal.state[p].piece+10*goal.state[q].piece] = true;
//                            goal.cornerAdjacencies[goal.state[q].piece+10*goal.state[p].piece] = true;
                            goal.cornerAdjacencies[p+11*q] = true;
                            goal.cornerAdjacencies[q+11*p] = true;
                            break;
                        }
                    }
                    if(cornerAdjacent) break;
                }
                if(cornerAdjacent) break;
            }
        }
    }
}


//                if((!(bits1[i] == 6 || bits1[i] == 15 || bits1[i] == 26 || bits1[i] == 37 || bits1[i] == 46 || bits1[i] == 53) && find(bits2.begin(), bits2.end(), bits1[i]+1) == bits2.end())
//                   ||
//                   (!(bits1[i] == 0 || bits1[i] == 7 || bits1[i] == 16 ||
//                      bits1[i] == 27 || bits1[i] == 38 || bits1[i] == 47) && find(bits2.begin(), bits2.end(), bits1[i]-1) == bits2.end())
//                   ||
//                   (bits1[i] % 2 == 0 && bits1[i] < 47 && find(bits2.begin(), bits2.end(), bits1[i]+(bits1[i] < 7 ? 8 : (bits1[i] < 16 ? 10 : (bits1[i] < 27 ? 11 : (bits1[i] < 38 ? 10 : 8))))) == bits2.end())
//                   ||
//                   (bits1[i] % 2 == 1 && bits1[i] > 6 && find(bits2.begin(), bits2.end(), bits1[i]-(bits1[i] < 16 ? 8 : (bits1[i] < 27 ? 10 : (bits1[i] < 38 ? 11 : (bits1[i] < 47 ? 10 : 8))))) == bits2.end()))
//                {
//                    goal.edgeAdjacencies[p+10*q] = true;
//                    goal.edgeAdjacencies[q+10*p] = true;
//                    break;
//                }


void HexagonEnvironment::ColorConstraintSpaceSearchParallel(vector<HexagonSearchState> goals, vector<double> &interestingPatterns, int THRESHOLD, uint64_t numPatterns, int numColors, int threadNum, int totalThreads)
{
    vector<double> localInterestingPatterns(interestingPatterns.size());
    uint64_t patternGoals = 0;
    bool goalValid;
    int size = goals.size();
    int i,j,k,p,q,g;
    int constraint;
    HexagonSearchState goal;
    int adjacencyPortion;
    
    vector<vector<int>> colors(numColors);
    
    for (i = 0; i < 10; i++) {
        colors[i/5].push_back(i);
    }
    
    cout << threadNum << " " << numPatterns << " " << totalThreads;
    
    for (uint64_t pattern = threadNum; pattern < numPatterns; pattern += totalThreads)
    {
        for (i = 0; i < numColors; i++) {
            colors[i].clear();
        }
        
        k = pow(numColors, pieces.size());
        q = pattern % k;
        
        for (i = 0; i < 10; i++) {
            p = q / pow(numColors, i);
            p %= numColors;
            colors[p].push_back(i);
        }
        
        adjacencyPortion = pattern / pow(numColors, pieces.size());
        
        patternGoals = 0;
        if(pattern % 1000000 == 0)
        {
            cout << "Pattern " << pattern << " / " << numPatterns << " ("<< ((pattern*100)/numPatterns) << "%)" << "\n";
        }
        
        for (g = 0; g < size; g++)
        {
            goal = goals[g];
            goalValid = true;
            k = -1;

            for (i = 0; i < numColors; i++)
            {
                for (j = i+1; j < numColors; j++)
                {
                    k++;
                    constraint = adjacencyPortion / pow(5, k);
                    constraint %= 5;
                    for (p = 0; p < colors[i].size(); p++)
                    {
                        for (q = 0; q < colors[j].size(); q++)
                        {
                            if((goal.edgeAdjacencies[p + 10 * q] && constraint == 1)
                              || (!goal.edgeAdjacencies[p + 10 * q] && constraint == 2)
                              || (goal.cornerAdjacencies[p + 10 * q] && constraint == 3)
                              || (!goal.cornerAdjacencies[p + 10 * q] && constraint == 4))
                            {
                                goalValid = false;
                                break;
                            }
                        }
                        if(!goalValid) break;
                    }
                    if(!goalValid) break;
                }
                if(!goalValid) break;
            }
                        
            if(goalValid) patternGoals++;
        }
        
        localInterestingPatterns[patternGoals]++;
    }
    
    patternLock.lock();
    
    for(i = 0; i < interestingPatterns.size(); i++)
        interestingPatterns[i] += localInterestingPatterns[i];
    
    patternLock.unlock();
    
    cout<<"THREAD (" << threadNum << ") COMPLETE\n";
}

// 0/1 0/2 0/3 0/4 1/2 1/3 1/4 2/3 2/4 3/4
int comb = 1;
// Runs the search with the predetermined set of piece colors
void HexagonEnvironment::GenerateColorRules(vector<HexagonSearchState> &goals, vector<double> &interestingPatterns, int THRESHOLD, uint64_t numPatterns, int numColors, int threadNum, int totalThreads, vector<vector<HexagonSearchState>> &selectedSolutions)
{
    vector<double> localInterestingPatterns(interestingPatterns.size());
    vector<int> pieces;
    uint64_t patternGoals = 0;
    bool goalValid;
    int size = goals.size(), mostPatternGoals = 99999, bestPattern;
    mostPatternGoalsGlobal = 999999;
    int i,j,k,p,q,g;
    int constraint;
    HexagonSearchState goal;
    int adjacencyPortion;
    
    vector<vector<int>> colors(numColors);
    
    int p1 = comb % 4, p2 = comb / 4;
    
    if(p1 == p2) p2 = 3;
    
    colors[0].push_back(0); // all sym
    colors[0].push_back(1);
    
    colors[1].push_back(3); // rot sym
    colors[1].push_back(9);
    
    colors[2].push_back(2); // flip sym
    colors[2].push_back(8);
    colors[2].push_back(8);
    
    colors[3].push_back(p1+4);
    colors[3].push_back(p2+4);
    
    for (i = 0; i < 4; i++) {
        if(i != p1 && i != p2)
            colors[4].push_back(i+4);
    }
    
    numPatterns = numColors * (numColors-1) / 2;
    int constraintType = 1;
    
//        for (i = 0; i < numColors; i++) {
//            colors[i].clear();
//        }
//
//        k = pow(numColors, pieces.size());
//        q = pattern % k;
//
//        for (i = 0; i < 10; i++) {
//            p = q / pow(numColors, i);
//            p %= numColors;
//            colors[p].push_back(i);
//        }
        
//        adjacencyPortion = pattern;// / k;
        
//        if(pattern % 1000000 == 0)
//        {
//            cout << "Pattern " << pattern << " / " << numPatterns << " ("<< ((pattern*100)/numPatterns) << "%)" << "\n";
//        }
        
        for (g = 0; g < size; g++)
        {
            goal = goals[g];
            patternGoals = 0;
            pieces.clear();
            for (p = 0; p < goal.cnt; p++)
            {
                pieces.push_back(goal.state[p].piece);
            }
            
            for(int multi = 0; multi < 2; multi++)
            for (constraintType = 1; constraintType < 5; constraintType++)
//            constraintType = 4;
            {
                numPatterns = multi == 0 ? numColors : (numColors * (numColors-1) / 2);
                for (int pattern = 0; pattern < numPatterns; pattern++)
                {
                    goalValid = constraintType == 1 || constraintType == 3;
                    k = -1;
                    
                    for (i = (multi == 0 ? pattern : 0); i < (multi == 0 ? (pattern+1) : numColors); i++)
                    {
                        for (j =  (multi == 0 ? pattern : (i+1)); j < (multi == 0 ? (pattern+1) : numColors); j++)
                        {
                            k++;
                            if(multi == 1 && k != pattern) continue;
                            
                            if(i == j && multi == 0) // TODOX added multi here
                            {
                                int numPiecesOfClr = 0;
                                for (int tp : pieces) {
                                    if(find(colors[i].begin(), colors[i].end(), tp) != colors[i].end())
                                        numPiecesOfClr++;
                                }
                                if(numPiecesOfClr < 2) continue;
                            }
                            //                            cout << constraintType << " " << i << " " << j << " " << (i * numPieces + j) << " " << ((i * numPieces + j) * 10 + constraintType) << colors[i].size() << " " << colors[j].size() << "\n";
                            goal.constraints.push_back((i * numPieces + j) * 10 + constraintType);
//                            if(goal.allConstraints.size() > 1) cout<<"\n\nMOREE\n\n\n";
                            constraint = constraintType;//adjacencyPortion / pow(5, k);
                            //                    constraint %= 5;
                            bool lookingForFirstTrapezoid = true;
                            for (p = 0; p < colors[i].size(); p++)
                            {
                                int p1 = colors[i][p];
                                int actualP = -1;
                                bool firstTrapezoid = true;
                                for (int pp = 0; pp < goal.cnt; pp++)
                                {
                                    if(goal.state[pp].piece == p1)
                                    {
                                        // if this is first trapezoid and looking for first get => set looking for first to false
                                        // if this is first and looking for second continue => set first to false
                                        // if this is second and looking for second get
                                        
                                        if(p1 == 8)
                                        {
                                            if(lookingForFirstTrapezoid)
                                            {
                                                lookingForFirstTrapezoid = false;
                                                actualP = pp;
                                                break;
                                            }
                                            
                                            if(!firstTrapezoid)
                                            {
                                                actualP = pp;
                                                break;
                                            }
                                            
                                            firstTrapezoid = false;
                                            continue;
                                        }
                                        
                                        actualP = pp;
                                        break;
                                    }
                                }

                                bool lookingForFirstQTrapezoid = true;
                                for (q = 0; q < colors[j].size(); q++)
                                {
                                    
                                    int q1 = colors[j][q];
                                    int actualQ = -1;
                                    bool firstQTrapezoid = true;

                                    for (int qq = 0; qq < goal.cnt; qq++)
                                    {
                                        if(goal.state[qq].piece == q1)
                                        {
                                            if(q1 == 8)
                                            {
                                                if(lookingForFirstQTrapezoid)
                                                {
                                                    lookingForFirstQTrapezoid = false;
                                                    actualQ = qq;
                                                    break;
                                                }
                                                
                                                if(!firstQTrapezoid)
                                                {
                                                    actualQ = qq;
                                                    break;
                                                }
                                                
                                                firstQTrapezoid = false;
                                                continue;
                                            }
                                            actualQ = qq;
                                            break;
                                        }
                                    }

                                    if(actualP == actualQ || actualP == -1 || actualQ == -1)
                                    {
                                        continue;
                                    }

                                    if(   ( goal.edgeAdjacencies  [actualP + 11 * actualQ] && constraint == 1)
                                       || (!goal.edgeAdjacencies  [actualP + 11 * actualQ] && constraint == 2)
                                       || ((goal.edgeAdjacencies  [actualP + 11 * actualQ] || goal.cornerAdjacencies[actualP + 11 * actualQ]) && constraint == 3)
                                       || ((goal.edgeAdjacencies [actualP + 11 * actualQ]  ||!goal.cornerAdjacencies[actualP + 11 * actualQ]) && constraint == 4))
                                    {
                                        goalValid = false;
                                        break;
                                    }
                                    if((goal.edgeAdjacencies[actualP + 11 * actualQ] && constraint == 2) || ((!goal.edgeAdjacencies[actualP + 11 * actualQ] && goal.cornerAdjacencies[actualP + 11 * actualQ]) && constraint == 4))
                                        goalValid = true;
                                }
                                if(!goalValid) break;
                            }
                            //                            if(!goalValid) break;
                        }
                        //                        if(!goalValid) break;
                    }

                    if(goalValid)
                    {
                        patternGoals++;
                        
                        //                        cout<<"GOAL VALID [" << goal.index <<"] " <<constraintType << " " << selectedSolutions[constraintType].size() << "\n";
                        
                        goals[g].allConstraints.push_back(goal.constraints[0]);
                        for (auto t : goal.constraints) {
                            
                            HexagonSearchState newGoal;
                            newGoal.state = goal.state;
                            newGoal.cnt = goal.cnt;
                            newGoal.bits = goal.bits;
                            newGoal.index = goal.index;
                            newGoal.dots = goal.dots;
                            newGoal.forbiddenPiece = goal.forbiddenPiece;
                            
                            newGoal.edgeAdjacencies = goal.edgeAdjacencies;
                            newGoal.cornerAdjacencies = goal.cornerAdjacencies;
                            
//                            if(multi == 1)
//                                cout << "idx " << goal.index << " color: " << t << "\n";
                            
                            newGoal.constraints.push_back(t);
                            newGoal.allConstraints = goals[g].allConstraints;
                            
                            selectedSolutions[multi == 0 ? constraintType : 5].push_back(newGoal);
                        }
                        
                    }
                    
                    goal.constraints.clear();
                    
                }
            }
        
        localInterestingPatterns[g] = patternGoals;
        if(patternGoals < mostPatternGoals) { mostPatternGoals = patternGoals; bestPattern = g; }
//        if(patternGoals > mostPatternGoals) mostPatternGoals = patternGoals;
    }
    
    patternLock.lock();
    
    if(mostPatternGoals < mostPatternGoalsGlobal) { mostPatternGoalsGlobal = mostPatternGoals; bestPatternGlobal = bestPattern; }
    
    for(i = 0; i < interestingPatterns.size(); i++)
        interestingPatterns[i] += localInterestingPatterns[i];
    
    for (i = 0; i < goals.size(); i++) {
        if(goals[i].allConstraints.size() > 1)
        {
//            selectedSolutions[5].push_back(goals[i]);
//            cout << "NOW WE HAVE " << selectedSolutions[5].size();
        }
    }
    
    patternLock.unlock();
    
//    cout<<"THREAD (" << threadNum << ") COMPLETE\n";
}

uint64_t HexagonEnvironment::BitsFromArray(vector<int> a) const
{
    uint64_t r = 0;
    for(int i : a) r|=(((uint64_t)1)<<i);
    return r;
}

string HexagonEnvironment::FancyPrintBoard(uint64_t bits, uint64_t holes) const
{
//    bits = 671154232;
    string res = "";
    
    for (int i = 0; i < 54; i++) {
        if(i == 0 || i == 47) res += "  ";
        if(i == 7 || i == 38) res += " ";
        
        if(((i % 2 == 0 && i <= 6) || (i % 2 == 1 && (i > 6 && i <= 15)) || (i % 2 == 0 && (i > 15 && i <= 37)) || (i % 2 == 1 && (i > 37 && i <= 46)) || (i % 2 == 0 && (i > 46 && i <= 53))))
        {
            res += ((bits>>i)&1) == 0 ? "â³" : (((holes>>i)&1) != 0 ? "â®" : "â²");
//            res |= (((uint64_t)1)<<(loc+(loc < 7 ? 8 : (loc < 16 ? 10 : (loc < 27 ? 11 : (loc < 38 ? 10 : 8))))));
        }
        else
        {
            res += ((bits>>i)&1) == 0 ? "â½" : (((holes>>i)&1) != 0 ? "â§¨" : "â¼");
//            res |= (((uint64_t)1)<<(loc-(loc < 16 ? 8 : (loc < 27 ? 10 : (loc < 38 ? 11 : (loc < 47 ? 10 : 8))))));
        }
        
        if(i == 6) res += "  ";
        if(i == 26 || i == 46) res += " ";
        
        if(i == 6 || i == 15 || i == 26 || i == 37 || i == 46)
            res += "\n";
    }
    
    return res;
}

//
bool HexagonEnvironment::GoalValidHoles(HexagonSearchState goal, uint64_t pattern) const
{
    if(goal.dots == 0)
        return true;
    
    int p1, p2, y, loc, piece, location, x1, x2, x;
    
    p1 = comb % 4;
    p2 = comb / 4;

    if(p1 == p2) p2 = 3;

    p1+=4;
    p2+=4;
    
    for(int p = 0; p < goal.cnt; p++)
    {
        piece = goal.state[p].piece;
        
        location = goal.state[p].location;
        
        if(numPatternsForPiece[piece] == 1)
        {
//            cout << "\n\n" << FancyPrintBoard(locations[piece][location]) << "\n\n";
            continue;
        }
        
        bool valid = false;
        
        uint64_t div = 1;
        
        for (int j = 0; j < piece; j++)
        {
            div *= numPatternsForPiece[j];
        }
        
        x = (pattern / div) % numPatternsForPiece[piece];

        if(piece == 3 || piece == 9)
        {
            // flip odd, even, no constraint
            // rot: one side fits and not the other, or neither
            x1 = x % 2 == 0 ? 0 : 3;
            x2 = x / 2 == 0 ? 0 : 3;
        }
        else
        {
            if(numPatternsForPiece[piece] == 3)
            {
                x1 = x2 = x;
            }
            else
            {
                if(p1 == piece || p2 == piece)
                {
                    // no - o/e
                    x1 = x < 2 ? (x+1) : 3;
                    x2 = x > 1 ? (x-1) : 3;
                }
                else
                {
                    // o/e e/o
                    x1 = (x / 2) + 1;
                    x2 = (x % 2) + 1;
                }
                
//                        x1 = x / 4;
//                        x2 = x % 4;
            }
        }
        
        if(location <= noFlipMoveCount[piece])
        {
            if(x1 == 0)
            {
//                cout << "\n\n" << FancyPrintBoard(locations[piece][location], locations[piece][location]) << "\n\n";
                continue;
            }
            
            if((numPatternsForPiece[piece] == 3 && !(piece == 3 || piece == 9)) && x2 == 0)
            {
//                cout << "\n\n" << FancyPrintBoard(locations[piece][location], locations[piece][location]) << "\n\n";
                continue;
            }
            
            if(x1 != 3)
            {
                for (y = 1; y <= (x1 == 1 ? localized_holes_side1_odd : localized_holes_side1_even)[piece][location][0]; y++)
                {
                    if (((goal.dots&~(x1 == 1 ? localized_holes_side1_odd : localized_holes_side1_even)[piece][location][y])&locations[piece][location]) == 0)
                    {
                        valid = true;
//                        cout << "\n\n" << FancyPrintBoard(locations[piece][location], (x1 == 1 ? localized_holes_side1_odd : localized_holes_side1_even)[piece][location][y]) << "\n\n";
                        break;
                    }
                }
                
                if(valid)
                {
                    continue;
                }
            }
        }
        else
        {
            if(x2 == 0)
            {
//                cout << "\n\n" << FancyPrintBoard(locations[piece][location], locations[piece][location]) << "\n\n";
                continue;
            }
            
            if(x2 != 3)
            {
                loc = location - noFlipMoveCount[piece];// + 1;
                
                for (y = 1; y <= (x2 == 1 ? localized_holes_side2_odd : localized_holes_side2_even)[piece][loc][0]; y++)
                {
                    if (((goal.dots&~(x2 == 1 ? localized_holes_side2_odd : localized_holes_side2_even)[piece][loc][y])&locations[piece][location]) == 0)
                    {
                        valid = true;
//                        cout << "\n\n" << FancyPrintBoard(locations[piece][location], (x2 == 1 ? localized_holes_side2_odd : localized_holes_side2_even)[piece][loc][y]) << "\n\n";
                        break;
                    }
                }
                
                if(valid)
                {
                    continue;
                }
            }
        }
        
//        cout << "\n\nINVLAID\n\n";

        return false;
    }
    
    uint64_t dots = BitsFromArray({1,3,5,8,10,12,14,17,19,21,23,25,27,29,31,33,35,37,38,40,42,44,46,47,49,51,53});
    
//    cout << "\n\n" << FancyPrintBoard((((1ull)<<54)-1), dots) << "\n\n";
//
//    cout << "\n\nVALID "<< goal.index <<"\n\n";
    
//    int ffhx =22;
    
    return true;
}

vector<HexagonSearchState> filteredGoals;

void HexagonEnvironment::FilterGoalsUsingPattern(vector<HexagonSearchState> goals, vector<double> &interestingPatterns, int THRESHOLD, uint64_t numPatterns, int threadNum, int totalThreads)
{
    long best = goals.size(), validA = 0, validB = 0, validX1 = 0, validX2 = 0, validX3 = 0, validO = 0,mostPatternGoals=0, bestPattern;
    vector<double> localInterestingPatterns(interestingPatterns.size());
    uint64_t patternGoals = 0;
    bool debug = false;//threadNum==0;//pattern % 1000000 == 0;
    bool goalValid, valid;
    int location, loc, piece;
    int size = goals.size();
    int i,j,p,y;
    int x, x1, x2, p1, p2;
    HexagonSearchState goal;
    
    vector<double> goalxs(10);
    
    p1 = comb % 4;
    p2 = comb / 4;
    
    if(p1 == p2) p2 = 3;
    
    p1+=4;
    p2+=4;
//
//    if(threadNum == 0)
//        cout << "COMB COMPONENTS " << p1 << " " << p2 << "\n";
//
    
    // hole patterns -> max solutions + max min color-constraint-configs solution
//    for (uint64_t pattern = threadNum; pattern < numPatterns; pattern += totalThreads)
    uint64_t pattern = goldenPattern;
    {
//        bool basic_debug = pattern % 1000000 == 0;
//        bool debug = false;//pattern % 1000000 == 0;
        patternGoals = 0;
//        if(pattern % 1000000 == 0)
//        {
//            cout << "Pattern " << pattern << " / " << numPatterns << " ("<< ((pattern*100)/numPatterns) << "%)" << "\n";
//        }
        
//        int i = -1;
        
        for (i = 0; i < size; i++)
        {
            goal = goals[i];
//            i++;
            goalValid = true;
            
            if(debug)
            {
                cout << "Goal pieces " << goal.cnt << " " << i << "/" << size << "\n";
            }
            
            goalValid = GoalValidHoles(goal, pattern);
                        
            if(goalValid) {
                patternGoals++;
                filteredGoals.push_back(goals[i]);
            }
        }
        localInterestingPatterns[patternGoals]++;
        if(patternGoals > mostPatternGoals)
        {
            mostPatternGoals = patternGoals;
            bestPattern = pattern;
        }
    }
    
    patternLock.lock();
    
    for(i = 0; i < interestingPatterns.size(); i++)
        interestingPatterns[i] += localInterestingPatterns[i];
    
    validAGlobal+=validA;
    validBGlobal+=validB;
    validX1Global+=validX1;
    validX2Global+=validX2;
    validX3Global+=validX3;
    validOGlobal+=validO;
    
    if(mostPatternGoals > mostPatternGoalsGlobal) { mostPatternGoalsGlobal = mostPatternGoals; bestPatternGlobal = bestPattern; }
    
    patternLock.unlock();
    
//    cout<<"THREAD (" << threadNum << ") COMPLETE\n";
}


void HexagonEnvironment::ConstraintSpaceSearchParallel(vector<HexagonSearchState> goals, vector<double> &interestingPatterns, int THRESHOLD, uint64_t numPatterns, int threadNum, int totalThreads)
{
    long best = goals.size(), validA = 0, validB = 0, validX1 = 0, validX2 = 0, validX3 = 0, validO = 0,mostPatternGoals=0, bestPattern;
    vector<double> localInterestingPatterns(interestingPatterns.size());
    uint64_t patternGoals = 0;
    bool debug = false;//threadNum==0;//pattern % 1000000 == 0;
    bool goalValid, valid;
    int location, loc, piece;
    int size = goals.size();
    int i,j,p,y;
    int x, x1, x2;//, p1, p2;
    HexagonSearchState goal;
    
    vector<double> goalxs(10);
//
//    p1 = comb % 4;
//    p2 = comb / 4;
//
//    if(p1 == p2) p2 = 3;
//
//    p1+=4;
//    p2+=4;
    
    // hole patterns -> max solutions + max min color-constraint-configs solution
    for (uint64_t pattern = threadNum; pattern < numPatterns; pattern += totalThreads)
    {
        patternGoals = 0;
        if(pattern % 1000000 == 0)
        {
            cout << "Pattern " << pattern << " / " << numPatterns << " ("<< ((pattern*100)/numPatterns) << "%)" << "\n";
        }
                
        for (i = 0; i < size; i++)
        {
            goal = goals[i];
            goalValid = true;
            
            if(debug)
            {
                cout << "Goal pieces " << goal.cnt << " " << i << "/" << size << "\n";
            }
            
            goalValid = GoalValidHoles(goal, pattern);
                                    
            if(goalValid)
            {
                patternGoals++;
            }
        }
        
        localInterestingPatterns[patternGoals]++;
        
        if(patternGoals > mostPatternGoals)
        {
            mostPatternGoals = patternGoals;
            bestPattern = pattern;
        }
    }
    
    patternLock.lock();
    
    for(i = 0; i < interestingPatterns.size(); i++)
        interestingPatterns[i] += localInterestingPatterns[i];
//
//    validAGlobal+=validA;
//    validBGlobal+=validB;
//    validX1Global+=validX1;
//    validX2Global+=validX2;
//    validX3Global+=validX3;
//    validOGlobal+=validO;
//
    if(mostPatternGoals > mostPatternGoalsGlobal)
    {
        mostPatternGoalsGlobal = mostPatternGoals;
        bestPatternGlobal = bestPattern;
    }
    
    patternLock.unlock();
    
    cout<<"THREAD (" << threadNum << ") COMPLETE\n";
}

void HexagonEnvironment::GenerateInitialStates(int numColors, vector<vector<HexagonSearchState>> &selectedSolutions, int categories) const
{
    
//    vector<vector<int>> initStatePatterns(goals.size());
    
    vector<vector<int>> colors(numColors);
    
    int pp1 = comb % 4, pp2 = comb / 4;
    
    if(pp1 == pp2) pp2 = 3;
    
    
//    const int mapPiece[numPieces] =    {2, 1, 7, 6, 3, 5, 4, a, 8, 9};
//    const int revMapPiece[numPieces+1] = {7, 1, 0, 4, 6, 5, 3, 2, 8, 9, 8};// 8, 8/i 9/j
    
    colors[0].push_back(0); // all sym
    colors[0].push_back(1);
    
    colors[1].push_back(3); // rot sym
    colors[1].push_back(9);
    
    colors[2].push_back(2); // flip sym
    colors[2].push_back(8);
    colors[2].push_back(8);
    
    colors[3].push_back(pp1+4);
    colors[3].push_back(pp2+4);
    
    for (int i = 0; i < 4; i++) {
        if(i != pp1 && i != pp2)
            colors[4].push_back(i+4);
    }
    
    for(int i = 0; i < categories; i++)
    {
//        cout << "Analyzing group: " << i << " ("<< selectedSolutions[i].size() << " items)\n";
        for (int j = 0; j < selectedSolutions[i].size(); j++)
        {
//            cout<<"analyzing init for: " << j << "\n";
            for (int pattern = 0; pattern < pow(11, 10); pattern ++)
            {
//                cout<<pattern<<"\n";
                bool unique = true;
                uint64_t bits1 = 0;
                for (int x = 0; x < 10; x++)
                {
                    int p = pattern / pow(11, x);
                    p %= 11;
                    p--;
                    if(p!=-1)
                        bits1 |= locations[selectedSolutions[i][j].state[p].piece][selectedSolutions[i][j].state[p].location];
                }
                
                for (int k = 0; k < selectedSolutions[i].size(); k++)
                {
                    if(j == k || selectedSolutions[i][j].index == selectedSolutions[i][k].index || selectedSolutions[i][j].forbiddenPiece != selectedSolutions[i][j].forbiddenPiece) continue;
                    
                    if(i != 0)
                    {
                        HexagonSearchState goal = selectedSolutions[i][k];
                        bool goalValid = true;//TODOX
                        for (auto con : selectedSolutions[i][j].constraints)
                        {
                            int constraintType  = con % 5;
                            int constraint = constraintType;
                            int con1 = (con / 10) % numPieces;
                            int con2 = (con / 10) / numPieces;
                            
//                            cout << "Category: "<< i << " comparing: " << selectedSolutions[i][j].index << " VS " << selectedSolutions[i][k].index << " type: " << constraint << " clrs: " << con1<< "|"<< con2<<"\n";
                            //                            goal.constraints.push_back((i * numPieces + j) * 10 + constraintType);
                            bool lookingForFirstTrapezoid = true;
                            for (int p = 0; p < colors[con1].size(); p++)
                            {
                                int p1 = colors[con1][p];
                                int actualP = -1;
                                bool firstTrapezoid = true;
                                for (int pp = 0; pp < goal.cnt; pp++)
                                {
                                    if(goal.state[pp].piece == p1)
                                    {
                                        if(p1 == 8 && lookingForFirstTrapezoid)
                                            lookingForFirstTrapezoid = false;
                                        else if(p1 == 8 && !lookingForFirstTrapezoid && firstTrapezoid)
                                        {
                                            firstTrapezoid = false;
                                            continue;
                                        }
                                        
                                        actualP = pp;
                                        break;
                                    }
                                }
                                bool lookingForFirstQTrapezoid = true;
                                for (int q = 0; q < colors[con2].size(); q++)
                                {
                                    int q1 = colors[con2][q];
                                    int actualQ = -1;
                                    bool firstQTrapezoid = true;
                                    for (int qq = 0; qq < goal.cnt; qq++)
                                    {
                                        if(goal.state[qq].piece == q1)
                                        {
                                            if(q1 == 8 && lookingForFirstQTrapezoid)
                                                lookingForFirstQTrapezoid = false;
                                            if(q1 == 8 && !lookingForFirstQTrapezoid && firstQTrapezoid)
                                            {
                                                firstQTrapezoid = false;
                                                continue;
                                            }
                                            
                                            actualQ = qq;
                                            break;
                                        }
                                    }
                                    
                                    if(actualP == actualQ || actualP == -1 || actualQ == -1)
                                        continue;
                                    
//                                    cout << "validating " << actualP << " against " << actualQ << " type " << constraint <<"\n";
                                    
                                    if(   ( goal.edgeAdjacencies  [actualP + 11 * actualQ] && constraint == 1)
                                       || (!goal.edgeAdjacencies  [actualP + 11 * actualQ] && constraint == 2)
                                       || ((goal.edgeAdjacencies  [actualP + 11 * actualQ] || goal.cornerAdjacencies[actualP + 11 * actualQ]) && constraint == 3)
                                       || ((goal.edgeAdjacencies [actualP + 11 * actualQ]  ||!goal.cornerAdjacencies[actualP + 11 * actualQ]) && constraint == 4))
                                    {
                                        goalValid = false;
                                        break;
                                    }
                                    
                                    if((goal.edgeAdjacencies[actualP + 11 * actualQ] && constraint == 2) || ((!goal.edgeAdjacencies[actualP + 11 * actualQ] && goal.cornerAdjacencies[actualP + 11 * actualQ]) && constraint == 4))
                                        goalValid = true;
                                }
//                                cout << "Result: " << goalValid << "\n";
                                if(!goalValid) break;
                            }
                            if(!goalValid)
                                break;
                        }
                        
                        if(!goalValid) continue;
                    }
                      
                    HexagonSearchState tmp = selectedSolutions[i][k];
                    for (int y = 0; y < 6; y++)
                    {
                        uint64_t bits2 = 0;
                        for (int x = 0; x < 10; x++) {
                            int p = pattern / pow(11, x);
                            p %= 11;
                            p--;
                            if(p!=-1)
                                bits2 |= locations[tmp.state[p].piece][tmp.state[p].location];
                        }

                        if(bits1 == bits2)
                        {
                            unique = false;
                            break;
                        }
                        RotateCW(tmp);
                    }

                    if(!unique)
                        break;

                    Flip(tmp);
                    for (int y = 0; y < 6; y++)
                    {
                        uint64_t bits2 = 0;
                        for (int x = 0; x < 10; x++) {
                            int p = pattern / pow(11, x);
                            p %= 11;
                            p--;
                            if(p!=-1)
                                bits2 |= locations[tmp.state[p].piece][tmp.state[p].location];
                        }

                        if(bits1 == bits2)
                        {
                            unique = false;
                            break;
                        }
                        RotateCW(tmp);
                    }

                    if(!unique)
                        break;
                }
                
                if(unique)
                {
                    vector<string> initPieces;
                    for (int x = 0; x < 10; x++)
                    {
                        int p = pattern / pow(11, x);
                        p %= 11;
                        p--;
                        if(p!=-1)
                            initPieces.push_back(pieceNames[selectedSolutions[i][j].state[p].piece]);
                    }
                    
//                    initStatePatterns[i].push_back(pattern);
//                    cout<<"BEST INIT STATE FOR: " << selectedSolutions[i][j].index << " (" << pattern << ") "  << " is with: ";
                    
                    selectedSolutions[i][j].initState = pattern;
//
//                    for (auto t : initPieces) {
//                        cout <<t<< " | ";
//                    }
//                    cout<<"\n";
                    break;
                }
            }
        }
    }
}

// eliminate invalid pieces
// use vector rather than dict
// batch writes
// prune search
// hexagon is one *
// butterfly is one *
// trapezoids are three
// elbow is three
// parallelogram is three (specific) (or even one)

// opengl = stub
// make open gl = stub
// build/sfml
// hogw/bin/release

// clear: 0, odd: 1, even: 2, full: 3


//string pieceNames[numPieces] = {"hexagon", "butterfly","elbow","line","mountains","wrench","triangle","hook","trapezoid","snake"};
//    kHexagon = 0
//    kButterfly = 1
//    kElbow = 2
//    kLine = 3
//    kMountains = 4
//    kWrench = 5
//    kTriangle = 6
//    kHook = 7
//    kTrapezoid = 8
//    kSnake = 9

void HexagonEnvironment::FullAnalysis(vector<HexagonSearchState> goals, vector<vector<HexagonSearchState>> &selectedSolutions, int categories)
{
    all = true;

    int THREADS = 1;
    int THRESHOLD = ceil(goals.size()/2.0);
    
    int numColors = 5;

    uint64_t numPatterns = 1;
    
    for (int i = 0; i < numPieces; i++) {
        numPatterns *= numPatternsForPiece[i];
    }
    
//    numPatterns *= (numColors-1) * (numColors) / 2;
//    numPatterns *= 5;
    
//    numPatterns *= pow(numColors, pieces.size());
    
    
//    for (comb = 0; comb < 12; comb++)
//    comb = 5;
    {
        mostPatternGoalsGlobal = 0;
        cout << "\n------------------------------------------------------\n";
        cout << "Generating dotted side solutions...";
        cout << "\n------------------------------------------------------\n";
        vector<thread> v;
        vector<thread> v2;
        
        vector<double> interestingPatterns(goals.size()+1);
        
        for (int i = 0; i < THREADS; i++)
        {
            v.emplace_back(&HexagonEnvironment::FilterGoalsUsingPattern, this, goals, ref(interestingPatterns), THRESHOLD, numPatterns, i, THREADS);
        }
        
        for (auto& t : v)
        {
            t.join();
        }
        
        cout << "\n------------------------------------------------------\n";
        cout << "Finished generating dotted side solutions";
        cout << "\n------------------------------------------------------\n";
        
//        filteredGoals = goals;//TODOX
        
        selectedSolutions[0] = filteredGoals;
        
        if(categories > 1)
        {
            cout << "\n------------------------------------------------------\n";
            cout << "Generating color rules...";
            cout << "\n------------------------------------------------------\n";
            
            for (int i = 0; i < THREADS; i++) {
                v2.emplace_back(&HexagonEnvironment::GenerateColorRules, this, ref(filteredGoals), ref(interestingPatterns), THRESHOLD, numPatterns, numColors, i, THREADS, ref(selectedSolutions));
            }
            
            for (auto& t : v2) {
                t.join();
            }
        }

        cout << "\n------------------------------------------------------\n";
        cout << "Finished generating color rules...";
        cout << "\n------------------------------------------------------\n";
        
        //    cout << "A: " << validAGlobal << " B: " << validBGlobal << " X1: " << validX1Global << " X2: " << validX2Global << " X3: " << validX3Global << " O: " << validOGlobal << "\n"; TODO

//        for (int i = 0; i < filteredGoals.size(); i++) {
//            cout << "Goal: " << i << " patterns: " << interestingPatterns[i] << "\n";
//        }
//
//        cout << "\n------------------------------------------------------\n";
//        cout << "Smallest bin goal: " << bestPatternGlobal << " | Number of color patterns: " << mostPatternGoalsGlobal;
//        cout << "\n------------------------------------------------------\n\n";
        
        
//        for (int i = 0; i < mostPatternGoalsGlobal+1; i++) {
//            cout << "Goals: " << i << " patterns: " << interestingPatterns[i] << "\n";
//        }
//
//        cout << "\n------------------------------------------------------\n";
//        cout << "Best pattern: " << bestPatternGlobal << " | Most pattern goals: " << mostPatternGoalsGlobal;
//        cout << "\n------------------------------------------------------\n\n";
    }
    
    
    cout << "\n------------------------------------------------------\n";
    cout << "Generating inital states...";
    cout << "\n------------------------------------------------------\n";
    
    GenerateInitialStates(numColors, selectedSolutions, categories);
    
    cout << "\n------------------------------------------------------\n";
    cout << "Finished generating inital states";
    cout << "\n------------------------------------------------------\n";
//    vector<double> nums(goals.size()+1);
//
//
//    for (int i = 0; i < nums.size(); i++) {
//        nums[i] = i;
//    }
    
//    bool success;
//    StringReference *errorMessage = CreateStringReferenceLengthValue(0, L' ');
//    RGBABitmapImageReference *imageReference = CreateRGBABitmapImageReference();
//
//
//    success = DrawScatterPlot(imageReference, 1024, 1024, &nums, &interestingPatterns, errorMessage);
//
//    if(success){
//        vector<double> *pngdata = ConvertToPNG(imageReference->image);
//        WriteToFile(pngdata, "/Users/yazeedsabil/Desktop/svgs_clean/0example1.png");
//        DeleteImage(imageReference->image);
//        cout << "image gen success";
//    }else{
//        cerr << "Error: ";
//        for(wchar_t c : *errorMessage->string){
//            wcerr << c;
//        }
//        cerr << endl;
//
//        cout << errorMessage->string;
//    }
//
//    FreeAllocations();

    
//    ofstream ofs("/Users/yazeedsabil/Desktop/svgs_clean/hexagon.txt");

    // create class instance
//    map<int,string> whatever;

    // populate map.

    // save data to archive
//    {
//        boost::archive::text_oarchive oa(ofs);
//        // write map instance to archive
//        oa << interestingPatterns;
//        // archive and stream closed when destructors are called
//    }
}


void HexagonEnvironment::ConstraintSpaceSearch(vector<HexagonSearchState> goals)
{
    all = true;

    int THREADS = 8;
    
    int numColors = 5;

    uint64_t numPatterns = 1;
    
    for (int i = 0; i < numPieces; i++) {
        numPatterns *= numPatternsForPiece[i];
    }
    
//    numPatterns *= (numColors-1) * (numColors) / 2;
//    numPatterns *= 5;
    
//    numPatterns *= pow(numColors, pieces.size());
    
    vector<double> interestingPatternsAll(goals.size()+1);
    
    for (comb = 0; comb < 12; comb++)
    {
        int combwas = comb;
        mostPatternGoalsGlobal = 0;
//        cout << "\n------------------------------------------------------\n";
//        cout << "Comination: " << comb;
//        cout << "\n------------------------------------------------------\n";
        vector<thread> v;
        vector<thread> v2;
        
        vector<double> interestingPatterns(goals.size()+1);
        
        for (int i = 0; i < THREADS; i++)
        {
            v.emplace_back(&HexagonEnvironment::ConstraintSpaceSearchParallel, this, goals, ref(interestingPatterns), 0, numPatterns, i, THREADS);
        }
        
        for (auto& t : v)
        {
            t.join();
        }
        
//        cout << "\n------------------------------------------------------\n";
//        cout << "Finished hole space search";
//        cout << "\n------------------------------------------------------\n";
        
//        filteredGoals = goals;//TODOX
        
//        selectedSolutions[0] = filteredGoals;
        
//        cout << "\n------------------------------------------------------\n";
//        cout << "Running color space search...";
//        cout << "\n------------------------------------------------------\n";
//
//        for (int i = 0; i < THREADS; i++) {
//            v2.emplace_back(&HexagonEnvironment::GenerateColorRules, this, ref(filteredGoals), ref(interestingPatterns), THRESHOLD, numPatterns, numColors, i, THREADS, ref(selectedSolutions));
//        }
//
//        for (auto& t : v2) {
//            t.join();
//        }
//
//        cout << "\n------------------------------------------------------\n";
//        cout << "Finished color space search...";
//        cout << "\n------------------------------------------------------\n";
        
//        for (int i = 0; i < filteredGoals.size(); i++)
//        {
//            cout << "Goal: " << i << " patterns: " << interestingPatterns[i] << "\n";
//        }
//
//        cout << "\n------------------------------------------------------\n";
//        cout << "Smallest bin goal: " << bestPatternGlobal << " | Number of color patterns: " << mostPatternGoalsGlobal;
//        cout << "\n------------------------------------------------------\n\n";
        
        
        
        
        
        for (int i = 0; i < mostPatternGoalsGlobal+1; i++) {
            interestingPatternsAll[i] += interestingPatterns[i];
        }
    }
    
    
    for (int i = 0; i < mostPatternGoalsGlobal+1; i++) {
        cout << "Goals: " << i << " patterns: " << interestingPatternsAll[i] << "\n";
    }
    
    
//    cout << "\n------------------------------------------------------\n";
//    cout << "Best pattern: " << bestPatternGlobal << " | Most pattern goals: " << mostPatternGoalsGlobal;
//    cout << "\n------------------------------------------------------\n\n";

    vector<double> nums(goals.size()+1);

    for (int i = 0; i < nums.size(); i++) {
        nums[i] = i;
    }
    
//    bool success;
//    StringReference *errorMessage = CreateStringReferenceLengthValue(0, L' ');
//    RGBABitmapImageReference *imageReference = CreateRGBABitmapImageReference();
//
//    success = DrawScatterPlot(imageReference, 1024, 1024, &nums, &interestingPatternsAll, errorMessage);
//
//    if(success){
//        vector<double> *pngdata = ConvertToPNG(imageReference->image);
//        WriteToFile(pngdata, "/Users/yazeedsabil/Desktop/Temp/svgs_clean/0example" +to_string(comb)+".png");
//        DeleteImage(imageReference->image);
//        cout << "image gen success";
//    }else{
//        cerr << "Error: ";
//        for(wchar_t c : *errorMessage->string){
//            wcerr << c;
//        }
//        cerr << endl;
//
//        cout << errorMessage->string;
//    }
//
//    FreeAllocations();
    
    

    
//    ofstream ofs("/Users/yazeedsabil/Desktop/svgs_clean/hexagon.txt");

    // create class instance
//    map<int,string> whatever;

    // populate map.

    // save data to archive
//    {
//        boost::archive::text_oarchive oa(ofs);
//        // write map instance to archive
//        oa << interestingPatterns;
//        // archive and stream closed when destructors are called
//    }
}



//QUE: is this on purpose?
HexagonAction HexagonEnvironment::GetAction(const HexagonSearchState &s1, const HexagonSearchState &s2) const
{
	assert(false);
	return {0, 0};
}

void HexagonEnvironment::ApplyAction(HexagonSearchState &s, HexagonAction a) const
{
    s.state[s.cnt] = a;
    s.cnt++;
    s.bits ^= locations[a.piece][a.location];
}
//
//void HexagonEnvironment::ApplyAction(HexagonSearchState &s, int piece) const
//{
////    s.state[s.cnt] = a;
//    s.cnt++;
//    s.bits ^= locations[piece][0];
//}

void HexagonEnvironment::UndoAction(HexagonSearchState &s, HexagonAction a) const
{
	s.cnt--;
	s.bits ^= locations[a.piece][a.location];
}


void HexagonEnvironment::GetNextState(const HexagonSearchState &s1, HexagonAction a, HexagonSearchState &s2) const
{
	s2 = s1;
	ApplyAction(s2, a);
}

//QUE: how does this work?
bool HexagonEnvironment::InvertAction(HexagonAction &a) const
{
	return true;
}

/** Goal Test if the goal is stored **/
bool HexagonEnvironment::GoalTest(const HexagonSearchState &node) const
{
	return node.bits == (((1ull)<<54)-1); // all 54 1s set
//	return false;
}


uint64_t HexagonEnvironment::GetStateHash(const HexagonSearchState &node) const
{
	return 0;
}

uint64_t HexagonEnvironment::GetActionHash(HexagonAction act) const
{
	return 0;
}



// entropyRecur()
// from the given state
// step 1: base case if its solved => return 0
// call get successors
// filteredSuccessors = successors with removing moves you can't perform (based on inference rules)
// if filteredSuccssors.length == 0 return inf
// requiredSuccessors = filter by: if piece can only go to one place OR if the location can only fit one piece
// for succ : filteredSuccors:
//      childEntropy = min(entropyRecur(succ), childEntropy)
// return log2(filteredSucs.length)+childEntropy;



bool HexagonEnvironment::SizeOfEmtpyRegionRule(const HexagonSearchState &s) const
{
//    return true; // 9.321
    // When placing a piece, the unfilled regions need to have a number of open triangles which are either mod 6 or mod 3, depending on the trapezoid. This limits the number of possible placements.
    
    // steps:
    // write code that detects size of connected regions of empty triangles, add those trianlges in a list such that you don't explore them again
    // now you have the list of empty regions, should be vector<vector<int>> emptyRegions
    // get count for each and make sure they're either: mod 6 (in case we don't have trapezoids left), or that they're -3 mod 6 (in case we do)
    
    
    int remainingTrapezoids = 0;
    
    if(find(pieces.begin(), pieces.end(), kTrapezoid) != pieces.end())
    {
        remainingTrapezoids = 2;
        
        for (int i = 0; i < s.cnt; i++) {
            if(s.state[i].piece == kTrapezoid)
            {
                remainingTrapezoids--;
            }
        }
    }
    
    for (auto space : s.emptySpaces) {
        int spaceSize = 0;
        for (int i = 0; i < 54; i++)
        {
            if(((space>>i)&1) == 1)
                spaceSize++;
        }
        
        if(spaceSize%6 != 0 && !(remainingTrapezoids > 0 && (spaceSize-3)%6 == 0))
            return false;
    }
    
    return true;
}

bool HexagonEnvironment::PiecesAreComposedOfTrapezoidsRule(const HexagonSearchState &s) const
{
//    return true;// 21.2
    // There are certain patterns that can never be filled, even if they meet the parity constraint, given that all the pieces are composed of trapezoids, which reduces the number of places a piece might be placed.
    
    // steps:
    // get empty regions list
    // for all 6 sized spaces: check that there's a 2-trapezoid configuration that would fit the space
    
    
    for (auto space : s.emptySpaces) {
        int spaceSize = 0;
        for (int i = 0; i < 54; i++)
        {
            if(((space>>i)&1) == 1)
                spaceSize++;
        }
        
        if(spaceSize != 6)
            continue;
        
        bool configFound = false;
        for (int trap1 = 1; trap1 <= locations[kTrapezoid][0]; trap1++) {
            for (int trap2 = 1; trap2 <= locations[kTrapezoid][0]; trap2++) {
                uint64_t config = 0;
                config |= locations[kTrapezoid][trap1];
                config |= locations[kTrapezoid][trap2];
                
                if(space == config)
                {
                    configFound = true;
                    break;
                }
            }
            if(configFound) break;
        }
        
        if(!configFound)
        {
            return false;
        }
    }
    
    return true;
}

//21.2
bool HexagonEnvironment::PieceThatFitsTheSpaceIsNotAvailableRule(const HexagonSearchState &s) const
{
//    return true;//19.5
    // there can be spaces that can fit pieces, but that piece isnât available due to being played already, or not matching other (color/bump) constraints.
    
    // if both trapezoids are available return true
    
    
     int remainingTrapezoids = 0;
    
    if(find(pieces.begin(), pieces.end(), kTrapezoid) != pieces.end())
    {
        remainingTrapezoids = 2;
        
        for (int i = 0; i < s.cnt; i++) {
            if(s.state[i].piece == kTrapezoid)
            {
                remainingTrapezoids--;
            }
        }
    }
    
    if(remainingTrapezoids == 2) return true;
    
    // get empty regions list
    
    // if any of them is size 3 and no trapezoids are available return false
    
    // for each one of size 6, make sure that there's a remaining piece that has a location that can fit there, if so return true
    
    
    for (auto space : s.emptySpaces)
    {
        int spaceSize = 0;
        for (int i = 0; i < 54; i++)
        {
            if(((space>>i)&1) == 1)
                spaceSize++;
        }
        
        if(spaceSize == 3 && remainingTrapezoids == 0)
            return false;
        
        if(spaceSize != 6) continue;
        
        bool locCovered = false;
        
        for(auto piece : pieces)
        {
            bool piecePlayed = false;
            for (int p = 0; p < s.cnt; p++) {
                if(s.state[p].piece == piece)
                {
                    piecePlayed = true;
                    break;
                }
            }
            
            if(piecePlayed) continue;
            
            for (int loc = 1; loc <= locations[piece][0]; loc++) {
                if(locations[piece][loc] == space)
                {
                    locCovered = true;
                    break;
                }
            }
            
            if(locCovered) break;
        }
        
        if(!locCovered)
            return false;
    }
        
    return true;
}

uint64_t HexagonEnvironment::LocationCanOnlyFitACertainPieceReqRule(const HexagonSearchState &s) const
{
//    return 0;
    // if location can only fit one piece then it has to go there
    
    // loop through empty regions
    //      if its size 3 and a trapezoid exists return true
    //      int fits = 0;
    //      if its size 6 loop through remaining pieces and then loop through all their possible locations (given constraints?)
    //          fits++
    //      return fits == 1;
    
    
    
    int remainingTrapezoids = 0;
    
    if(find(pieces.begin(), pieces.end(), kTrapezoid) != pieces.end())
    {
        remainingTrapezoids = 2;
        
        for (int i = 0; i < s.cnt; i++) {
            if(s.state[i].piece == kTrapezoid)
            {
                remainingTrapezoids--;
            }
        }
    }
    
    if(remainingTrapezoids == 2) return 0;
    
    for (auto &space : s.emptySpaces)
    {
//        int spaceSize = 0;
//        for (int i = 0; i < 54; i++)
//        {
//            if(((space>>i)&1) == 1)
//                spaceSize++;
//        }
        
//        if(spaceSize == 3 && remainingTrapezoids > 0)
//            return true;
        
//        if(spaceSize != 6 && spaceSize != 3) return false;
        
//        if(spaceSize != 6) continue;
        
        int fits = 0, thePiece;
        
        for(auto piece : pieces)
        {
            if(remainingTrapezoids > 0 && piece != kTrapezoid) continue;
            
            int piecePlayed = 0;
            for (int p = 0; p < s.cnt; p++) {
                if(s.state[p].piece == piece)
                {
                    piecePlayed++;
                    break;
                }
            }
            
            if(piecePlayed) continue;
            
            for (int loc = 1; loc <= locations[piece][0]; loc++) {
                if(locations[piece][loc] == space)
                {
                    thePiece = piece;
                    fits++;
                    break;
                }
            }
        }
        
        if(fits == 1)
        {
//            cout<<"\n\n\nThis is the only piece: " << pieceNames[thePiece] << " that can fit the space\n" << FancyPrintBoard(space)<<"\n\n";
            return space;
        }
    }
    
    return 0;
}

int HexagonEnvironment::PieceCanOnlyGoInOnePlaceReqRule(const HexagonSearchState &s) const
{
//    return -1;
    // if piece can only go to one place then its requied to go there
    
    // loop through remaining pieces
    //      int fits = 0;
    //      loop through empty regions
    //          if its size 6 loop through all piece possible locations (given constraints?)
    //              fits++
    //      return fits == 1;
    
    
    
    for(auto piece : pieces)
    {
        if(piece == kTrapezoid) continue;
        
        bool piecePlayed = false;
        
        for (int p = 0; p < s.cnt; p++)
        {
            if(s.state[p].piece == piece)
            {
                piecePlayed = true;
                break;
            }
        }
        
        if(piecePlayed) continue;
        
        int fits = 0;
        uint64_t theSpace;
//
//        for (auto space : s.emptySpaces)
//        {
//            int spaceSize = 0;
//            for (int i = 0; i < 54; i++)
//            {
//                if(((space>>i)&1) == 1)
//                    spaceSize++;
//            }
////
//            if(spaceSize != 6) return false;
//
////            if(spaceSize != 6) continue;
//
//            for (int loc = 1; loc <= locations[piece][0]; loc++) {
//                if(locations[piece][loc] == space)
//                {
//                    theSpace = space;
//                    fits++;
//                    break;
//                }
//            }
//        }
        
        
        for (int loc = 1; loc <= locations[piece][0]; loc++)
        {
            if((locations[piece][loc]&s.bits) == 0)
            {
                theSpace = locations[piece][loc];
                fits++;
            }
        }
        
        if(fits == 1)
        {
//            cout<<"\n\n\nThis piece: " << pieceNames[piece] << " can only fit in this space\n" << FancyPrintBoard(theSpace)<<"\n\n";
            return piece;
        }
    }
   
    return -1;
}

void HexagonEnvironment::GetEmptySpaces(HexagonSearchState &s) const
{
    s.emptySpaces.clear();
    uint64_t exploredTriangles = 0, emptySpace = 0, emptyTrianglesAtLevel = 0, emptyTrianglesAtNextLevel = 0, neighbors = 0;
    
    for (int i = 0; i < 54; i++)
    {
        if(((s.bits>>i)&1) == 1 || ((exploredTriangles>>i)&1) == 1)
            continue;
        
        emptySpace = 0;
        
        emptySpace ^= (((uint64_t)1)<<i);
        
        exploredTriangles |= (((uint64_t)1)<<i);
        
        emptyTrianglesAtLevel = GetNeighboringTrianlgesBits(i);

        while(emptyTrianglesAtLevel != 0)
        {
            emptyTrianglesAtNextLevel = 0;
            for (int t = 0; t < 54; t++)
            {
                if(((emptyTrianglesAtLevel>>t)&1) == 0 || t == i || ((s.bits>>t)&1) == 1 || ((exploredTriangles>>t)&1) == 1)
                    continue;

                emptySpace |= (((uint64_t)1)<<t);

                exploredTriangles |= (((uint64_t)1)<<t);

                neighbors = GetNeighboringTrianlgesBits(t);

                for (int child = 0; child < 54; child++)
                {
                    if(((neighbors>>child)&1) == 0 || child == t || ((s.bits>>child)&1) == 1 || ((exploredTriangles>>child)&1) == 1)
                        continue;

                    emptyTrianglesAtNextLevel |= (((uint64_t)1)<<child);
                }
            }
            emptyTrianglesAtLevel = emptyTrianglesAtNextLevel;
        }
        
        // SANITY CHECK
        // check that shape is convex
//
//        int spaceSize = 0;
//        for (int i = 0; i < 54; i++)
//        {
//            if(((emptySpace>>i)&1) == 1)
//                emptySpace++;
//        }
        
//        if(spaceSize > 1)
//        for (int xstep = 0; xstep < 54; xstep++) {
//            if(((emptySpace>>xstep)&1) == 0)
//                continue;
//
//            uint64_t neigh = GetNeighboringTrianlgesBits(xstep);
//            bool found = false;
//            for (int xstep2 = 0; xstep2 < 54; xstep2++) {
//                if(((emptySpace>>xstep2)&1) == 0 || xstep == xstep2)
//                    continue;
//
//                if(((neigh>>xstep2)&1) == 1)
//                {
//                    found = true;
//                    break;
//                }
//            }
//
//            if(!found)
//            {
//                cout<<"FREAKOUT";
//            }
//
//        }
//        if(emptySpace == 671154232)
//        {
//            cout<<"CATCCHHHHH";
//        }
        s.emptySpaces.push_back(emptySpace);
    }
    
}

// 1 .
// 3 ...
// 9 ... ... ...
// 27 ... ... ... ... ... ... ... ... ...
// 54

int leafNum, deadEnds;
vectorCache<HexagonSearchState> succsCache;
//vectorCache<bool> boolCache;
vectorCache<int> intCache;
long expansions;

float HexagonEnvironment::GetEntropy(HexagonSearchState &s, short mode) const
{
    if(GoalTest(s)) // Base case
    {
//        leafNum++;
//        cout<< s.cnt << " reached leaf #" << leafNum << "\n";
        return 0;
    }
        
    vector<HexagonSearchState> &succs = *succsCache.getItem();
    
    vector<HexagonSearchState> &filteredSuccs = *succsCache.getItem();
    
    vector<HexagonSearchState> &tempSucc = *succsCache.getItem();
    
    vector<int> &numItems = *intCache.getItem();
    numItems.resize(pieces.size());
    
    GetSuccessors(s, succs);
    
    uint64_t exists = 0;
    
    bool parentHasOneTrapezoid = false;
    
    for (int i = 0; i < s.cnt; i++)
    {
        if(s.state[i].piece == kTrapezoid)
            parentHasOneTrapezoid = !parentHasOneTrapezoid;
    }

    for (auto &succ : succs)//consider trapezoids separately
    {
        bool firstTrapezoidFound = false;
        for (int i = 0; i < succ.cnt; i++)
        {
            if(succ.state[i].piece != kTrapezoid || (succ.state[i].piece == kTrapezoid && (!parentHasOneTrapezoid || firstTrapezoidFound)))
                exists |= (((uint64_t)1)<<succ.state[i].piece);
            if(succ.state[i].piece == kTrapezoid)
                firstTrapezoidFound = true;
//            cout << succ.state[i].piece << " ";
        }
        
//        cout << "\n";
        
        GetEmptySpaces(succ);
////        cout<< "\n\n\n" << bitset<54>(succ.bits)<<"\n\n";
//        cout << "\n\n\n" << FancyPrintBoard(succ.bits) << "\n\n";
//        for (auto em : succ.emptySpaces)
//        {
////            cout<< bitset<54>(em)<<"\n";
//            cout<< FancyPrintBoard(em) << "\n\n";
//        }
    }

    for (int i = 0; i < pieces.size(); i++)
    {
        if(((exists>>pieces[i])&1) == 0)
        {
//            cout<<"Piece missing: " << pieces[i] <<"\n";
            return INFINITY;
        }
    }

    uint64_t req1 = LocationCanOnlyFitACertainPieceReqRule(s);
    int req2 = PieceCanOnlyGoInOnePlaceReqRule(s);

    if (!(req1 == 0 && req2 == -1))
    {
        for (auto &succ : succs)
        {
            if((req1 != 0 && (succ.bits & req1) == 6) || (req2 != -1 && succ.state[succ.cnt - 1].piece == req2))
            {
                return GetEntropy(succ, mode);
            }
        }
    }
    
    for (const auto &succ : succs)
    {
        if((mode & 0b00100) != 0 && !SizeOfEmtpyRegionRule(succ))
            continue;

        if((mode & 0b010) != 0 && !PiecesAreComposedOfTrapezoidsRule(succ))
            continue;

        if((mode & 0b001) != 0 && !PieceThatFitsTheSpaceIsNotAvailableRule(succ))
            continue;

        numItems[succ.state[succ.cnt - 1].piece]++;
        
//        cout << succ.state[succ.cnt - 1].piece << " " << numItems[succ.state[succ.cnt - 1].piece] << "\n";
        
        tempSucc.push_back(succ);
    }
    
    int minP = 99999, bestP = -1;
    
    for (int i = 0; i < numItems.size(); i++)
    {
        if(numItems[i] < minP && numItems[i] > 0)
        {
            minP = numItems[i];
            bestP = i;
            
//            cout << "found best: " << bestP << " " << minP << "\n";
        }
    }
    
    for (const auto &succ : tempSucc)
    {
        if(succ.state[succ.cnt - 1].piece != bestP)
            continue;
        
        filteredSuccs.push_back(succ);
    }
    
//    cout << "filtered " << tempSucc.size() << " into " << filteredSuccs.size() << " " << bestP << " " << minP << "\n";
    
    succsCache.returnItem(&tempSucc);

    if(filteredSuccs.size() == 0)
    {
//        cout << "dead end\n";
        return INFINITY;
    }
    
    float childEntropy = INFINITY;
    
    int cur = 0;
    
    for (auto &succ : filteredSuccs)
    {
        //ctrl cmd y
        cur++;
        expansions++;
//        if(s.cnt == 2)
//            cout<<"expansions " << expansions << " | " << childEntropy << " ("<<cur<<"/"<<filteredSuccs.size()<<")\n";
        
        childEntropy = min(GetEntropy(succ, mode), childEntropy);
    }
    
    childEntropy += log2(filteredSuccs.size());
    
    succsCache.returnItem(&succs);
    succsCache.returnItem(&filteredSuccs);
    
//    if(childEntropy != INFINITY)
//        cout<<"entropy returned: " << childEntropy << "\n";
    
    return childEntropy;
}

void HexagonEnvironment::GetInferenceActions(const HexagonSearchState &s, vector<HexagonAction> &actions, short mode) const
{
//    all = true;
    vector<HexagonSearchState> &succs = *succsCache.getItem();

    vector<HexagonSearchState> &tempSucc = *succsCache.getItem();

    vector<int> &numItems = *intCache.getItem();
    numItems.resize(pieces.size());

    GetSuccessors(s, succs);
    
//    cout << " || " << succs.size();

//    uint64_t exists = 0;
//
//    bool parentHasOneTrapezoid = false;
//
//    for (int i = 0; i < s.cnt; i++)
//    {
//        if(s.state[i].piece == kTrapezoid)
//            parentHasOneTrapezoid = !parentHasOneTrapezoid;
//    }

    for (auto &succ : succs)//consider trapezoids separately
    {
//        bool firstTrapezoidFound = false;
//        for (int i = 0; i < succ.cnt; i++)
//        {
//            if(succ.state[i].piece != kTrapezoid || (succ.state[i].piece == kTrapezoid && (!parentHasOneTrapezoid || firstTrapezoidFound)))
//                exists |= (((uint64_t)1)<<succ.state[i].piece);
//            if(succ.state[i].piece == kTrapezoid)
//                firstTrapezoidFound = true;
//        }

        GetEmptySpaces(succ);
    }

//    for (int i = 0; i < pieces.size(); i++)
//    {
//        if(((exists>>pieces[i])&1) == 0)
//        {
////            cout << "\n piece not found: " << pieces[i] << "\n";
////            return;
//        }
//    }

    uint64_t req1 = LocationCanOnlyFitACertainPieceReqRule(s);
    int req2 = PieceCanOnlyGoInOnePlaceReqRule(s);

    if (!(req1 == 0 && req2 == -1))
    {
        for (auto &succ : succs)
        {
            if((req1 != 0 && (succ.bits & req1) == 6) || (req2 != -1 && succ.state[succ.cnt - 1].piece == req2))
            {
                actions.push_back({succ.state[succ.cnt - 1].piece, succ.state[succ.cnt - 1].location});
//                cout << "one action___";
                return;
            }
        }
    }

    for (const auto &succ : succs)
    {
        if((mode & 0b100) != 0 && !SizeOfEmtpyRegionRule(succ))
            continue;

        if((mode & 0b010) != 0 && !PiecesAreComposedOfTrapezoidsRule(succ))
            continue;

        if((mode & 0b001) != 0 && !PieceThatFitsTheSpaceIsNotAvailableRule(succ))
            continue;

        numItems[succ.state[succ.cnt - 1].piece]++;

        tempSucc.push_back(succ);
    }

    int minP = 99999, bestP = -1;

    for (int i = 0; i < numItems.size(); i++)
    {
        if(numItems[i] < minP && numItems[i] > 0)
        {
            minP = numItems[i];
            bestP = i;
        }
    }

    for (const auto &succ : tempSucc)
    {
        if(succ.state[succ.cnt - 1].piece != bestP)
            continue;

        actions.push_back({succ.state[succ.cnt - 1].piece, succ.state[succ.cnt - 1].location});
//        cout << "adding action " << actions.size();
    }

    succsCache.returnItem(&tempSucc);
}

/** Prints out the triangles used for this piece in HOG2 coordinates */
void HexagonEnvironment::GeneratePieceCoordinates(tPieceName p)
{
	// 1. Start with environment with only one piece type
//	HexagonEnvironment e;
	vector<tPieceName> v;
	v.push_back(p);
	/*e.*/SetPieces(v);
	
	// 2. Get legal actions
	vector<HexagonSearchState> succ;
	HexagonSearchState s;
    /*e.*/GetSuccessors(s, succ);

	// 3. Place the piece on the board
	s = succ[0];
	
	assert(s.cnt == 1); // should only be 1 piece on the board
	
	uint64_t state = s.bits;
	
	cout << pieceNames[p] << "\t";
//	// count how many objects we have
	int count = 0;
	for (int t = 0; t < 54; t++)
	{
		if (((state>>t)&1) == 1)
		{
			count++;
		}
	}
    
    int pp1 = comb % 4, pp2 = comb / 4;
    if(pp1 == pp2) pp2 = 3;
    
    pp1+=4; pp2+=4;
    
    //int noFlipMoveCount[numPieces] =
    //{
    ////    kHexagon = 0, 2/c
    ////    kButterfly = 1, 1/b
    ////    kElbow = 2, 7/h
    ////    kLine = 3, 6/g
    ////    kMountains = 4, 3/d
    ////    kWrench = 5, 5/f
    ////    kTriangle = 6, 4/e
    ////    kHook = 7, 0/a
    ////    kTrapezoid = 8, 8/i 9/j
    ////    kSnake = 9
    //};

    
    int piece = s.state[0].piece;
    int loc = s.state[0].location;
    
    cout << count << "\n";//piece

    uint64_t pattern = goldenPattern;
    uint64_t div = 1;

    for (int j = 0; j < piece; j++) {
        div *= numPatternsForPiece[j];
    }

    int x = (pattern / div) % numPatternsForPiece[piece];
    int x1, x2;

    if(numPatternsForPiece[piece] == 1)
    {
        x1 = x2 = 0;
    }
    else if(piece == 3 || piece == 9)
    {
        // flip odd, even, no constraint
        // rot: one side fits and not the other, or neither
        x1 = x % 2 == 0 ? 0 : 3;
        x2 = x / 2 == 0 ? 0 : 3;
    }
    else
    {
        if(numPatternsForPiece[piece] == 3)
        {
            x1 = x2 = x;
        }
        else
        {
            if(pp1 == piece || pp2 == piece)
            {
                // no - o/e
                x1 = x < 2 ? (x+1) : 3;
                x2 = x > 1 ? (x-1) : 3;
            }
            else
            {
                // o/e e/o
                x1 = (x / 2) + 1;
                x2 = (x % 2) + 1;
            }
        }
    }
    
//    cout << "x: " << x << " x1: " << x1 << " x2: " << x2  << " pp1: " << pp1 << " pp2: " << pp2 << "\n";
//
//    cout << "G O: " << bitset<54>(state) << "\n";
//    cout << "G 0: " << bitset<54>(localized_holes_side1_odd[piece][1][1]) << "\n";
//    cout << "G 1: " << bitset<54>(localized_holes_side1_even[piece][1][1]) << "\n";
//    cout << "G 2: " << bitset<54>(localized_holes_side2_odd[piece][1][1]) << "\n";
//    cout << "G 3: " << bitset<54>(localized_holes_side2_even[piece][1][1]) << "\n";
    
    cout << "\n\n" << x ;
    cout << "\n\n" << FancyPrintBoard(state,localized_holes_side1_odd[piece][1][1]) << "\n\n";
    cout << "\n\n" << FancyPrintBoard(state,localized_holes_side1_even[piece][1][1]) << "\n\n";
//    cout << "\n\n" << FancyPrintBoard(localized_holes_side1_odd[piece][1][1]) << "\n\n";
//    cout << "\n\n" << FancyPrintBoard(localized_holes_side1_even[piece][1][1]) << "\n\n";
//    cout << "\n\n" << FancyPrintBoard(localized_holes_side2_odd[piece][1][1]) << "\n\n";
//    cout << "\n\n" << FancyPrintBoard(localized_holes_side2_even[piece][1][1]) << "\n\n";
    
	// drawing doesn't have to be so fast! (compared to enumeration operations)
    //
	for (int t = 0; t < 54; t++)
	{
		if (((state>>t)&1) == 1)
		{
			int xx, y;
			Graphics::point p1, p2, p3;
			IndexToXY(t, xx, y);
			GetCorners(xx, y, p1, p2, p3);
			
			cout.precision(20);
			cout << fixed;

			cout << " " << p1 << " " << p2 << " " << p3 << "\t";

            
            bool side1 = x1 == 0 || (x1 == 1 && ((localized_holes_side1_odd[piece][1][1]>>t)&1) == 1) || (x1 == 2 && ((localized_holes_side1_even[piece][1][1]>>t)&1) == 1);
            bool side2 = x2 == 0 || (x2 == 1 && ((localized_holes_side1_odd[piece][1][1]>t)&1) == 1) || (x2 == 2 && ((localized_holes_side1_even[piece][1][1]>>t)&1) == 1);

            int type = (side1 ? 1 : 0) + (side2 ? 2 : 0);
            
            // 0: none
            // 1: side 1 only
            // 2: side 2 only
            // 3: both
            
//            cout << "\n" << ((localized_holes_side1_odd[piece][1][1]>>t)&1) << " " << ((localized_holes_side1_even[piece][1][1]>>t)&1) << " "<<  type << "\n";
            
            cout <<  type << "\t";
            
            // 0: full
            // 1: odd-odd or even-even //flip
            // 2: full-none or none-full //rot
            // 3: none-odd or none-even //g1
            // 4: odd-even or even-odd //g2
            
		}
	}
	cout << "\n";
}

/** Prints out the outer coorsinates of the board */
void HexagonEnvironment::GenerateBoardBorder()
{
	// 1. Start with environment with only one piece type
//	HexagonEnvironment e;
    
    uint64_t dots = BitsFromArray({1,3,5,8,10,12,14,17,19,21,23,25,27,29,31,33,35,37,38,40,42,44,46,47,49,51,53});
    
    cout << "\n\n" << FancyPrintBoard((((1ull)<<54)-1), dots) << "\n\n";
	
	cout << "Board\t";
//	// count how many objects we have
	int count = 54;
	cout << count << "\n";
	// drawing doesn't have to be so fast! (compared to enumeration operations)
	for (int t = 0; t < 54; t++)
	{
		int x, y;
		Graphics::point p1, p2, p3;
		IndexToXY(t, x, y);
		GetCorners(x, y, p1, p2, p3);
		
		cout.precision(20);
		cout << fixed;
		
		cout << " " << p1 << " " << p2 << " " << p3 << "\t";
        
        cout << (((dots>>t)&1) == 1 ? 1 : 0) << "\t";
	}
	cout << "\n";
}

void HexagonEnvironment::Draw(Graphics::Display &display) const
{
	
}

/** Draws available pieces and constraints */
void HexagonEnvironment::DrawSetup(Graphics::Display &display) const
{
	hex.DrawSetup(display);
}

void HexagonEnvironment::Draw(Graphics::Display &display, const HexagonSearchState &s) const
{
    return;
	display.FillSquare({0,0}, 1.0, Colors::white);
	for (int t = 0; t < 54; t++)
	{
		int x, y;
		Graphics::point p1, p2, p3;
		IndexToXY(t, x, y);
		GetCorners(x, y, p1, p2, p3);
		display.FillTriangle(p1, p2, p3, Colors::lightgray);
	}

	HexagonSearchState tmp;
	for (int i = 0; i < s.cnt; i++)
	{
		tmp.Reset();
		ApplyAction(tmp, s.state[i]);
		uint64_t state = tmp.bits;

		// drawing doesn't have to be so fast! (compared to enumeration operations)
		for (int t = 0; t < 54; t++)
		{
			if (((state>>t)&1) == 1)
			{
				int x, y;
				Graphics::point p1, p2, p3;
				IndexToXY(t, x, y);
				GetCorners(x, y, p1, p2, p3);
				display.FillTriangle(p1, p2, p3, rgbColor::hsl((float)i/12, (i%2)?0.75f:0.25f, 0.5f));
			}
		}
	}
}

void HexagonEnvironment::IndexToXY(int index, int &x, int &y)  const
{
	switch (index)
	{
		case 0: x = 2; y = 0; return;
		case 1: x = 3; y = 0; return;
		case 2: x = 4; y = 0; return;
		case 3: x = 5; y = 0; return;
		case 4: x = 6; y = 0; return;
		case 5: x = 7; y = 0; return;
		case 6: x = 8; y = 0; return;

		case 7: x = 1; y = 1; return;
		case 8: x = 2; y = 1; return;
		case 9: x = 3; y = 1; return;
		case 10: x = 4; y = 1; return;
		case 11: x = 5; y = 1; return;
		case 12: x = 6; y = 1; return;
		case 13: x = 7; y = 1; return;
		case 14: x = 8; y = 1; return;
		case 15: x = 9; y = 1; return;

		case 16: x = 0; y = 2; return;
		case 17: x = 1; y = 2; return;
		case 18: x = 2; y = 2; return;
		case 19: x = 3; y = 2; return;
		case 20: x = 4; y = 2; return;
		case 21: x = 5; y = 2; return;
		case 22: x = 6; y = 2; return;
		case 23: x = 7; y = 2; return;
		case 24: x = 8; y = 2; return;
		case 25: x = 9; y = 2; return;
		case 26: x = 10; y = 2; return;

		case 27: x = 0; y = 3; return;
		case 28: x = 1; y = 3; return;
		case 29: x = 2; y = 3; return;
		case 30: x = 3; y = 3; return;
		case 31: x = 4; y = 3; return;
		case 32: x = 5; y = 3; return;
		case 33: x = 6; y = 3; return;
		case 34: x = 7; y = 3; return;
		case 35: x = 8; y = 3; return;
		case 36: x = 9; y = 3; return;
		case 37: x = 10; y = 3; return;

		case 38: x = 1; y = 4; return;
		case 39: x = 2; y = 4; return;
		case 40: x = 3; y = 4; return;
		case 41: x = 4; y = 4; return;
		case 42: x = 5; y = 4; return;
		case 43: x = 6; y = 4; return;
		case 44: x = 7; y = 4; return;
		case 45: x = 8; y = 4; return;
		case 46: x = 9; y = 4; return;

		case 47: x = 2; y = 5; return;
		case 48: x = 3; y = 5; return;
		case 49: x = 4; y = 5; return;
		case 50: x = 5; y = 5; return;
		case 51: x = 6; y = 5; return;
		case 52: x = 7; y = 5; return;
		case 53: x = 8; y = 5; return;
	}
	x=-1;y=-1;
}


void HexagonEnvironment::GetCorners(int x, int y, Graphics::point &p1, Graphics::point &p2, Graphics::point &p3) const
{
	return hex.GetCorners(x, y, p1, p2, p3);
}

bool HexagonEnvironment::GetBorder(int x, int y, int xoff, int yoff, Graphics::point &p1, Graphics::point &p2) const
{
	return hex.GetBorder(x, y, xoff, yoff, p1, p2);
}

bool HexagonEnvironment::Valid(int x, int y) const
{
	return hex.Valid(x, y);
}

//vector<rgbColor> pieceColors;

#pragma mark -
#pragma mark Hexagon Display Code
#pragma mark -


Hexagon::Hexagon()
{
	
}
Hexagon::~Hexagon()
{
	
}

void Hexagon::LoadSolution(const char *file, HexagonState &s)
{
	Load(file, s, true);
}

void Hexagon::LoadPuzzle(const char *file, HexagonState &s)
{
	Load(file, s, false);
}

void Hexagon::Load(const char *file, HexagonState &s, bool solution)
{
    s.state.FillMax();
	this->solution.state.FillMax();
	FILE *f = fopen(file, "r");
	if (f == 0)
	{
		printf("Error opening file for rea\n");
		return;
	}
	int h, w;
	fscanf(f, "type triangle\n");
	int cnt = fscanf(f, "height %d\nwidth %d\nmap\n", &h, &w);
	if (cnt != 2)
	{
		printf("Error reading height/width from file\n");
		return;
	}
	if (h != 6 || w != 11)
	{
		printf("Invalid height/width from file. Requires 6/11.\n");
		return;
	}
	// read constraints (if any)
	char buffer[255];
	fgets(buffer, 255, f);
	if (strncmp("Constraint:", buffer, 11) != 0)
	{
		printf("Error: expected 'Constraint:'\n");
		return;
	}
	char *tmp;
	
	// must touch diagonally
    tmp = strcasestr(buffer, "Diag");
    if (tmp != NULL)
    {
        diagPieces.resize(3);
        sscanf(&tmp[5], "%d %d %d", &diagPieces[0], &diagPieces[1], &diagPieces[2]);
    }
    
    tmp = strcasestr(buffer, "NotDiag");
    if (tmp != NULL)
    {
        notDiagPieces.resize(3);
        sscanf(&tmp[5], "%d %d %d", &notDiagPieces[0], &notDiagPieces[1], &notDiagPieces[2]);// check this 5
    }
	
	tmp = strcasestr(buffer, "NoFlip");

	if (tmp != NULL)
	{
		noFlipPieces.resize(3);
		sscanf(&tmp[7], "%d %d %d", &noFlipPieces[0], &noFlipPieces[1], &noFlipPieces[2]);
	}

	tmp = strcasestr(buffer, "NotTouch");

	if (tmp != NULL)
	{
		notTouchPieces.resize(3);
		sscanf(&tmp[9], "%d %d %d", &notTouchPieces[0], &notTouchPieces[1], &notTouchPieces[2]);
	}

	tmp = strcasestr(buffer, " Touch"); // Add space -- otherwise matches NotTouch

	if (tmp != NULL)
	{
		touchPieces.resize(3);
		sscanf(&tmp[7], "%d %d %d", &touchPieces[0], &touchPieces[1], &touchPieces[2]);
	}
	
	for (int x = 0; x < 66; x++)
	{
		char c = fgetc(f);
		while (isspace(c))
			c = fgetc(f);
		if (c == 'x')
		{
			s.state.Set(x, -1);
			this->solution.state.Set(x, -1);
		}
		else if (isalpha(c))
		{
			this->solution.state.Set(x, tolower(c)-'a');
			if (solution)
			{
				s.state.Set(x, tolower(c)-'a');
			}
			else {
				s.state.Set(x, 11);
			}
		}
		else if (isdigit(c))
		{
			this->solution.state.Set(x, tolower(c)-'0');
			s.state.Set(x, tolower(c)-'0');
		}
	}
	fclose(f);
//	this->solution = s;
	
	// Get all of the colors
	for (int y = 0; y < 6; y++)
	{
		for (int x = 0; x < 11; x++)
		{
			if (!Valid(x, y))
				continue;
			int piece = this->solution.state.Get(y*11+x);
			if (piece > pieceColors.size())
				pieceColors.resize(piece+1);
			pieceColors[piece] = rgbColor::hsl((piece)/11.0, (piece%2)?1.0:0.5, 0.5);
		}
	}
    for (auto i : diagPieces)
        pieceColors[i] = rgbColor::hsl((diagPieces[0])/11.0, (diagPieces[0]%2)?1.0:0.5, 0.5);
    for (auto i : notDiagPieces)
        pieceColors[i] = rgbColor::hsl((notDiagPieces[0])/11.0, (notDiagPieces[0]%2)?1.0:0.5, 0.5);
	for (auto i : noFlipPieces)
		pieceColors[i] = rgbColor::hsl((noFlipPieces[0])/11.0, (noFlipPieces[0]%2)?1.0:0.5, 0.5);
	for (auto i : touchPieces)
		pieceColors[i] = rgbColor::hsl((touchPieces[0])/11.0, (touchPieces[0]%2)?1.0:0.5, 0.5);
	for (auto i : notTouchPieces)
		pieceColors[i] = rgbColor::hsl((notTouchPieces[0])/11.0, (notTouchPieces[0]%2)?1.0:0.5, 0.5);
}

//
//void HexagonEnvironment::ConvertToSearchState(){
//
//}


HexagonSearchState HexagonEnvironment::GetInitState(HexagonSearchState &hss, vector<int> *addedInitPieces)
{
    vector<int> initPieces;
    
    HexagonSearchState init;
    init.index = hss.index;
    init.constraints = hss.constraints;
    init.dots = hss.dots;
    
    for (int x = 0; x < 10; x++)
    {
        int p = hss.initState / pow(11, x);
        p %= 11;
        p--;
        if(p!=-1)
            initPieces.push_back(p);
    }
    
    if(addedInitPieces != nullptr)
        for(auto i : *addedInitPieces)
        {
            initPieces.push_back(i);
        }
    
    init.cnt = initPieces.size();
    
    for (int i = 0; i < initPieces.size(); i++) {
        init.state[i].piece = hss.state[initPieces[i]].piece;
        init.state[i].location = hss.state[initPieces[i]].location;
        init.bits ^= locations[hss.state[initPieces[i]].piece][hss.state[initPieces[i]].location];
    }
    
    return init;
}

void HexagonEnvironment::AddPiecesToInitState(HexagonSearchState &hss, int pieces, bool chooseEasiest)
{
    int startingInitState = hss.initState;
    float origEntropy = hss.entropy;
    vector<int> initPieces, addedInitPieces;

    if(hss.initState != -1)
    {
        for (int x = 0; x < 10; x++)
        {
            int p = hss.initState / pow(11, x);
            p %= 11;
            p--;
            if(p!=-1)
                initPieces.push_back(p);//hss.state[p].piece);
        }
    }
    
    float maxEntropy, minEntropy;

    while(pieces > 0)
    {
        pieces--;
        maxEntropy = -INFINITY; minEntropy = INFINITY;
        int bestPiece = -1;

        for (int i = 0; i < hss.cnt; i++)
        {
            if(find(initPieces.begin(), initPieces.end(), i) != initPieces.end())
                continue;
                        
            if(find(addedInitPieces.begin(), addedInitPieces.end(), i) != addedInitPieces.end())
                continue;
            
            addedInitPieces.push_back(i);
            
            auto newInit = GetInitState(hss, &addedInitPieces);
            
            addedInitPieces.pop_back();
            
            float newEntropy = GetEntropy(newInit);
            
            if(newEntropy > maxEntropy && !chooseEasiest)
            {
                maxEntropy = newEntropy;
                bestPiece = i;
            }
            else if(newEntropy < minEntropy && chooseEasiest)
            {
                minEntropy = newEntropy;
                bestPiece = i;
            }
        }
        
//        cout << "best piece to be added is " << bestPiece << " | " << hss.state[bestPiece].piece << " | " <<pieceNames[hss.state[bestPiece].piece] << " to init state" << "\n";

        addedInitPieces.push_back(bestPiece);
    }
    
    hss.addedInitPieces = addedInitPieces;
    hss.entropyWithAddedPieces = chooseEasiest ? minEntropy : maxEntropy;
}


void HexagonEnvironment::ConvertToHexagonState(HexagonSearchState &hss, HexagonState &hs, bool fill){
    int trapizodeLocs = 0;
    hs.constraints = hss.constraints;
    hs.dots = hss.dots;
    
    vector<int> initPieces;

    if(hss.initState != -1)
    {
        for (int x = 0; x < 10; x++)
        {
            int p = hss.initState / pow(11, x);
            p %= 11;
            p--;
            if(p!=-1)
                initPieces.push_back(p);//hss.state[p].piece);
        }
    }
    
    for(auto i : hss.addedInitPieces)
    {
//        cout << "added " << i << " | " << hss.state[i].piece << " | " <<pieceNames[hss.state[i].piece] << " to init state" << "\n";

        initPieces.push_back(i);
    }
    
    for (int u = 0; u < 66; u++) {
        hs.state.Set(u, 11);
    }
    
    hs.state.Set(0, -1);
    hs.state.Set(1, -1);
    hs.state.Set(9, -1);
    hs.state.Set(10, -1);
    hs.state.Set(11, -1);
    hs.state.Set(21, -1);

    hs.state.Set(65, -1);
    hs.state.Set(64, -1);
    hs.state.Set(56, -1);
    hs.state.Set(55, -1);
    hs.state.Set(54, -1);
    hs.state.Set(44, -1);
    
    for(int x = 0; x < hss.cnt; x++)
    {
        /*
         
         xxhhhhcccxx
         xhhe66cccbx
         ddeee66bbbb
         ddd5ee66bjj
         xdi55aaaajx
         xxii555aaxx
         
         */
        
        int piece = hss.state[x].piece;
        int location = hss.state[x].location;
        uint64_t loc = locations[piece][location];//[hss.state[x].piece, hss.state[x].location];
        
        if(!fill && hss.initState != -1 && (find(initPieces.begin(), initPieces.end(), x) == initPieces.end()))
            continue;
        
//        cout << "RESIZING COLORS " << pieceColors.size();
//        if (piece > pieceColors.size())
//            pieceColors.resize(piece+1);
//        pieceColors[piece] = rgbColor::hsl((piece)/11.0, (piece%2)?1.0:0.5, 0.5);
        
//        cout << "RESIZING COLORS END " << pieceColors.size();
        
        
//        cout << hss.state[x].piece << " " << hss.state[x].location<< " " << loc << '\n';

        
        for (int t = 0; t < 66; t++)// goes to 66 for hss!
        {
//            uint64_t fixedLoc = loc + 2 + (loc > 300 ? 3 : 0) + (loc > 400 ? 1 : 0) + (loc > 500 ? 3 : 0);
            
            int fixedT = (t == 0 || t == 1 || t == 9 || t == 10 || t == 11 || t == 21 || t == 65 || t == 64 || t == 56 || t == 55 || t == 54 || t == 44) ? -1 : (t / 11 == 0 ? (t-2) : (t / 11 == 1 ? (t-5) : (t / 11 == 2 || t / 11 == 3 ? (t-6) : (t / 11 == 4 ? (t-7) : (t-10)))));
            
            if(fixedT < 0) continue;
            
            if ((loc>>fixedT)&1)
            {
                int mappedPiece = mapPiece[piece];
                if(mappedPiece == 8) trapizodeLocs++;
                hs.state.Set(t, mappedPiece == 8 && trapizodeLocs > 3 ? 10 : mappedPiece);

//                int x1, y1;
//                IndexToXY(t, x1, y1);
                
//                printf("%d : %d => %d\n", t, fixedT, mapPiece[piece]);
//                flip_loc |= (one<<flipTable[x]);
            }
        }
        
    }
    
//    printf("trapizode locs: %s \n", trapizodeLocs);

}

void HexagonEnvironment::BuildLocationTable()
{
    //    uint64_t newLocations[numPieces][14*6*2+1];
    uint64_t one = 1;
    bool V = false;
    
    for(int piece = 0; piece < numPieces; piece++)
    {
        vector<uint64_t> locs;
        
        uint64_t loc_orig = locations_orig[piece][1];//loop through rotations and flips
        
        
        for (int flip = 0; flip < 2; flip++)
        {
            uint64_t flip_loc = flip == 1 ? 0 : loc_orig;
            
            if(flip == 1)
            {
                for (int x = 0; x < 54; x++) // simple and dumb
                {
                    if ((loc_orig>>x)&1)
                    {
                        flip_loc |= (one<<flipTable[x]);
                    }
                }
            }
            
            for (int rots = 0; rots < 6; rots++)
            {
                uint64_t loc = flip_loc;//rots == 0 ? flip_loc : 0;
                
                for(int rot = 0; rot < rots; rot++)
                {
                    uint64_t rot_loc = 0;
                    for (int x = 0; x < 54; x++) // simple and dumb
                    {
                        if ((loc>>x)&1)
                        {
                            rot_loc |= (one<<rotateCWTable[x]);
                        }
                    }
                    loc = rot_loc;
                }
                
                vector<int> b;
                
                for (int t = 0; t < 54; t++)
                {
                    if ((loc>>t)&1)
                    {
                        b.push_back(t);
                    }
                }
                
                int size = b.size();//sizeof(b)/sizeof(*b);
                
                if(V)
                {
                    cout << "(";
                    for(int p = 0; p < size; p++)
                    {printf("%d", b[p]);if(p<(size-1))cout << ", ";}
                    cout << ")\n";
                }
                
                int bits[size][2];
                
                for(int p = 0; p < size; p++)
                {
                    int loc = b[p];
                    loc += loc < 7 ? 2 : (loc < 16 ? 5 : (loc < 38 ? 6 : (loc < 47 ? 7 : 10)));
                    
                    bits[p][0] = loc % 11;
                    bits[p][1] = loc / 11;
                }
                
                if(V)
                {
                    cout << "(";
                    for(int p = 0; p < size; p++)
                    {printf("(%d,%d)", bits[p][0],bits[p][1]);if(p<(size-1))cout << ", ";}
                    cout << ")\n\n";
                }
                
                for (int y = -6; y < 6; y++)
                {
                    for (int x = -10; x < 10; x++)
                    {
                        if(((bits[0][0]+x)+11*(bits[0][1]+y))%2 != (bits[0][0]+11*bits[0][1])%2)
                            continue;
                        
                        int bits2[size][2];
                        
                        for(int p = 0; p < size; p++)// can be moved down
                        {
                            bits2[p][0] = bits[p][0] + x;
                            bits2[p][1] = bits[p][1] + y;
                        }
                        
                        bool valid = true;
                        
                        int bitsr[size];
                        uint64_t location = 0;
                        
                        for(int p = 0; p < size; p++)
                        {
                            if((bits2[p][0] < 2 && bits2[p][1] % 5 == 0) ||
                               (bits2[p][0] < 1 && (bits2[p][1]-1) % 3 == 0) ||
                               (bits2[p][0] > 8 && bits2[p][1] % 5 == 0) ||
                               (bits2[p][0] > 9 && (bits2[p][1]-1) % 3 == 0) ||
                               bits2[p][0] > 10 || bits2[p][0] < 0 || bits2[p][1] > 5 || bits2[p][1] < 0)
                            {
                                valid = false;
                                break;
                            }
                            
                            int bit = bits2[p][0] + 11*bits2[p][1];
                            bit -= bits2[p][1] == 0 ? 2 : (bits2[p][1] == 1 ? 5 : (bits2[p][1] == 2 || bits2[p][1] == 3 ? 6 : (bits2[p][1] == 4 ? 7 : 10)));
                            
                            bitsr[p] = bit;
                            
                            location |= (one<<bit);
                        }
                        
                        if(!valid)
                            continue;
                        
                        if (find(locs.begin(), locs.end(), location) == locs.end())
                            locs.push_back(location);
                        
                        if(V)
                        {
                            cout << "(";
                            for(int p = 0; p < size; p++)
                            {printf("%d", bitsr[p]);if(p<(size-1))cout << ", ";}
                            cout << ")\n";
                        }
                        
                        //                        vector<int> b2;
                        //
                        //                        for (int t = 0; t < 54; t++)
                        //                        {
                        //                            if ((location>>t)&1)
                        //                            {
                        //                                b2.push_back(t);
                        //                            }
                        //                        }
                        //
                        //                        int size2 = b2.size();//sizeof(b)/sizeof(*b);
                        //
                        //                        if(true)
                        //                        {
                        //                            cout << "(";
                        //                            for(int p = 0; p < size2; p++)
                        //                            {printf("%d", b2[p]);if(p<(size2-1))cout << ", ";}
                        //                            cout << ")\n";
                        //                        }
                    }
                }
            }
            
            if(flip == 0)
                noFlipMoveCount[piece] = locs.size();
        }
        
        locations[piece][0] = locs.size();
        
        for(int loc = 0; loc < locs.size(); loc++)
        {
            locations[piece][1+loc] = locs[loc];
            vector<int> b;
            
            for (int t = 0; t < 54; t++)
            {
                if ((locations[piece][1+loc]>>t)&1)
                {
                    b.push_back(t);
                }
            }
            
            int size = b.size();//sizeof(b)/sizeof(*b);
            
            if(printLocTables)
            {
                cout << "["<<(loc+1)<<"] (";
                for(int p = 0; p < size; p++)
                {printf("%d", b[p]);if(p<(size-1))cout << ", ";}
                cout << ")\n";
            }
        }
        
        cout<< pieceNames[piece] << " " << locs.size() << "\n";
        
        //        vector<int> b;
        //
        //        for (int t = 0; t < 54; t++)
        //        {
        //            if ((locations[0][10]>>t)&1)
        //            {
        //                b.push_back(t);
        //            }
        //        }
        //
        //        int size = b.size();//sizeof(b)/sizeof(*b);
        //
        //        if(true)
        //        {
        //            cout << "+++ (";
        //            for(int p = 0; p < size; p++)
        //            {printf("%d", b[p]);if(p<(size-1))cout << ", ";}
        //            cout << ")\n";
        //        }
        if(printLocTables)
            cout << "\n\n";
    }
    
//    exit(1);//TODOXXX
}

    
    void HexagonEnvironment::BuildHolesTable()
    {
    //    uint64_t newLocations[numPieces][14*6*2+1];
        uint64_t one = 1;
        bool V = false;
        int hole_locs_size;

        for(int piece = 0; piece < numPieces; piece++)
        {
            uint64_t loc_orig = locations_orig[piece][1];//loop through rotations and flips
//            uint64_t hole_loc_orig = hole_locations_orig[piece][1];//loop through rotations and flips
// print when adding
            for (int even = 0; even < 2; even ++)
            {
                uint64_t hole_loc_orig = even == 1 ? hole_locations_orig[piece][2]: hole_locations_orig[piece][1];

                for (int flip = 0; flip < 2; flip++)//TODO check flips
                {
                    vector<uint64_t> locs;
                    vector<vector<uint64_t>> hole_locs;
                    
                    uint64_t flip_loc = flip == 1 ? 0 : loc_orig;
                    uint64_t hole_flip_loc = flip == 1 ? 0 : hole_loc_orig;
                    
                    if(flip == 1)
                    {
                        for (int x = 0; x < 54; x++) // simple and dumb
                        {
                            if ((loc_orig>>x)&1)
                            {
                                flip_loc |= (one<<flipTable[x]);
                            }
                            
                            if ((hole_loc_orig>>x)&1)
                            {
                                hole_flip_loc |= (one<<flipTable[x]);
                            }
                        }
                        //hole flip normally? (confirm)
                    }
                    
                    
                    //                if(flip_loc != hole_flip_loc)
                    //                {
                    //
                    //                    cout << "R 0: " << bitset<54>(flip_loc) << "\n";
                    //                    cout << "R 1: " << bitset<54>(hole_flip_loc) << "\n";
                    //
                    //                }
                    
                    for (int rots = 0; rots < 6; rots++)
                    {
                        uint64_t loc = flip_loc;//rots == 0 ? flip_loc : 0;
                        uint64_t hole_loc = hole_flip_loc;//rots == 0 ? flip_loc : 0;
                        
                        for(int rot = 0; rot < rots; rot++)
                        {
                            uint64_t rot_loc = 0;
                            uint64_t hole_rot_loc = 0;
                            
                            for (int x = 0; x < 54; x++) // simple and dumb
                            {
                                if ((loc>>x)&1)
                                {
                                    rot_loc |= (one<<rotateCWTable[x]);
                                }
                                if ((hole_loc>>x)&1)
                                {
                                    hole_rot_loc |= (one<<rotateCWTable[x]);
                                }
                            }
                            loc = rot_loc;
                            hole_loc = hole_rot_loc;
                            
                            //hole rot normally? (confirm)
                        }
                        
                        
                        //                    if(loc != hole_loc)
                        //                    {
                        //
                        //                        cout << "R 0: " << bitset<54>(loc) << "\n";
                        //                        cout << "R 1: " << bitset<54>(hole_loc) << "\n";
                        //
                        //                    }
                        
                        vector<int> b;
                        vector<int> hole_b;
                        
                        for (int t = 0; t < 54; t++)
                        {
                            if ((loc>>t)&1)
                            {
                                b.push_back(t);
                            }
                            if ((hole_loc>>t)&1)
                            {
                                hole_b.push_back(t);
                            }
                        }
                        
                        int size = b.size();//sizeof(b)/sizeof(*b);
                        int hole_size = hole_b.size();//sizeof(b)/sizeof(*b);
                        
                        if(V)
                        {
                            cout << "(";
                            for(int p = 0; p < size; p++)
                            {printf("%d", b[p]);if(p<(size-1))cout << ", ";}
                            cout << ")\n";
                        }
                        
                        int bits[size][2], hole_bits[hole_size][2];
                        
                        for(int p = 0; p < size; p++)
                        {
                            int loc = b[p];
                            loc += loc < 7 ? 2 : (loc < 16 ? 5 : (loc < 38 ? 6 : (loc < 47 ? 7 : 10)));
                            
                            bits[p][0] = loc % 11;
                            bits[p][1] = loc / 11;
                        }
                        
                        for(int p = 0; p < hole_size; p++)
                        {
                            int loc = hole_b[p];
                            loc += loc < 7 ? 2 : (loc < 16 ? 5 : (loc < 38 ? 6 : (loc < 47 ? 7 : 10)));
                            
                            hole_bits[p][0] = loc % 11;
                            hole_bits[p][1] = loc / 11;
                        }
                        
//                        for(int p = 0; p < hole_size; p++)
//                        {
//                            if(b[p] != hole_b[p])// || bits[p][0] != hole_bits[p][0])
//                            {
//                                cout << b[p] << " " << hole_b[p] << "CATCH";
//                                
//                            }
//                        }
                        if(V)
                        {
                            cout << "(";
                            for(int p = 0; p < size; p++)
                            {printf("(%d,%d)", bits[p][0],bits[p][1]);if(p<(size-1))cout << ", ";}
                            cout << ")\n\n";
                        }
                        
                        for (int y = -6; y < 6; y++)
                        {
                            for (int x = -10; x < 10; x++)
                            {
                                if(((bits[0][0]+x)+11*(bits[0][1]+y))%2 != (bits[0][0]+11*bits[0][1])%2)
                                    continue;
                                
                                int bits2[size][2], hole_bits2[hole_size][2];
                                
                                for(int p = 0; p < size; p++)// can be moved down
                                {
                                    bits2[p][0] = bits[p][0] + x;
                                    bits2[p][1] = bits[p][1] + y;
                                    
                                    //peform same movement for hole bits
                                }
                                
                                for(int p = 0; p < hole_size; p++)// can be moved down
                                {
                                    hole_bits2[p][0] = hole_bits[p][0] + x;
                                    hole_bits2[p][1] = hole_bits[p][1] + y;
                                    
                                    //peform same movement for hole bits
                                }
                                
                                bool valid = true;
                                
                                //                            int bitsr[size], hole_bitsr[hole_size];
                                uint64_t location = 0;
                                uint64_t hole_location = 0;
                                
                                for(int p = 0; p < size; p++)
                                {
                                    if((bits2[p][0] < 2 && bits2[p][1] % 5 == 0) ||
                                       (bits2[p][0] < 1 && (bits2[p][1]-1) % 3 == 0) ||
                                       (bits2[p][0] > 8 && bits2[p][1] % 5 == 0) ||
                                       (bits2[p][0] > 9 && (bits2[p][1]-1) % 3 == 0) ||
                                       bits2[p][0] > 10 || bits2[p][0] < 0 || bits2[p][1] > 5 || bits2[p][1] < 0)
                                    {
                                        valid = false;
                                        break;
                                    }
                                    
                                    //                                int bit = bits2[p][0] + 11*bits2[p][1];
                                    //                                bit -= bits2[p][1] == 0 ? 2 : (bits2[p][1] == 1 ? 5 : (bits2[p][1] == 2 || bits2[p][1] == 3 ? 6 : (bits2[p][1] == 4 ? 7 : 10)));
                                    //
                                }
                                
                                if(!valid)
                                    continue;
                                
                                for (int p = 0; p < hole_size; p++) {
                                    int hole_bit = hole_bits2[p][0] + 11*hole_bits2[p][1];
                                    hole_bit -= hole_bits2[p][1] == 0 ? 2 : (hole_bits2[p][1] == 1 ? 5 : (hole_bits2[p][1] == 2 || hole_bits2[p][1] == 3 ? 6 : (hole_bits2[p][1] == 4 ? 7 : 10)));
                                    
                                    hole_location |= (one<<hole_bit);
                                }
                                
                                for (int p = 0; p < size; p++) {
                                    int bit = bits2[p][0] + 11*bits2[p][1];
                                    bit -= bits2[p][1] == 0 ? 2 : (bits2[p][1] == 1 ? 5 : (bits2[p][1] == 2 || bits2[p][1] == 3 ? 6 : (bits2[p][1] == 4 ? 7 : 10)));
                                    
                                    location |= (one<<bit);
                                }
                                
                                //                            cout << "RF 5: " << piece << " " << rots << " " << flip << " " << (location == hole_location ? "EQ" : "NE") << "\n";
                                
                                
                                if (find(locs.begin(), locs.end(), location) == locs.end())
                                {
                                    locs.push_back(location);
                                    //                                hole_locs.push_back(hole_location);
                                    
                                    vector<uint64_t> ls;
                                    ls.push_back(hole_location);
                                    
                                    hole_locs.push_back(ls);
                                    
                                    
                                    //                                cout << "S 0: " << bitset<54>(location) << "\n";
                                    //                                cout << "S 1: " << bitset<54>(hole_location) << "\n";
                                    
                                }
                                else
                                {
                                    int w = find(locs.begin(), locs.end(), location) - locs.begin();
                                    
                                    //                                cout << "HOLE AGAIN " << w << " " << hole_locs[w].size() << "\n";
                                    
                                    if(find(hole_locs[w].begin(), hole_locs[w].end(), hole_location) == hole_locs[w].end())
                                    {
                                        hole_locs[w].push_back(hole_location);
                                        
                                        if(piece == 3 && w == 1 && hole_locs[w].size() == 2)
                                        {
//                                            cout << "G 0: " << bitset<54>(location) << "\n";
//                                            cout << "G 1: " << bitset<54>(hole_locs[w][0]) << "\n";
//                                            cout << "G 2: " << bitset<54>(hole_locs[w][1]) << "\n";
//                                            cout << "G 3: " << rots << " " << even << " " << flip << "\n";
                                        }
                                    }
                                }
                                
                                if(V)
                                {
                                    //                                cout << "(";
                                    //                                for(int p = 0; p < size; p++)
                                    //                                {printf("%d", bitsr[p]);if(p<(size-1))cout << ", ";}
                                    //                                cout << ")\n";
                                }
                                
                                //                        vector<int> b2;
                                //
                                //                        for (int t = 0; t < 54; t++)
                                //                        {
                                //                            if ((location>>t)&1)
                                //                            {
                                //                                b2.push_back(t);
                                //                            }
                                //                        }
                                //
                                //                        int size2 = b2.size();//sizeof(b)/sizeof(*b);
                                //
                                //                        if(true)
                                //                        {
                                //                            cout << "(";
                                //                            for(int p = 0; p < size2; p++)
                                //                            {printf("%d", b2[p]);if(p<(size2-1))cout << ", ";}
                                //                            cout << ")\n";
                                //                        }
                            }
                        }
                    }
                    
                    
                    for(int loc = 0; loc < hole_locs.size(); loc++)
                    {
                        (flip == 0 ? (even == 0 ? localized_holes_side1_odd : localized_holes_side1_even) : (even == 0 ? localized_holes_side2_odd : localized_holes_side2_even))[piece][loc+1][0] = hole_locs[loc].size();
                        for (int q = 0; q < hole_locs[loc].size(); q++) {
                            (flip == 0 ? (even == 0 ? localized_holes_side1_odd : localized_holes_side1_even) : (even == 0 ? localized_holes_side2_odd : localized_holes_side2_even))[piece][loc+1][1+q] = hole_locs[loc][q];
                        }
                        
//                        if(piece == 3)
//                        {
//
//                            cout << "piece " << piece << " no flip moves " << noFlipMoveCount[piece] << " total moves " << locations[piece][0] << " 1o " << localized_holes_side1_odd[piece][loc][0]<< " 1e " << localized_holes_side1_even[piece][loc][0]<< " 2o " << localized_holes_side2_odd[piece][loc][0]<< " 2e " << localized_holes_side2_even[piece][loc][0] << "\n";
//                        }
                    }
                    
                    hole_locs_size = hole_locs.size();
//
                    
                }
            }
            
            
            if(piece == 2)
            {
//                cout << "\n\n" << localized_holes_side1_odd[piece][1][0] << "\n" << bitset<54>(locations[piece][78]) << "\n" << bitset<54>(localized_holes_side1_odd[piece][78][1])<< "\n" << bitset<54>(localized_holes_side1_even[piece][78][1]) << "\n";

                for(int loc = 0; loc < noFlipMoveCount[piece]; loc++)
                {
//                    cout << "piece " << piece << " loc " << (loc+1) <<  " no flip moves " << noFlipMoveCount[piece] << " total moves " << locations[piece][0] << " 1o " << localized_holes_side1_odd[piece][loc+1][0]<< " 1e " << localized_holes_side1_even[piece][loc+1][0] << "\n";
                }

                for(int loc = 0; loc < noFlipMoveCount[piece]; loc++)
                {
//                    cout << "piece " << piece << " loc " << (loc+1) <<  " no flip moves " << noFlipMoveCount[piece] << " total moves " << locations[piece][0] << " 2o " << localized_holes_side2_odd[piece][loc+1][0]<< " 2e " << localized_holes_side2_even[piece][loc+1][0] << "\n";
                }

            }
            
            

//            localized_holes[piece][0] = hole_locs.size();
            
//            cout << "SIZE " << hole_locs.size() << "\n";

//                uint64_t locz_holes = (flip == 0 ? localized_holes : localized_holes_flipped);
            
            


        }
        
//                vector<int> b; EDIT: print function from here to end of "for"
//
//                for (int t = 0; t < 54; t++)
//                {
//                    if ((localized_holes[piece][1+loc]>>t)&1)
//                    {
//                        b.push_back(t);
//                    }
//                }
//
//                int size = b.size();//sizeof(b)/sizeof(*b);
//
//                if(true)
//                {
//                    cout << "["<<(loc+1)<<"] (";
//                    for(int p = 0; p < size; p++)
//                    {printf("%d", b[p]);if(p<(size-1))cout << ", ";}
//                    cout << ")\n";
//                }
        
        //        vector<int> b;
        //
        //        for (int t = 0; t < 54; t++)
        //        {
        //            if ((locations[0][10]>>t)&1)
        //            {
        //                b.push_back(t);
        //            }
        //        }
        //
        //        int size = b.size();//sizeof(b)/sizeof(*b);
        //
        //        if(true)
        //        {
        //            cout << "+++ (";
        //            for(int p = 0; p < size; p++)
        //            {printf("%d", b[p]);if(p<(size-1))cout << ", ";}
        //            cout << ")\n";
        //        }

    //            cout << "\n\n";
//
//
//    array<array<uint64_t, numPieces>, (14*6*2+1)> xs;
//
//    return xs;
//    int bits[] = {0,1,2};
//    bool done = false;
//    int size = sizeof(bits)/sizeof(*bits), inc = 0, aff = bits[0] % 2 == 0 ? 1 : -1;
//
//    for (int j = 0; j < size; j++)
//        bits[j] -= 2;
//
//
//
//
//    while(true)
//    {
//        bool touchingLeft = false, touchingRight = false;
//
//        for (int j = 0; j < size; j++)
//        {
//            int bit = bits[j] + 2;
//            touchingRight = touchingRight || bit == 6 || bit == 15 || bit == 26 || bit == 37 || bit == 46 || bit == 53;
//            touchingLeft = touchingLeft || bit == 0 || bit == 7 || bit == 16 || bit == 27 || bit == 38 || bit == 47;
//
//            if(bit > 53)
//            {
//                done = true;
//                break;
//            }
//
//            if(((bits[j] <= 6 && bit > 6) || (bits[j] <= 15 && bit > 15)))
//            {inc = -1 * aff; printf("\n");}
//
//            if(((bits[j] <= 37 && bit > 37) || (bits[j] <= 46 && bit > 46)))
//            {inc = 1 * aff; printf("\n");}
//
//            bits[j] = bit + inc;
//        }
//
//
//        if(done)
//            break;
//
//
//
//        if(!(touchingLeft && touchingRight))
//        {
////            table.add(bits);
//            printf("(%d, %d, %d)  ", bits[0], bits[1], bits[2]);
//        }
////        else
////        {
////            for (int j = 0; j < size; j++)
////                bits[j] += inc;
////        }
//
//        inc = 0;
//    }
//
//    bits(0, 1, 2), bits(2, 3, 4), bits(4, 5, 6),
//    bits(7, 8, 9), bits(9, 10, 11), bits(11, 12, 13), bits(13, 14, 15),
//    bits(16, 17, 18), bits(18, 19, 20), bits(20, 21, 22), bits(22, 23, 24), bits(24, 25, 26),
//    bits(28, 29, 30), bits(30, 31, 32), bits(32, 33, 34), bits(34, 35, 36),
//    bits(39, 40, 41), bits(41, 42, 43), bits(43, 44, 45),
//    bits(48, 49, 50), bits(50, 51, 52),
    
    
//
//    // downward pieces
//    bits(1, 2, 3), bits(3, 4, 5),
//    bits(8, 9, 10), bits (10, 11, 12), bits(12, 13, 14),
//    bits(17, 18, 19), bits(19, 20, 21), bits(21, 22, 23), bits(23, 24, 25),
//    bits(27, 28, 29), bits(29, 30, 31), bits(31, 32, 33), bits(33, 34, 35), bits(35, 36, 37),
//    bits(38, 39, 40), bits(40, 41, 42), bits(42, 43, 44), bits(44, 45, 46),
//    bits(47, 48, 49), bits(49, 50, 51), bits(51, 52, 53),
//    // one clockwise rotation
//    bits(5, 6, 14), bits(14, 15, 25), bits(25, 26, 37),
//    bits(3, 4, 12), bits(12, 13, 23), bits(23, 24, 35), bits(35, 36, 46),
//    bits(1, 2, 10), bits(10, 11, 21), bits(21, 22, 33), bits(33, 34, 44), bits(44, 45, 53),
//    bits(8, 9, 19), bits(19, 20, 31), bits(31, 32, 42), bits(42, 43, 51),
//    bits(17, 18, 29), bits(29, 30, 40), bits(40, 41, 49),
//    bits(27, 28, 38), bits(38, 39, 47),
//    // one clockwise rotation downward
//    bits(6, 14, 15), bits(15, 25, 26),
//    bits(4, 12, 13), bits(13, 23, 24), bits(24, 35, 36),
//    bits(2, 10, 11), bits(11, 21, 22), bits(22, 33, 34), bits(34, 44, 45),
//    bits(0, 8, 9), bits(9, 19, 20), bits(20, 31, 32), bits(32, 42, 43), bits(43, 51, 52),
//    bits(7, 17, 18), bits(18, 29, 30), bits(30, 40, 41), bits(41, 49, 50),
//    bits(16, 27, 28), bits(28, 38, 39), bits(39, 47, 48),
//    // two clockwise rotations
//    bits(27, 16, 17), bits(17, 7, 8), bits(8, 0, 1),
//    bits(38, 28, 29), bits(29, 18, 19), bits(19, 9, 10), bits(10, 2, 3),
//    bits(47, 39, 40), bits(40, 30, 31), bits(31, 20, 21), bits(21, 11, 12), bits(12, 4, 5),
//    bits(49, 41, 42), bits(42, 32, 33), bits(33, 22, 23), bits(23, 13, 14),
//    bits(51, 43, 44), bits(44, 34, 35), bits(35, 24, 25),
//    bits(53, 45, 46), bits(46, 36, 37),
//    // two clockwise rotations downward
//    bits(16, 17, 7), bits(7, 8, 0),
//    bits(28, 29, 18), bits(18, 19, 9), bits(9, 10, 2),
//    bits(39, 40, 30), bits(30, 31, 20), bits(20, 21, 11), bits(11, 12, 4),
//    bits(48, 49, 41), bits(41, 42, 32), bits(32, 33, 22), bits(22, 23, 13), bits(13, 14, 6),
//    bits(50, 51, 43), bits(43, 44, 34), bits(34, 35, 24), bits(24, 25, 15),
//    bits(52, 53, 45), bits(45, 46, 36), bits(36, 37, 26)

    //    bits(0, 1, 2, 3, 4, 5),
//    bits(7, 8, 9, 10, 11, 12), bits(9, 10, 11, 12, 13, 14),
//    bits(16, 17, 18, 19, 20, 21), bits(18, 19, 20, 21, 22, 23), bits(20, 21, 22, 23, 24, 25),
//    bits(28, 29, 30, 31, 32, 33), bits(30, 31, 32, 33, 34, 35), bits(32, 33, 34, 35, 36, 37),
//    bits(39, 40, 41, 42, 43, 44), bits(41, 42, 43, 44, 45, 46),
//    bits(48, 49, 50, 51, 52, 53),
    
//    bits(28, 38, 39, 47, 48, 49), bits(16, 27, 28, 38, 39, 40),
//    bits(30, 40, 41, 49, 50, 51), bits(18, 29, 30, 40, 41, 42), bits(7, 17, 18, 29, 30, 31),
//    bits(32, 42, 43, 51, 52, 53), bits(20, 31, 32, 42, 43, 44), bits(9, 19, 20, 31, 32, 33), bits(0, 8, 9, 19, 20, 21),
//    bits(22, 33, 34, 44, 45, 46), bits(11, 21, 22, 33, 34, 35), bits(2, 10, 11, 21, 22, 23),
//    bits(13, 23, 24, 35, 36, 37),
}

/*
 
 pieces:
     flips:
         rotations:
            locations
            - similar? add to location holes list
            - new? add a new location
 
 
 
 [bits(), bits(), ...]
    |
    V
 [holes(), holes(), holes(), ...]
 
*/


string HexagonEnvironment::PrintHexagonState(HexagonState &hs){
    string res = "";
    for (int t = 0; t < 66; t++)// goes to 66 for hss!
    {
        if(t % 11 == 0 && t != 0) res += "\n";
        int p = hs.state.Get(t);
        res += p == 15 ? "x" : to_string(p);
    }
    
    return res;
}

void Hexagon::GetSuccessors(const HexagonState &nodeID, vector<HexagonState> &neighbors) const
{
	
}

void Hexagon::GetActions(const HexagonState &nodeID, vector<HexagonAction> &actions) const
{
	
}

HexagonAction Hexagon::GetAction(const HexagonState &s1, const HexagonState &s2) const
{
	HexagonAction a;
	return a;
}

void Hexagon::ApplyAction(HexagonState &s, HexagonAction a) const
{
	
}

void Hexagon::GetNextState(const HexagonState &, HexagonAction , HexagonState &) const
{
	
}

bool Hexagon::InvertAction(HexagonAction &a) const
{
	return true;
}


uint64_t Hexagon::GetStateHash(const HexagonState &node) const
{
	return 0;
}

uint64_t Hexagon::GetActionHash(HexagonAction act) const
{
	return 0;
}

/** Goal Test if the goal is stored **/
bool Hexagon::GoalTest(const HexagonState &node) const
{
	return true;
}

void Hexagon::RotateCW(HexagonState &s) const
{
	
}


bool Hexagon::GetBorder(int x, int y, int xoff, int yoff, Graphics::point &p1, Graphics::point &p2) const
{
	const float triangleWidth = 2.0/7;
	const float triangleHeight = triangleWidth/1.154700538379252; // 2/sqrt(3)
	const float xMargin = triangleWidth/2;
	const float yMargin = (2.0-triangleHeight*6)/2;
//	const float triangleHeight = 2.0/7;
//	const float triangleWidth = 1.154700538379252*triangleHeight; // 2/sqrt(3)
//	const float margin = triangleHeight/2;
	
	if (0==(x+y)%2) // points up
	{
		if (yoff < 0)
		{
			return false;
		}
		else if (xoff > 0)
		{
			p1 = {
				-1+xMargin+(x+2)*triangleWidth/2,
				-1+yMargin+(y+1)*triangleHeight
			};
			p2 = {
				-1+xMargin+(x+1)*triangleWidth/2,
				-1+yMargin+(y)*triangleHeight
			};
		}
		else if (xoff < 0)
		{
			p1 = {
				-1+xMargin+x*triangleWidth/2,
				-1+yMargin+(y+1)*triangleHeight
			};
			p2 = {
				-1+xMargin+(x+1)*triangleWidth/2,
				-1+yMargin+(y)*triangleHeight
			};
		}
		else if (yoff > 0)
		{
			p1 = {
				-1+xMargin+x*triangleWidth/2,
				-1+yMargin+(y+1)*triangleHeight
			};
			p2 = {
				-1+xMargin+(x+2)*triangleWidth/2,
				-1+yMargin+(y+1)*triangleHeight
			};
		}
		return true;
	}
	else { // points down
		if (yoff > 0)
		{
			return false;
		}
		else if (xoff > 0)
		{
			// upper right
			p1 = {
				-1+xMargin+(x+2)*triangleWidth/2,
				-1+yMargin+(y)*triangleHeight
			};
			// bottom tip
			p2 = {
				-1+xMargin+(x+1)*triangleWidth/2,
				-1+yMargin+(y+1)*triangleHeight
			};
		}
		else if (xoff < 0)
		{
			// upper left
			p1 = {
				-1+xMargin+(x)*triangleWidth/2,
				-1+yMargin+(y)*triangleHeight
			};
			// bottom tip
			p2 = {
				-1+xMargin+(x+1)*triangleWidth/2,
				-1+yMargin+(y+1)*triangleHeight
			};
		}
		else if (yoff < 0)
		{
			// upper right
			p1 = {
				-1+xMargin+(x+2)*triangleWidth/2,
				-1+yMargin+(y)*triangleHeight
			};
			// upper left
			p2 = {
				-1+xMargin+(x)*triangleWidth/2,
				-1+yMargin+(y)*triangleHeight
			};
		}
		return true;
//		// upper right
//		p1 = {
//			-1+margin+(x+2)*triangleHeight/2,
//			-1+margin+(y)*triangleHeight
//		};
//		// upper left
//		p2 = {
//			-1+margin+(x)*triangleHeight/2,
//			-1+margin+(y)*triangleHeight
//		};
//		// bottom tip
//		p3 = {
//			-1+margin+(x+1)*triangleHeight/2,
//			-1+margin+(y+1)*triangleHeight
//		};
//		return false;
	}
}

void Hexagon::GetCorners(int x, int y, Graphics::point &p1, Graphics::point &p2, Graphics::point &p3) const
{
	const float triangleWidth = 2.0/7;
	const float triangleHeight = triangleWidth/1.154700538379252; // 2/sqrt(3)
	const float xMargin = triangleWidth/2;
	const float yMargin = (2.0-triangleHeight*6)/2;

	if (0==(x+y)%2) // points up
	{
		p1 = {
			-1+xMargin+x*triangleWidth/2,
			-1+yMargin+(y+1)*triangleHeight
		};
		p2 = {
			-1+xMargin+(x+2)*triangleWidth/2,
			-1+yMargin+(y+1)*triangleHeight
		};
		p3 = {
			-1+xMargin+(x+1)*triangleWidth/2,
			-1+yMargin+(y)*triangleHeight
		};
	}
	else { // points down
		p1 = {
			-1+xMargin+(x+2)*triangleWidth/2,
			-1+yMargin+(y)*triangleHeight
		};
		p2 = {
			-1+xMargin+(x)*triangleWidth/2,
			-1+yMargin+(y)*triangleHeight
		};
		p3 = {
			-1+xMargin+(x+1)*triangleWidth/2,
			-1+yMargin+(y+1)*triangleHeight
		};
	}
}

bool Hexagon::Valid(int x, int y) const
{
	static bool valid[6][11] =
	{
		{false, false, true, true, true, true, true, true, true, false, false},
		{false, true, true, true, true, true, true, true, true, true, false},
		{true, true, true, true, true, true, true, true, true, true, true},
		{true, true, true, true, true, true, true, true, true, true, true},
		{false, true, true, true, true, true, true, true, true, true, false},
		{false, false, true, true, true, true, true, true, true, false, false}
	};
	return valid[y][x];
}

void Hexagon::Draw(Graphics::Display &display) const
{
//    return;
	// Draw board
	display.FillRect(Graphics::rect({0,0}, 1.0), Colors::white);
	for (int y = 0; y < 6; y++)
	{
		for (int x = 0; x < 11; x++)
		{
			if (!Valid(x, y))
				//if (!valid[y][x])
				continue;
			Graphics::point p1, p2, p3;
			GetCorners(x, y, p1, p2, p3);
			display.FillTriangle(p1, p2, p3, Colors::lightgray);
			display.FrameTriangle(p1, p2, p3, 0.01f, Colors::darkgray);
		}
	}
	float xLoc = -1, yLoc = -1;
	float dim = 0.1;
	
	if (noFlipPieces.size() != 0)
	{
		display.FillRect({xLoc, yLoc, xLoc+dim, yLoc+dim}, pieceColors[noFlipPieces[0]]);
		display.DrawText("Cannot Flip", {xLoc+1.2f*dim, yLoc+dim/2.0f}, Colors::black, dim*0.8f, Graphics::textAlignLeft, Graphics::textBaselineMiddle);
		xLoc = 0;
	}
    if (diagPieces.size() != 0)
    {
        display.FillRect({xLoc, yLoc, xLoc+dim, yLoc+dim}, pieceColors[diagPieces[0]]);
        display.DrawText("Must Touch Diagonally", {xLoc+1.2f*dim, yLoc+dim/2.0f}, Colors::black, dim*0.8f, Graphics::textAlignLeft, Graphics::textBaselineMiddle);
        xLoc = 0;
    }
    if (notDiagPieces.size() != 0)
    {
        display.FillRect({xLoc, yLoc, xLoc+dim, yLoc+dim}, pieceColors[diagPieces[0]]);
        display.DrawText("Must Not Touch Diagonally", {xLoc+1.2f*dim, yLoc+dim/2.0f}, Colors::black, dim*0.8f, Graphics::textAlignLeft, Graphics::textBaselineMiddle);
        xLoc = 0;
    }
	if (notTouchPieces.size() != 0)
	{
		display.FillRect({xLoc, yLoc, xLoc+dim, yLoc+dim}, pieceColors[notTouchPieces[0]]);
		display.DrawText("Cannot Touch", {xLoc+1.2f*dim, yLoc+dim/2.0f}, Colors::black, dim*0.8f, Graphics::textAlignLeft, Graphics::textBaselineMiddle);
		xLoc = 0;
	}
	if (touchPieces.size() != 0)
	{
		display.FillRect({xLoc, yLoc, xLoc+dim, yLoc+dim}, pieceColors[touchPieces[0]]);
		display.DrawText("Must Touch Edges", {xLoc+1.2f*dim, yLoc+dim/2.0f}, Colors::black, dim*0.8f, Graphics::textAlignLeft, Graphics::textBaselineMiddle);
		xLoc = 0;
	}
}

void Hexagon::DrawSetup(Graphics::Display &display) const
{
	// Draw board
	display.FillRect(Graphics::rect({0,0}, 1.0), Colors::white);

	// Horribly inefficient for now; just looking for correctness
	// Could all be pre-computed and cached
	for (int piece = 0; piece < 10; piece++)
	{
		bool found = false;
		Graphics::rect bounds;
		// get bounding box for piece
		for (int y = 0; y < 6; y++)
		{
			for (int x = 0; x < 11; x++)
			{
				if (!Valid(x, y))
					continue;
				int p = solution.state.Get(y*11+x);
				if (piece == p)
				{
					Graphics::point p1, p2, p3;
					GetCorners(x, y, p1, p2, p3);

					if (!found)
					{
						found = true;
						bounds = Graphics::rect(p1, p2);
					}
					else
                    {
						bounds |= Graphics::rect(p1, p2);
					}
					bounds |= Graphics::rect(p2, p1);
					bounds |= Graphics::rect(p2, p3);
					bounds |= Graphics::rect(p3, p2);
					bounds |= Graphics::rect(p1, p3);
					bounds |= Graphics::rect(p3, p1);
				}
			}
		}

		float newWidth = 0.45f;
		float newHeight = 0.45f;
		float border = 0.01;
		float scale = 0.45f/max(bounds.right-bounds.left, bounds.bottom-bounds.top);
		float baseX = -0.9f+(piece%4)*(newWidth+border);
		float baseY = -0.7f+(piece>>2)*(newHeight+border);
//		cout << "Piece " << piece << " rect: " << bounds << "\n";
		// draw piece scaled
		for (int y = 0; y < 6; y++)
		{
			for (int x = 0; x < 11; x++)
			{
				if (!Valid(x, y))
					continue;
				int p = solution.state.Get(y*11+x);
				if (piece == p)
				{
					Graphics::point p1, p2, p3;
					GetCorners(x, y, p1, p2, p3);
					p1.x = baseX+(p1.x-bounds.left)*scale;
					p1.y = baseY+(p1.y-bounds.top)*scale;
					p2.x = baseX+(p2.x-bounds.left)*scale;
					p2.y = baseY+(p2.y-bounds.top)*scale;
					p3.x = baseX+(p3.x-bounds.left)*scale;
					p3.y = baseY+(p3.y-bounds.top)*scale;
					display.FillTriangle(p1, p2, p3, pieceColors[piece]);
				}
			}
		}
	}
	
	// Draw constraints at top
	{
		float xLoc = -1, yLoc = -1;
		float dim = 0.1;
		
		if (noFlipPieces.size() != 0)
		{
			display.FillRect({xLoc, yLoc, xLoc+dim, yLoc+dim}, pieceColors[noFlipPieces[0]]);
			display.DrawText("Cannot Flip", {xLoc+1.2f*dim, yLoc+dim/2.0f}, Colors::black, dim*0.8f, Graphics::textAlignLeft, Graphics::textBaselineMiddle);
			xLoc = 0;
		}
        if (diagPieces.size() != 0)
        {
//            display.FillRect({xLoc, yLoc, xLoc+dim, yLoc+dim}, pieceColors[diagPieces[0]]);
//            display.DrawText("Must Touch Diagonally", {xLoc+1.2f*dim, yLoc+dim/2.0f}, Colors::black, dim*0.8f, Graphics::textAlignLeft, Graphics::textBaselineMiddle);
//            xLoc = 0;
            
            display.FillRect({xLoc, yLoc, xLoc+dim, yLoc+dim}, pieceColors[diagPieces[0]]);
            xLoc += 1.2f * dim;
            display.FillRect({xLoc, yLoc, xLoc+dim, yLoc+dim}, pieceColors[diagPieces[1]]);
            xLoc += 1.2f * dim;
            display.DrawText("Must Touch Corners", {xLoc, yLoc+dim/2.0f}, Colors::black, dim*0.8f, Graphics::textAlignLeft, Graphics::textBaselineMiddle);
            xLoc = 0;
        }
        if (notDiagPieces.size() != 0)
        {
//            display.FillRect({xLoc, yLoc, xLoc+dim, yLoc+dim}, pieceColors[notDiagPieces[0]]);
//            display.DrawText("Must Not Touch Diagonally", {xLoc+1.2f*dim, yLoc+dim/2.0f}, Colors::black, dim*0.8f, Graphics::textAlignLeft, Graphics::textBaselineMiddle);
//            xLoc = 0;
            
            display.FillRect({xLoc, yLoc, xLoc+dim, yLoc+dim}, pieceColors[notDiagPieces[0]]);
            xLoc += 1.2f * dim;
            display.FillRect({xLoc, yLoc, xLoc+dim, yLoc+dim}, pieceColors[notDiagPieces[1]]);
            xLoc += 1.2f * dim;
            display.DrawText("Must Not Touch Corners", {xLoc, yLoc+dim/2.0f}, Colors::black, dim*0.8f, Graphics::textAlignLeft, Graphics::textBaselineMiddle);
            xLoc = 0;
        }
		if (notTouchPieces.size() != 0)
		{
//			display.FillRect({xLoc, yLoc, xLoc+dim, yLoc+dim}, pieceColors[notTouchPieces[0]]);
//			display.DrawText("Cannot Touch", {xLoc+1.2f*dim, yLoc+dim/2.0f}, Colors::black, dim*0.8f, Graphics::textAlignLeft, Graphics::textBaselineMiddle);
//			xLoc = 0;
            
            display.FillRect({xLoc, yLoc, xLoc+dim, yLoc+dim}, pieceColors[notTouchPieces[0]]);
            xLoc += 1.2f * dim;
            display.FillRect({xLoc, yLoc, xLoc+dim, yLoc+dim}, pieceColors[notTouchPieces[1]]);
            xLoc += 1.2f * dim;
            display.DrawText("Must Not Touch Edges", {xLoc, yLoc+dim/2.0f}, Colors::black, dim*0.8f, Graphics::textAlignLeft, Graphics::textBaselineMiddle);
            xLoc = 0;
		}
		if (touchPieces.size() != 0)
		{
            display.FillRect({xLoc, yLoc, xLoc+dim, yLoc+dim}, pieceColors[touchPieces[0]]);
            xLoc += 1.2f * dim;
            display.FillRect({xLoc, yLoc, xLoc+dim, yLoc+dim}, pieceColors[touchPieces[1]]);
            xLoc += 1.2f * dim;
			display.DrawText("Must Touch Edges", {xLoc, yLoc+dim/2.0f}, Colors::black, dim*0.8f, Graphics::textAlignLeft, Graphics::textBaselineMiddle);
			xLoc = 0;
		}
	}
}

const int revMapPiece[numPieces+1] = {7, 1, 0, 4, 6, 5, 3, 2, 8, 9, 8};// 8, 8/i 9/j
const float specialColors[5] = {0, 0.2, 0.5, 0.65, 0.8};

void Hexagon::Draw(Graphics::Display &display, const HexagonState &s) const
{
	// Draw objects
	for (int y = 0; y < 6; y++)
	{
		for (int x = 0; x < 11; x++)
		{
			if (!Valid(x, y))
				continue;
			Graphics::point p1, p2, p3;
			GetCorners(x, y, p1, p2, p3);
			int piece = s.state.Get(y*11+x);
			if (piece < 11)
			{
                /**
                 
                 int noFlipMoveCount[numPieces] =
                 {
                 //    kHexagon = 0, 2/c
                     4, // no flip symmetry
                 //    kButterfly = 1, 1/b
                     42, // no flip symmetry
                 //    kElbow = 2, 7/h
                     72, // no symmetry
                 //    kLine = 3, 6/g
                     72/2,
                 //    kMountains = 4, 3/d
                     156/2,
                 //    kWrench = 5, 5/f
                     156/2,
                 //    kTriangle = 6, 4/e
                     144/2,
                 //    kHook = 7, 0/a
                     168/2,
                 //    kTrapezoid = 8, 8/i 9/j
                     126,
                 //    kSnake = 9
                     72/2
                 };
                 
                 */
                int convPiece = revMapPiece[piece];
                int pp1 = comb % 4, pp2 = comb / 4;

                if(pp1 == pp2) pp2 = 3;
                
//                cout << "Piece: " << piece << " " << convPiece << " || " << pp1 << " " << pp2 << "\n";

                display.FillTriangle(p1, p2, p3, rgbColor::hsl(specialColors[convPiece < 2 ? 0 : ((convPiece == 3 || convPiece == 9) ? 1 : ((convPiece == 2 || convPiece == 8) ? 2 : ((convPiece == (pp1+4) || convPiece == (pp2+4)) ? 3 : 4)))], 0.5, 0.5));//pieceColors[piece]);(piece%2)?1.0:
			}
		}
	}
	// Draw Borders
	for (int y = 0; y < 6; y++)
	{
		for (int x = 0; x < 11; x++)
		{
//			if (!Valid(x, y))
//				//if (!valid[y][x])
//				continue;
			Graphics::point p1, p2, p3;
			GetCorners(x, y, p1, p2, p3);
			int piece = s.state.Get(y*11+x);
            
            if(piece == 15) continue;
            
            cout << piece << " " <<s.state.Get(y*11+x+1)<<"\n";
            
//            continue;
            if ((x == 10) || (piece != s.state.Get(y*11+x+1)))
//			if ((x < 10 && piece != s.state.Get(y*11+x+1)))// && (piece != 11 || s.state.Get(y*11+x+1) != 15)))
			{
				if (GetBorder(x, y, 1, 0, p1, p2))
				{
					display.DrawLine(p1, p2, 0.02, Colors::black);
				}
			}
            if ((x == 0) || (x > 0 && piece != s.state.Get(y*11+x-1)))
//			if ((x > 0 && piece != s.state.Get(y*11+x-1)))// && (piece != 11 || s.state.Get(y*11+x-1) != 15)))
			{
				if (GetBorder(x, y, -1, 0, p1, p2))
				{
					display.DrawLine(p1, p2, 0.02, Colors::black);
				}
			}
            if ((y == 5) || (y < 5 && piece != s.state.Get((y+1)*11+x)))
//			if ((y < 5 && piece != s.state.Get((y+1)*11+x)))// && (piece != 11 || s.state.Get((y+1)*11+x) != 15)))
			{
				if (GetBorder(x, y, 0, 1, p1, p2))
				{
					display.DrawLine(p1, p2, 0.02, Colors::black);
				}
			}
            if ((y == 0) || (y > 0 && piece != s.state.Get((y-1)*11+x)))
//			if ((y > 0 && piece != s.state.Get((y-1)*11+x)))// && (piece != 11 || s.state.Get((y-1)*11+x) != 15)))
			{
				if (GetBorder(x, y, 0, -1, p1, p2))
				{
					display.DrawLine(p1, p2, 0.02, Colors::black);
				}
			}
		}
	}
    
    return;
    
    float dim = 0.1;
    float xLoc = -1 + dim/2.0f, yLoc = -1 + dim/2.0f;

    for (auto con : s.constraints) {
        int constraintType = con % 5;
        int p1 = (con / 10) % numPieces;
        int p2 = (con / 10) / numPieces;
                
        display.FillRect({xLoc, yLoc, xLoc+dim, yLoc+dim}, rgbColor::hsl(specialColors[p1], 0.5, 0.5));
        xLoc += 1.2f * dim;
        display.DrawText((constraintType == 1 ? "Must Not Touch Edges With" : (constraintType == 2 ? "Must Touch Edges With" : (constraintType == 3 ? "Must Not Touch Corners With" : "Must Touch Corners With"))), {xLoc, yLoc+dim/2.0f}, Colors::black, dim*0.8f, Graphics::textAlignLeft, Graphics::textBaselineMiddle);
        
        xLoc += (constraintType == 1 ? 11 : (constraintType == 2 ? 9.45 : (constraintType == 3 ? 11.5 : 10))) * dim;
        
        display.FillRect({xLoc, yLoc, xLoc+dim, yLoc+dim},rgbColor::hsl(specialColors[p2], 0.5, 0.5));
        xLoc = -0.9f;
        yLoc += 1.2f * dim;
    }
    
    xLoc = -1;
    yLoc = -1;

    display.DrawText(s.dots == 0 ? "Free" : "Dots", {1-dim/2.0f, dim+ yLoc}, Colors::black, dim*0.8f, Graphics::textAlignRight, Graphics::textBaselineMiddle);
    
    xLoc = -1;
    yLoc = -1;

    if(s.entropy != 0)
    {
        stringstream ss;
        ss << s.entropy;
        string str = ss.str();
        const char* buf = str.c_str();
        
        display.DrawText(buf, {1-dim/2.0f, 1 - dim}, rgbColor::hsl(0.33f - (s.entropy/24.0f)/3.0f, 0.5, 0.5), dim*0.8f, Graphics::textAlignRight, Graphics::textBaselineMiddle);
    }
    
    if(s.forbiddenPiece == -1) return;
    
    display.DrawText("Forbidden:", {-0.75f, 0.75}, Colors::black, dim*0.8f, Graphics::textAlignCenter, Graphics::textBaselineMiddle);
    
    float forbiddenScale = 0.25f, forbiddenX = -0.75f, forbiddenY = 1;
    
    int index = -1;
    
    for (int y = 0; y < 6; y++)
    {
        for (int x = 0; x < 11; x++)
        {
            if (!Valid(x, y))
                continue;
            
            index++;
            
            if(((locations[s.forbiddenPiece][1]>>index)&1) == 0) continue;
            
            Graphics::point p1, p2, p3;
            GetCorners(x, y, p1, p2, p3);
            
            p1 = { forbiddenX + p1.x * forbiddenScale , forbiddenY + p1.y * forbiddenScale};
            p2 = { forbiddenX + p2.x * forbiddenScale , forbiddenY + p2.y * forbiddenScale};
            p3 = { forbiddenX + p3.x * forbiddenScale , forbiddenY + p3.y * forbiddenScale};
            
//            int piece = s.state.Get(y*11+x);
            int piece = mapPiece[s.forbiddenPiece];
            if (piece < 11)
            {
                int convPiece = revMapPiece[piece];
                int pp1 = comb % 4, pp2 = comb / 4;

                if(pp1 == pp2) pp2 = 3;
                
                display.FillTriangle(p1, p2, p3, rgbColor::hsl(specialColors[convPiece < 2 ? 0 : ((convPiece == 3 || convPiece == 9) ? 1 : ((convPiece == 2 || convPiece == 8) ? 2 : ((convPiece == (pp1+4) || convPiece == (pp2+4)) ? 3 : 4)))], 0.5, 0.5));
            }
        }
    }
            
//    index = -1;
//
//    for (int y = 0; y < 6; y++)
//    {
//        for (int x = 0; x < 11; x++)
//        {
//            if (!Valid(x, y))
//                continue;
//
//            index++;
//
//            if(((locations[s.forbiddenPiece][1]>>index)&1) == 0) continue;
//
//            Graphics::point p1, p2, p3;
//            GetCorners(x, y, p1, p2, p3);
//
//            p1 = { -0.75f + p1.x * 0.25f , 0.75f + p1.y * 0.25f};
//            p2 = { -0.75f + p2.x * 0.25f , 0.75f + p2.y * 0.25f};
//            p3 = { -0.75f + p3.x * 0.25f , 0.75f + p3.y * 0.25f};
//
////            int piece = s.state.Get(y*11+x);
//            int piece = mapPiece[s.forbiddenPiece];
//
//            if ((x == 10) || (piece != s.state.Get(y*11+x+1)))
//            {
//                if (GetBorder(x, y, 1, 0, p1, p2))
//                {
//                    p1 = { -0.75f + p1.x * 0.25f , 0.75f + p1.y * 0.25f};
//                    p2 = { -0.75f + p2.x * 0.25f , 0.75f + p2.y * 0.25f};
//                    display.DrawLine(p1, p2, 0.02, Colors::black);
//                }
//            }
//            if ((x == 0) || (x > 0 && piece != s.state.Get(y*11+x-1)))
//            {
//                if (GetBorder(x, y, -1, 0, p1, p2))
//                {
//                    p1 = { -0.75f + p1.x * 0.25f , 0.75f + p1.y * 0.25f};
//                    p2 = { -0.75f + p2.x * 0.25f , 0.75f + p2.y * 0.25f};
//                    display.DrawLine(p1, p2, 0.02, Colors::black);
//                }
//            }
//            if ((y == 5) || (y < 5 && piece != s.state.Get((y+1)*11+x)))
//            {
//                if (GetBorder(x, y, 0, 1, p1, p2))
//                {
//                    p1 = { -0.75f + p1.x * 0.25f , 0.75f + p1.y * 0.25f};
//                    p2 = { -0.75f + p2.x * 0.25f , 0.75f + p2.y * 0.25f};
//                    display.DrawLine(p1, p2, 0.02, Colors::black);
//                }
//            }
//            if ((y == 0) || (y > 0 && piece != s.state.Get((y-1)*11+x)))
//            {
//                if (GetBorder(x, y, 0, -1, p1, p2))
//                {
//                    p1 = { -0.75f + p1.x * 0.25f , 0.75f + p1.y * 0.25f};
//                    p2 = { -0.75f + p2.x * 0.25f , 0.75f + p2.y * 0.25f};
//                    display.DrawLine(p1, p2, 0.02, Colors::black);
//                }
//            }
//        }
//    }
}

